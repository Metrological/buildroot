diff -Naur kernel-3.3-3.0a-ref/arch/mips/brcmstb/Platform kernel-current/arch/mips/brcmstb/Platform
--- kernel-3.3-3.0a-ref/arch/mips/brcmstb/Platform	2013-08-28 01:30:56.000000000 +0200
+++ kernel-current/arch/mips/brcmstb/Platform	2013-11-29 10:10:03.163205852 +0100
@@ -3,6 +3,6 @@
 #
 platform-$(CONFIG_BRCMSTB)	+= brcmstb/
 cflags-$(CONFIG_BRCMSTB)	+= -I$(srctree)/arch/mips/include/asm/mach-brcmstb
-load-$(CONFIG_BRCMSTB)		+= 0x80001000
+load-$(CONFIG_BRCMSTB)		+= 0x80004000
 
 cflags-$(CONFIG_NO_INLINE)	+= -fno-inline
diff -Naur kernel-3.3-3.0a-ref/arch/mips/brcmstb/prom.c kernel-current/arch/mips/brcmstb/prom.c
--- kernel-3.3-3.0a-ref/arch/mips/brcmstb/prom.c	2013-08-28 01:30:56.000000000 +0200
+++ kernel-current/arch/mips/brcmstb/prom.c	2013-11-29 10:10:03.155205923 +0100
@@ -210,6 +210,7 @@
 	} while (0)
 
 	FETCH("ETH0_HWADDR", parse_eth0_hwaddr, brcm_primary_macaddr);
+	FETCH("MOCA_HWADDR", parse_eth0_hwaddr, brcm_moca_macaddr);
 	FETCH("ETH0_MDIO_MODE", parse_eth0_mdio_mode, &brcm_eth0_no_mdio);
 	FETCH("ETH0_PHY", parse_string, brcm_eth0_phy);
 	FETCH("ETH0_PHYADDR", parse_string, brcm_eth0_phyaddr);
diff -Naur kernel-3.3-3.0a-ref/block/genhd.c kernel-current/block/genhd.c
--- kernel-3.3-3.0a-ref/block/genhd.c	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/block/genhd.c	2013-11-29 10:10:03.247205115 +0100
@@ -21,6 +21,10 @@
 
 #include "blk.h"
 
+#ifdef CONFIG_KDEV_DRIVER
+#include <linux/kdev.h>
+#endif
+
 static DEFINE_MUTEX(block_class_lock);
 struct kobject *block_depr;
 
@@ -263,6 +267,42 @@
 }
 #endif /* CONFIG_PROC_FS */
 
+
+#ifdef CONFIG_KDEV_DRIVER
+
+int blkdev_getList(kdev_ioc_getDevices_t * listOfBlkDev)
+{
+  unsigned int index;
+  unsigned int offset = 0;
+  struct blk_major_name * bd;
+  
+  mutex_lock(&block_class_lock);
+  index = listOfBlkDev->devs_nb;
+  
+  for(offset = 0; offset < BLKDEV_MAJOR_HASH_SIZE; offset++)
+  {
+    for (bd = major_names[offset]; bd; bd = bd->next)
+    {
+      listOfBlkDev->devs[index].device_type = KDEV_BLOCK_DEV;
+      strlcpy(listOfBlkDev->devs[index].device_name, bd->name, sizeof(bd->name));
+      listOfBlkDev->devs[index].major = bd->major;
+      listOfBlkDev->devs[index].min_minor = 0;
+      listOfBlkDev->devs[index].max_minor = 0;
+      
+      index++;
+      if(index == (sizeof(listOfBlkDev->devs)/sizeof(kdev_dev_t)))
+        return 1;
+    }
+  }
+  
+  listOfBlkDev->devs_nb = index;
+  mutex_unlock(&block_class_lock);
+  
+  return 0;
+}
+
+#endif /* CONFIG_KDEV_DRIVER */
+
 /**
  * register_blkdev - register a new block device
  *
diff -Naur kernel-3.3-3.0a-ref/drivers/ata/libata-core.c kernel-current/drivers/ata/libata-core.c
--- kernel-3.3-3.0a-ref/drivers/ata/libata-core.c	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/ata/libata-core.c	2013-11-29 10:10:03.167205818 +0100
@@ -3887,6 +3887,12 @@
 	return 1;
 }
 
+
+#if defined CONFIG_PDI_DRIVER
+extern pdi_add_device (char *name, int type, int id); 
+#endif
+
+
 /**
  *	ata_dev_reread_id - Re-read IDENTIFY data
  *	@dev: target ATA device
@@ -3915,6 +3921,21 @@
 	/* is the device still there? */
 	if (!ata_dev_same_device(dev, class, id))
 		return -ENODEV;
+#if defined CONFIG_PDI_DRIVER
+	else	  
+	{
+	    char tname[MAX_LEN];
+	    // DEVICE STILL THERE CALLING PDI TO REGISTER IT                                                                                                            
+	    
+	    snprintf(tname, MAX_LEN, "%s%d", dev->link->ap->scsi_host->hostt->name, dev->link->ap->print_id);
+ 
+	    strcpy(dev->link->ap->scsi_host->hostt->pdi_name, tname);
+
+	    //printk("DEVICE ATA %d %s STILL THERE, CALLING PDI DRIVER TO REGISTER IT\n", dev->link->ap->print_id, dev->link->ap->scsi_host->hostt->pdi_name );
+	    pdi_add_device (dev->link->ap->scsi_host->hostt->pdi_name, 0, dev->link->ap->print_id);
+
+	}
+#endif
 
 	memcpy(dev->id, id, sizeof(id[0]) * ATA_ID_WORDS);
 	return 0;
diff -Naur kernel-3.3-3.0a-ref/drivers/brcmstb/bchip.c kernel-current/drivers/brcmstb/bchip.c
--- kernel-3.3-3.0a-ref/drivers/brcmstb/bchip.c	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/brcmstb/bchip.c	2013-11-29 10:10:03.155205923 +0100
@@ -55,6 +55,7 @@
 unsigned char brcm_eth0_phyaddr[CFE_STRING_SIZE];
 
 u8 brcm_primary_macaddr[IFHWADDRLEN] = { 0x00, 0x00, 0xde, 0xad, 0xbe, 0xef };
+u8 brcm_moca_macaddr[IFHWADDRLEN] = { 0x00, 0x00, 0xde, 0xad, 0xbf, 0xef };
 
 unsigned long brcm_base_baud0 = BRCM_BASE_BAUD_STB;	/* UPG UARTA */
 unsigned long brcm_base_baud = BRCM_BASE_BAUD_STB;	/* UPG_UART[BC] */
@@ -153,12 +154,21 @@
 /* SATA3 SSC per-port bitfield */
 static u32 sata3_enable_ssc;
 
+#define SATA3_MDIO_REG_BANK_SIZE	0x10
+#define SATA3_MDIO_BANK_SELECT(bank,port) \
+	((bank) + ((port) * SATA3_MDIO_REG_BANK_SIZE))
+
+#define SATA3_MDIO_TX_0_REG_BANK	0x60
 #define SATA3_MDIO_TXPMD_0_REG_BANK	0x1A0
 #define SATA3_MDIO_BRIDGE_BASE		(BCHP_SATA_GRB_REG_START + 0x100)
 #define SATA3_MDIO_BASE_REG_ADDR	(SATA3_MDIO_BRIDGE_BASE + 0x8F * 4)
 
 #define SATA_AHCI_GHC_PORTS_IMPLEMENTED	(BCHP_SATA_AHCI_GHC_REG_START + 0xC)
 
+/* SATA3_TX: TX Register Bank Registers */
+#define SATA3_TX_AFE_CTRL_2			0x82
+#define SATA3_TX_AFE_CTRL_3			0x83
+
 #define SATA3_TXPMD_CONTROL1			0x81
 #define SATA3_TXPMD_TX_FREQ_CTRL_CONTROL1	0x82
 #define SATA3_TXPMD_TX_FREQ_CTRL_CONTROL2	0x83
@@ -176,12 +186,12 @@
 	BDEV_WR(ofs * 4 + SATA3_MDIO_BRIDGE_BASE, tmp);
 }
 
-static void brcm_sata3_init_freq(int port, int ssc_enable)
+static void brcm_sata3_init_phy(int port, int ssc_enable)
 {
-	u32 bank = SATA3_MDIO_TXPMD_0_REG_BANK + port * 0x10;
+	u32 bank = SATA3_MDIO_BANK_SELECT(SATA3_MDIO_TXPMD_0_REG_BANK, port);
 
 	if (ssc_enable)
-		pr_info("SATA3: enabling SSC on port %d\n", port);
+		printk("SATA3: enabling SSC on port %d\n", port);
 
 	/* TXPMD_control1 - enable SSC force */
 	brcm_sata3_mdio_wr_reg(bank, SATA3_TXPMD_CONTROL1, 0xFFFFFFFC,
@@ -202,6 +212,18 @@
 	else
 		brcm_sata3_mdio_wr_reg(bank, SATA3_TXPMD_TX_FREQ_CTRL_CONTROL3,
 				0xFFFFFC00, 0x000003DF);
+
+	/*
+	 * (Derived from BBS document provided by Chanshine N.)
+	 * Set TX amplitude to -900mVppd, with pre-emphasis
+	 */
+	bank = SATA3_MDIO_BANK_SELECT(SATA3_MDIO_TX_0_REG_BANK, port);
+
+	brcm_sata3_mdio_wr_reg(bank, SATA3_TX_AFE_CTRL_2,
+			0xFFFF03FF, 0x00001000);
+
+	brcm_sata3_mdio_wr_reg(bank, SATA3_TX_AFE_CTRL_3,
+			0xFFFFF00F, 0x00000614);
 }
 
 /* Check up to 32 ports, although we typically only have 2 */
@@ -244,9 +266,10 @@
 
 	BDEV_WR(BCHP_SATA_TOP_CTRL_BUS_CTRL, (DATA_ENDIAN << 4) |
 			(DATA_ENDIAN << 2) | (MMIO_ENDIAN << 0));
-
+/* SB: Force ssc */
 	for (i = 0; i < ports; i++)
-		brcm_sata3_init_freq(i, sata3_enable_ssc & (1 << i));
+		/* brcm_sata3_init_freq(i, sata3_enable_ssc & (1 << i)); */
+		brcm_sata3_init_phy(i, 1);
 #endif
 }
 
@@ -484,7 +507,15 @@
 	brcm_primary_macaddr[4]++;
 	return 0;
 }
+
+int brcm_alloc_moca_macaddr(u8 *buf)
+{
+	memcpy(buf, brcm_moca_macaddr, ETH_ALEN);
+	return 0;
+}
+
 EXPORT_SYMBOL(brcm_alloc_macaddr);
+EXPORT_SYMBOL(brcm_alloc_moca_macaddr);
 
 /***********************************************************************
  * WKTMR utility functions (boot time only)
diff -Naur kernel-3.3-3.0a-ref/drivers/brcmstb/board.c kernel-current/drivers/brcmstb/board.c
--- kernel-3.3-3.0a-ref/drivers/brcmstb/board.c	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/brcmstb/board.c	2013-11-29 10:10:28.798987230 +0100
@@ -49,6 +49,12 @@
 unsigned long brcm_moca_rf_band = MOCA_BAND_HIGHRF;
 #endif
 
+
+/*prototypes */
+static void board_pinux_setup_DMC7000KLG_CADA(void);
+static void board_pinux_setup_DMC7000KLG_CADB(void);
+void board_pinmux_setup_default(void);
+
 /***********************************************************************
  * PIN_MUX setup
  *
@@ -100,8 +106,1696 @@
 				 (BCHP_SDIO_0_CFG_##y - \
 				  BCHP_SDIO_0_CFG_REG_START))
 
+#define IODIR(reg,shift,val) do{ \
+        BDEV_WR(BCHP_GIO_##reg, \
+        (BDEV_RD(BCHP_GIO_##reg) & ~(1<<shift)) | ((val) << shift)); \
+        } while(0)
+
+#define ODEN(reg,shift,val) do{ \
+        BDEV_WR(BCHP_GIO_##reg, \
+        (BDEV_RD(BCHP_GIO_##reg) & ~(1<<shift)) | ((val) << shift)); \
+        } while(0)
+
+#define DATA(reg,shift,val) do { \
+        BDEV_WR(BCHP_GIO_##reg, \
+                ((BDEV_RD(BCHP_GIO_##reg) & \
+                 ~(1 << shift)) | ((val) << shift)));\
+        } while (0)
+
+
+#define PAD_CTRL(reg, field, val) do { \
+        BDEV_WR(BCHP_SUN_TOP_CTRL_PIN_MUX_PAD_CTRL_##reg, \
+                (BDEV_RD(BCHP_SUN_TOP_CTRL_PIN_MUX_PAD_CTRL_##reg) & \
+                 ~BCHP_SUN_TOP_CTRL_PIN_MUX_PAD_CTRL_##reg##_##field##_pad_ctrl_MASK) | \
+                ((val) << \
+                 BCHP_SUN_TOP_CTRL_PIN_MUX_PAD_CTRL_##reg##_##field##_pad_ctrl_SHIFT)); \
+        } while (0)
+
 void board_pinmux_setup(void)
 {
+	char lower_boardname [CFE_STRING_SIZE] ;
+	int i ;
+	for (i=0; i<CFE_STRING_SIZE;i++ )
+	{
+		if ( brcm_cfe_boardname[i] >= 'A' && brcm_cfe_boardname[i] <='Z' )
+		{
+			lower_boardname[i] = brcm_cfe_boardname[i] + 0x20 ;
+		}
+		else
+		{
+			lower_boardname[i] = brcm_cfe_boardname[i] ;
+		}
+		
+	}
+
+	printk (KERN_INFO " Board detected : ******* %s ******* . \n",lower_boardname );
+
+    if	 (strstarts(lower_boardname, "pace_c281_cada") ||
+	    	  strstarts(lower_boardname, "pace_dmc7000klg_cada"))
+	{
+		board_pinux_setup_DMC7000KLG_CADA ();	
+	}
+    else if (strstarts(lower_boardname, "pace_dmc7000klg_cadb"))
+	{
+		board_pinux_setup_DMC7000KLG_CADB ();	
+	}	
+    else
+	{
+		printk (KERN_INFO " Default pin mux configuration for Broadcom Board. \n");
+		board_pinmux_setup_default() ;
+	}
+
+}
+
+
+#define PULL_NONE   (0)
+#define PULL_DOWN   (1)
+#define PULL_UP     (2)
+#define IODIR_OUT   (0)
+#define IODIR_IN    (1)
+#define TOTEM_POLE  (0)
+#define OPEN_DRAIN  (1)
+
+void board_pinux_setup_DMC7000KLG_CADA(void)
+{
+    printk (KERN_INFO " Specific init for PACE DMC7000KLG CADA Board. \n");
+    printk (KERN_INFO " Based on D915_GPIO_MAP_CADA_d1-5_23-05.xls\n");
+
+    /* AON_GPIO_00  AON_GP0_AUD_SPDIF   O   AUD_SPDIF  N/A             N/A    SPDIF output + strapping for boot (strap_xcore_bias_sel_0) */
+    AON_PINMUX(0, aon_gpio_00, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_00_AUD_SPDIF);
+    AON_PADCTRL(0, aon_gpio_00_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 0, IODIR_OUT);
+
+    /* AON_GPIO_01  not_switch_irq      I   GPIO       LOW             N/A    From ethernet switch BCM53125    */
+#if 0
+    AON_PINMUX(0, aon_gpio_01, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_01_AON_GPIO_01);
+    AON_PADCTRL(0, aon_gpio_01_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 1, IODIR_IN);
+#else
+    #warning "AON_GPIO_01 => SPEC ISSUE INPUT NOT POSSIBLE ACCORDING TO BCM SPEC"
+#endif
+
+    /* AON_GPIO_02  CM_PWR_EN           O   GPIO       HIgh            HIgh    cable modem power switch. 1=> cable modem power ON    */
+    AON_PINMUX(0, aon_gpio_02, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_02_AON_GPIO_02);
+    AON_PADCTRL(0, aon_gpio_02_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 2, IODIR_OUT);
+    DATA(AON_DATA_LO, 2, 1);
+
+    /* AON_GPIO_03    led_pwr_grn       O   GPIO       HIgh            LOW    "1 => green power LED ON    - init value to be confirmed, depending on standby LED behavior requested at boot"    */
+    AON_PINMUX(0, aon_gpio_03, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_03_AON_GPIO_03);
+    AON_PADCTRL(0, aon_gpio_03_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 3, IODIR_OUT);
+
+    /* AON_GPIO_04    led_cathode_0     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(0, aon_gpio_04, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_04_AON_GPIO_04);
+    AON_PADCTRL(0, aon_gpio_04_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 4, IODIR_IN);
+
+    /* AON_GPIO_05    led_cathode_1     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(0, aon_gpio_05, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_05_AON_GPIO_05);
+    AON_PADCTRL(0, aon_gpio_05_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 5, IODIR_IN);
+
+    /* AON_GPIO_06    led_cathode_2     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_06, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_06_AON_GPIO_06);
+    AON_PADCTRL(0, aon_gpio_06_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 6, IODIR_IN);
+
+    /* AON_GPIO_07    led_cathode_3     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_07, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_07_AON_GPIO_07);
+    AON_PADCTRL(0, aon_gpio_07_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 7, IODIR_IN);
+
+    /* AON_GPIO_08    led_cathode_4     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_08, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_08_AON_GPIO_08);
+    AON_PADCTRL(1, aon_gpio_08_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 8, IODIR_IN);
+
+    /* AON_GPIO_09    led_cathode_5     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_09, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_09_AON_GPIO_09);
+    AON_PADCTRL(1, aon_gpio_09_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 9, IODIR_IN);
+
+    /* AON_GPIO_10    led_cathode_6     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_10, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_10_AON_GPIO_10);
+    AON_PADCTRL(1, aon_gpio_10_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 10, IODIR_IN);
+
+    /* AON_GPIO_11    led_cathode_7     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_11, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_11_AON_GPIO_11);
+    AON_PADCTRL(1, aon_gpio_11_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 11, IODIR_IN);
+
+    /* AON_GPIO_12    led_anode_0n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_12, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_12_AON_GPIO_12);
+    AON_PADCTRL(1, aon_gpio_12_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 12, IODIR_IN);
+
+    /* AON_GPIO_13    led_anode_1n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_13, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_13_AON_GPIO_13);
+    AON_PADCTRL(1, aon_gpio_13_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 13, IODIR_IN);
+
+    /* AON_GPIO_14    led_anode_2n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(2, aon_gpio_14, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_14_AON_GPIO_14);
+    AON_PADCTRL(1, aon_gpio_14_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 14, IODIR_IN);
+
+    /* AON_GPIO_15    led_anode_3n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(2, aon_gpio_15, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_15_AON_GPIO_15);
+    AON_PADCTRL(1, aon_gpio_15_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 15, IODIR_IN);
+
+    /* AON_GPIO_16    led_pwr_red       O   GPIO       HIgh            HIgh    "1 => red power LED ON - init value to be confirmed, depending on standby LED behavior requested at boot"    */
+    AON_PINMUX(2, aon_gpio_16, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_16_AON_GPIO_16);
+    AON_PADCTRL(1, aon_gpio_16_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 16, IODIR_OUT);
+    DATA(AON_DATA_LO, 16, 1);
+
+    /* AON_GPIO_17    sw_standby_n      I   GPIO       HIgh    LOW    N/A    stand-by key input, 1 => key pressed    */
+    AON_PINMUX(2, aon_gpio_17, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_17_AON_GPIO_17);
+    AON_PADCTRL(1, aon_gpio_17_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 17, IODIR_IN);
+
+    /* AON_GPIO_18    sw_ch_up_n        I   GPIO       HIgh    LOW    N/A    channel up key input, 1 => key pressed    */
+    AON_PINMUX(2, aon_gpio_18, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_18_AON_GPIO_18);
+    AON_PADCTRL(1, aon_gpio_18_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 18, IODIR_IN);
+
+    /* AON_GPIO_19    sw_ch_dwn_n       I   GPIO       HIgh    LOW    N/A    channel down key input,  1 => key pressed    */
+    AON_PINMUX(2, aon_gpio_19, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_19_AON_GPIO_19);
+    AON_PADCTRL(1, aon_gpio_19_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 19, IODIR_IN);
+
+    /* AON_GPIO_20    PVR_POWER_EN      O   GPIO       HIgh            HIgh    HDD supply switch, 1=> HDD power ON    */
+    AON_PINMUX(2, aon_gpio_20, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_20_AON_GPIO_20);
+    AON_PADCTRL(1, aon_gpio_20_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 20, IODIR_OUT);
+    DATA(AON_DATA_LO, 20, 1);
+
+    /* AON_SGPIO_00     rf4ce_irq_n     I   GPIO        LOW                  HIgh   N/A */
+    AON_PINMUX(2, aon_sgpio_00, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_sgpio_00_AON_SGPIO_00);
+    IODIR(AON_IODIR_EXT, 0, IODIR_IN);
+
+    /* AON_SGPIO_01     rf4ce_wkup      O               LOW    open drain    High */
+    AON_PINMUX(3, aon_sgpio_01, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_01_AON_SGPIO_01);
+    IODIR(AON_IODIR_EXT, 1, IODIR_OUT);
+    ODEN(AON_ODEN_EXT, 1, 1);
+    DATA(AON_DATA_EXT, 1, 0);
+
+    /* AON_SGPIO_02    RF4CE_SCL        O   AON_BSC_M1_SCL                      RF4CE_I2C   */
+    AON_PINMUX(3, aon_sgpio_02, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_02_AON_BSC_M1_SCL);
+    IODIR(AON_IODIR_EXT, 2, IODIR_OUT);
+
+    /* AON_SGPIO_03    RF4CE_SDA        I/O AON_BSC_M1_SDA                      RF4CE_I2C   */
+    AON_PINMUX(3, aon_sgpio_03, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_03_AON_BSC_M1_SDA);
+
+    /* AON_SGPIO_04    HDMI_SCL         O   AON_BSC_M2_SCL                      HDMI I2C    */
+    AON_PINMUX(3, aon_sgpio_04, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_04_AON_BSC_M2_SCL);
+    IODIR(AON_IODIR_EXT, 4, IODIR_OUT);
+
+    /* AON_SGPIO_05    HDMI_SDA         I/O AON_BSC_M2_SDA                      HDMI I2C    */
+    AON_PINMUX(3, aon_sgpio_05, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_05_AON_BSC_M2_SDA);
+
+    /* GPIO_000    sc_pwr_fail_n        I   GPIO    LOW     HIgh    N/A    detection of power fail to interrupt smart card dialog    */
+    PINMUX(0, gpio_000, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_0_gpio_000_GPIO_000);
+    PADCTRL(0, gpio_000_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 0, IODIR_IN);
+
+    /* GPIO_001    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_001_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 1, IODIR_IN);
+
+    /* GPIO_002    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_002_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 2, IODIR_IN);
+
+    /* GPIO_003    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_003_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 3, IODIR_IN);
+
+    /* GPIO_004    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_004_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 4, IODIR_IN);
+
+    /* GPIO_005    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_005_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 5, IODIR_IN);
+
+    /* GPIO_006    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_006_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 6, IODIR_IN);
+
+    /* GPIO_007    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_007_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 7, IODIR_IN);
+
+    /* GPIO_008    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_008_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 8, IODIR_IN);
+
+    /* GPIO_009    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_009_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 9, IODIR_IN);
+
+    /* GPIO_010    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_010_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 10, IODIR_IN);
+
+    /* GPIO_011    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_011_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 11, IODIR_IN);
+
+    /* GPIO_012    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_012_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 12, IODIR_IN);
+
+    /* GPIO_013    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_013_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 13, IODIR_IN);
+
+    /* GPIO_014    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_014_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 14, IODIR_IN);
+
+    /* GPIO_015    BCM7430_SPIM_SS1b    I   GPIO    n/a     Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(1, gpio_015, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_1_gpio_015_GPIO_015);
+    PADCTRL(1, gpio_015_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 15, IODIR_IN);
+
+    /* GPIO_016    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_016_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 16, IODIR_IN);
+
+    /* GPIO_017    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_017_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 17, IODIR_IN);
+
+    /* GPIO_018    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_018_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 18, IODIR_IN);
+
+    /* GPIO_019    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_019_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 19, IODIR_IN);
+
+    /* GPIO_020    7430_NAND_CS_N       O   EBI_CS0b        HIgh    NAND FLASH INTERFACE    */
+    PINMUX(2, gpio_020, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_2_gpio_020_EBI_CS0B);
+    PADCTRL(1, gpio_020_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 20, IODIR_OUT);
+
+    /* GPIO_021    7430_NAND_CE_NOT     O   EBI_CS1b        HIgh    */
+    PINMUX(2, gpio_021, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_2_gpio_021_EBI_CS1B);
+    PADCTRL(2, gpio_021_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 21, IODIR_OUT);
+
+    /* GPIO_022    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_022_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 22, IODIR_IN);
+
+    /* GPIO_023    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_023_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 23, IODIR_IN);
+
+    /* GPIO_024    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_024_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 24, IODIR_IN);
+
+    /* GPIO_025    7430_NAND_DATA0      I/O    NAND_DATA_0    */
+    PINMUX(3, gpio_025, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_025_EBI_DATA0);
+    PADCTRL(2, gpio_025_pad_ctrl, PULL_NONE);
+
+    /* GPIO_026    7430_NAND_DATA1      I/O    NAND_DATA_1    */
+    PINMUX(3, gpio_026, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_026_EBI_DATA1);
+    PADCTRL(2, gpio_026_pad_ctrl, PULL_NONE);
+
+    /* GPIO_027    7430_NAND_DATA2      I/O    NAND_DATA_2    */
+    PINMUX(3, gpio_027, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_027_EBI_DATA2);
+    PADCTRL(2, gpio_027_pad_ctrl, PULL_NONE);
+
+    /* GPIO_028    7430_NAND_DATA3      I/O    NAND_DATA_3    */
+    PINMUX(3, gpio_028, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_028_EBI_DATA3);
+    PADCTRL(2, gpio_028_pad_ctrl, PULL_NONE);
+
+    /* GPIO_029    7430_NAND_DATA4      I/O    NAND_DATA_4    */
+    PINMUX(3, gpio_029, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_029_EBI_DATA4);
+    PADCTRL(2, gpio_029_pad_ctrl, PULL_NONE);
+
+    /* GPIO_030    7430_NAND_DATA5      I/O    NAND_DATA_5    */
+    PINMUX(3, gpio_030, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_030_EBI_DATA5);
+    PADCTRL(2, gpio_030_pad_ctrl, PULL_NONE);
+
+    /* GPIO_031    7430_NAND_DATA6      I/O    NAND_DATA_6    */
+    PINMUX(3, gpio_031, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_031_EBI_DATA6);
+    PADCTRL(2, gpio_031_pad_ctrl, PULL_NONE);
+
+    /* GPIO_032    7430_NAND_DATA7      I/O    NAND_DATA_7    */
+    PINMUX(4, gpio_032, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_032_EBI_DATA7);
+    PADCTRL(2, gpio_032_pad_ctrl, PULL_NONE);
+
+    /* GPIO_033    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(2, gpio_033_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 1, IODIR_IN);
+
+    /* GPIO_034    SCART_SBnot          O   GPIO        HIGH     1=> SB off    */
+    PINMUX(4, gpio_034, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_034_GPIO_034);
+    PADCTRL(2, gpio_034_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 2, IODIR_OUT);
+    DATA(DATA_HI, 2, 1);
+
+    /* GPIO_035    SCART_SB_6V          O   GPIO        N/a     1=> SB=6V (if  SCART_SBnot=0)    */
+    PINMUX(4, gpio_035, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_035_GPIO_035);
+    PADCTRL(2, gpio_035_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 3, IODIR_OUT);
+
+    /* GPIO_036    SCART_FB             O   GPIO    HIGH    LOW     1=> FB on    */
+    PINMUX(4, gpio_036, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_036_GPIO_036);
+    PADCTRL(3, gpio_036_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 4, IODIR_OUT);
+    DATA(DATA_HI, 4, 0);
+
+    /* GPIO_037    AUDIO_MUTE           O   GPIO    LOW    HIgh    LOW    shall remain low during the boot process until the DACs are properly initialized to avoid any plop.    */
+    PINMUX(4, gpio_037, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_037_GPIO_037);
+    PADCTRL(3, gpio_037_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 5, IODIR_OUT);
+    DATA(DATA_HI, 5, 0);
+
+    /* GPIO_038    BCM7430_SPIM_MOSI    I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(4, gpio_038, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_038_GPIO_038);
+    PADCTRL(3, gpio_038_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 6, IODIR_IN);
+
+    /* GPIO_039    BCM7430_SPIM_MISO    I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(4, gpio_039, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_039_GPIO_039);
+    PADCTRL(3, gpio_039_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 7, IODIR_IN);
+
+    /* GPIO_040    BCM7430_SPIM_SCK     I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(5, gpio_040, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_040_GPIO_040);
+    PADCTRL(3, gpio_040_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 8, IODIR_IN);
+
+    /* GPIO_041    7430_NAND_READ_N     O   NAND_REb    HIgh    NAND FLASH INTERFACE    */
+    PINMUX(5, gpio_041, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_041_EBI_RDB);
+    PADCTRL(3, gpio_041_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 9, IODIR_OUT);
+
+    /* GPIO_042    7430_NAND_WE_N       O   NAND_WEb    HIgh    */
+    PINMUX(5, gpio_042, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_042_EBI_WE0B);
+    PADCTRL(3, gpio_042_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 10, IODIR_OUT);
+
+    /* GPIO_043    7430_NAND_WE_ALE     I   NAND_ALE    HIgh    */
+    PINMUX(5, gpio_043, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_043_EBI_DSB);
+    PADCTRL(3, gpio_043_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 11, IODIR_IN);
+
+    /* GPIO_044    7430_NAND_WE_CLE     I   NAND_CLE    HIgh    */
+    PINMUX(5, gpio_044, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_044_EBI_TSB);
+    PADCTRL(3, gpio_044_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 12, IODIR_IN);
+
+    /* GPIO_045    7430_NAND_RB_N       I   NAND_RBb    HIgh        */
+    PINMUX(5, gpio_045, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_045_EBI_NAND_RBB);
+    PADCTRL(3, gpio_045_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 13, IODIR_IN);
+
+    /* GPIO_046    HDMI_OFF             O   GPIO        HIgh    HIgh    Low    HDMI 5V switch command. 1 => HDMI 5V ON    */
+    PINMUX(5, gpio_046, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_046_GPIO_046);
+    PADCTRL(3, gpio_046_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 14, IODIR_OUT);
+    DATA(DATA_HI, 14, 0);
+
+    /* GPIO_047    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_047_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 15, IODIR_IN);
+
+    /* GPIO_048    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_048_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 16, IODIR_IN);
+
+    /* GPIO_049    Scart_vid_buf_enable_n    O    GPIO    HIgh    HIgh    Low    1 => Video buffer ON    */
+    PINMUX(6, gpio_049, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_6_gpio_049_GPIO_049);
+    PADCTRL(3, gpio_049_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 17, IODIR_OUT);
+    DATA(DATA_HI, 17, 0);
+
+    /* GPIO_050    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_050_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 18, IODIR_IN);
+
+    /* GPIO_051    Moca_powerdown_n     O   GPIO    LOW    HIgh    HIgh    0 => MoCA 3V3 off    */
+    PINMUX(6, gpio_051, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_6_gpio_051_GPIO_051);
+    PADCTRL(4, gpio_051_pad_ctrl, PULL_UP);
+    IODIR(IODIR_HI, 19, IODIR_OUT);
+    DATA(DATA_HI, 19, 1);
+    brcm_moca_i2c_base = BPHYSADDR(BCHP_BSCD_REG_START);
+
+    /* GPIO_052    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_052_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 20, IODIR_IN);
+
+    /* GPIO_053    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_053_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 21, IODIR_IN);
+
+    /* GPIO_054    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_054_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 22, IODIR_IN);
+
+    /* GPIO_055    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_055_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 23, IODIR_IN);
+
+    /* GPIO_056    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_056_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 24, IODIR_IN);
+
+    /* GPIO_057    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_057_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 25, IODIR_IN);
+
+    /* GPIO_058    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_058_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 26, IODIR_IN);
+
+    /* GPIO_059    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_059_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 27, IODIR_IN);
+
+    /* GPIO_060    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_060_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 28, IODIR_IN);
+
+    /* GPIO_061    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_061_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 29, IODIR_IN);
+
+    /* GPIO_062    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(7, gpio_062, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_7_gpio_062_GPIO_062);
+    PADCTRL(4, gpio_062_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 30, IODIR_IN);
+
+    /* GPIO_063    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(7, gpio_063, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_7_gpio_063_GPIO_063);
+    PADCTRL(4, gpio_063_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 31, IODIR_IN);
+
+    /* GPIO_064    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_064_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 4, IODIR_IN);
+
+    /* GPIO_065    UART_TXD_1    UART_TX1        TESTTASK interface    */
+    PINMUX(8, gpio_065, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_8_gpio_065_UART_TX1);
+    PADCTRL(4, gpio_065_pad_ctrl, PULL_NONE);
+
+    /* GPIO_066    UART_RXD_1    UART_RX1        TESTTASK interface    */
+    PINMUX(8, gpio_066, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_8_gpio_066_UART_RX1);
+    PADCTRL(5, gpio_066_pad_ctrl, PULL_NONE);
+
+    /* GPIO_067    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_067_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 7, IODIR_IN);
+
+    /* GPIO_068    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_068_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 8, IODIR_IN);
+
+    /* GPIO_069    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_069_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 9, IODIR_IN);
+
+    /* GPIO_070    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_070_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 10, IODIR_IN);
+
+    /* GPIO_071    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_071_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 11, IODIR_IN);
+
+    /* GPIO_072    RF4CE_resetn         O    GPIO    Low    None    LOW     to reset RF4CE (0 ==> GP510 resetted). */
+    PINMUX(9, gpio_072, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_072_GPIO_072);
+    PADCTRL(5, gpio_072_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 12, IODIR_OUT);
+    DATA(DATA_EXT, 12, 0);
+
+    /* GPIO_073    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_073_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 13, IODIR_IN);
+
+    /* GPIO_074    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_074_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 14, IODIR_IN);
+
+    /* GPIO_075    led_rec              O    GPIO    HIGH    LOW    1=> record LED ON    */
+    PINMUX(9, gpio_075, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_075_GPIO_075);
+    PADCTRL(5, gpio_075_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 15, IODIR_OUT);
+    DATA(DATA_EXT, 15, 0);
+
+    /* GPIO_076    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_076_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 16, IODIR_IN);
+
+    /* GPIO_077    not_sc_1v8           I    GPIO    */
+    PINMUX(9, gpio_077, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_077_GPIO_077);
+    PADCTRL(5, gpio_077_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 17, IODIR_IN);
+
+    /* GPIO_078    sc_5v_not_3v         O    GPIO    */
+    PINMUX(9, gpio_078, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_078_GPIO_078);
+    PADCTRL(5, gpio_078_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 18, IODIR_OUT);
+
+    /* GPIO_079    SC_VCC               O    SC0_VCC    */
+    PINMUX(9, gpio_079, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_079_SC0_VCC);
+    PADCTRL(5, gpio_079_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 19, IODIR_OUT);
+
+    /* GPIO_080    SC_CLK               O    SC0_CLK    */
+    PINMUX(10, gpio_080, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_080_SC0_CLK);
+    PADCTRL(5, gpio_080_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 20, IODIR_OUT);
+
+    /* GPIO_081    SC_RST               O    SC0_RST    */
+    PINMUX(10, gpio_081, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_081_SC0_RST);
+    PADCTRL(6, gpio_081_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 21, IODIR_OUT);
+
+    /* GPIO_082    SC_data              I/O    SC0_IO    */
+    PINMUX(10, gpio_082, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_082_SC0_IO);
+    PADCTRL(6, gpio_082_pad_ctrl, PULL_NONE);
+
+    /* GPIO_083    SC_PRES              I    SC0_PRES        */
+    PINMUX(10, gpio_083, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_083_SC0_PRES);
+    PADCTRL(6, gpio_083_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 23, IODIR_IN);
+
+    /* GPIO_084    SC_AUX0              I    GPIO    n/a    Low    n/a    not used on D915    */
+    PINMUX(10, gpio_084, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_084_GPIO_084);
+    PADCTRL(6, gpio_084_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 24, IODIR_IN);
+
+    /* GPIO_085    SC_AUX1              I    GPIO    n/a    Low    n/a    not used on D915    */
+    PINMUX(10, gpio_085, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_085_GPIO_085);
+    PADCTRL(6, gpio_085_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 25, IODIR_IN);
+
+    /* GPIO_086    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(10, gpio_086, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_086_GPIO_086);
+    PADCTRL(6, gpio_086_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 26, IODIR_IN);
+
+    /* GPIO_087    MTSIF_CLK            I    MTSIF0_CLK        Multiplex Transport Stream interface with BCM3383    */
+    PINMUX(10, gpio_087, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_087_MTSIF0_CLK);
+    PADCTRL(6, gpio_087_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 27, IODIR_IN);
+
+    /* GPIO_088    MTSIF_DATA0          I    MTSIF0_DATA0    */
+    PINMUX(11, gpio_088, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_088_MTSIF0_DATA0);
+    PADCTRL(6, gpio_088_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 28, IODIR_IN);
+
+    /* GPIO_089    MTSIF_SYNC           I    MTSIF0_SYNC        */
+    PINMUX(11, gpio_089, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_089_MTSIF0_SYNC);
+    PADCTRL(6, gpio_089_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 29, IODIR_IN);
+
+    /* GPIO_090    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_090_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 30, IODIR_IN);
+
+    /* GPIO_091    MTSIF_DATA1          I    MTSIF0_DATA1    */
+    PINMUX(11, gpio_091, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_091_MTSIF0_DATA1);
+    PADCTRL(6, gpio_091_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 31, IODIR_IN);
+
+    /* GPIO_092    UART_TXD_0           UART_TX0        CFE interface    */
+    PINMUX(11, gpio_092, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_092_UART_TX0);
+    PADCTRL(6, gpio_092_pad_ctrl, PULL_NONE);
+
+    /* GPIO_093    UART_RXD_0           UART_RX0        CFE interface    */
+    PINMUX(11, gpio_093, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_093_UART_RX0);
+    PADCTRL(6, gpio_093_pad_ctrl, PULL_NONE);
+
+    /* GPIO_094    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_094_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 2, IODIR_IN);
+
+    /* GPIO_095    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_095_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 3, IODIR_IN);
+
+    /* GPIO_096    FAN_CTRL             O    PWM0    N/A    HIgh    low    fan pwm, fan speed is increased when PWM duty cycle is decreasing    */
+    PINMUX(12, gpio_096, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_096_PWM0);
+    PADCTRL(7, gpio_096_pad_ctrl, PULL_UP);
+    IODIR(IODIR_EXT_HI, 4, IODIR_OUT);
+    DATA(DATA_EXT_HI, 4, 0);
+
+    /* GPIO_097    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_097_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 5, IODIR_IN);
+
+    /* GPIO_098    fan_tacho            I    N/A    HIgh    N/A    This is a special GPIO. Check with BCM.*/
+#if 0
+    PINMUX(12, gpio_098, 0);
+    PADCTRL(7, gpio_098_pad_ctrl, PULL_UP);
+    IODIR(IODIR_EXT_HI, 6, IODIR_IN);
+#else
+    #warning "GPIO_098 fan_tacho => SPEC ISSUE TBC"
+#endif
+
+    /* GPIO_099    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_099_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 7, IODIR_IN);
+
+    /* GPIO_100    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_100_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 8, IODIR_IN);
+
+    /* GPIO_101    MTSIF_DATA2          I    MTSIF0_DATA2        Multiplex Transport Stream interface with BCM3383 */
+    PINMUX(12, gpio_101, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_101_MTSIF0_DATA2);
+    PADCTRL(7, gpio_101_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 9, IODIR_IN);
+
+    /* GPIO_102    MTSIF_DATA3          I    MTSIF0_DATA3    */
+    PINMUX(12, gpio_102, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_102_MTSIF0_DATA3);
+    PADCTRL(7, gpio_102_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 10, IODIR_IN);
+
+    /* GPIO_103    MTSIF_DATA4          I    MTSIF0_DATA4    */
+    PINMUX(12, gpio_103, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_103_MTSIF0_DATA4);
+    PADCTRL(7, gpio_103_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 11, IODIR_IN);
+
+    /* GPIO_104    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_104_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 12, IODIR_IN);
+
+    /* GPIO_105    MTSIF_DATA5          I    MTSIF0_DATA5    */
+    PINMUX(13, gpio_105, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_13_gpio_105_MTSIF0_DATA5);
+    PADCTRL(7, gpio_105_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 13, IODIR_IN);
+
+    /* GPIO_106 ???? */
+    /* GPIO_107 ???? */
+    /* GPIO_108 ???? */
+    /* GPIO_109 ???? */
+    /* GPIO_110 ???? */
+    /* GPIO_111 ???? */
+    /* GPIO_112 ???? */
+    /* GPIO_113 ???? */
+
+    /* GPIO_114    "GP114_ENET0_ACTIVITY    (unused, but strapping resistor connected)"    I    GPIO    */
+    PINMUX(14, gpio_114, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_114_GPIO_114);
+    PADCTRL(8, gpio_114_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 22, IODIR_IN);
+
+    /* GPIO_115 ???? */
+
+    /* GPIO_116    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_116_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 24, IODIR_IN);
+
+    /* GPIO_117    MTSIF_DATA6          I    MTSIF0_DATA6    */
+    PINMUX(14, gpio_117, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_117_MTSIF0_DATA6);
+    PADCTRL(8, gpio_117_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 25, IODIR_IN);
+
+    /* GPIO_118    MTSIF_DATA7          I    MTSIF0_DATA7    */
+    PINMUX(14, gpio_118, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_118_MTSIF0_DATA7);
+    PADCTRL(8, gpio_118_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 26, IODIR_IN);
+
+    /* GPIO_119 ???? */
+    /* GPIO_120 ???? */
+    /* GPIO_121 ???? */
+
+    /* GPIO_122    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_122_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 30, IODIR_IN);
+
+    /* GPIO_123    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_123_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 31, IODIR_IN);
+
+    /* GPIO_124    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_124_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 0, IODIR_IN);
+
+    /* GPIO_125    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_125_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 1, IODIR_IN);
+
+    /* GPIO_126    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_126_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 2, IODIR_IN);
+
+    /* GPIO_127    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_127_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 3, IODIR_IN);
+
+    /* GPIO_128    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_128_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 4, IODIR_IN);
+
+    /* GPIO_129    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_129_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 5, IODIR_IN);
+
+    /* GPIO_130    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(9, gpio_130_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 6, IODIR_IN);
+
+    /* GPIO_131    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(9, gpio_131_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 7, IODIR_IN);
+
+    /* GPIO_132    53125_7430_RGMII_RXDV    I    MII_RX_DV        EMAC0 interface with ethernet switch    */
+    PINMUX(15, gpio_132, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_15_gpio_132_MII_RX_DV);
+    PADCTRL(9, gpio_132_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 8, IODIR_IN);
+
+    /* GPIO_133    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_133_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 9, IODIR_IN);
+
+    /* GPIO_134    53125_7430_RGMII_RXCLK    I    MII_RX_CLK    */
+    PINMUX(16, gpio_134, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_134_MII_RX_CLK);
+    PADCTRL(9, gpio_134_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 10, IODIR_IN);
+
+    /* GPIO_135    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_135_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 11, IODIR_IN);
+
+    /* GPIO_136    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_136_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 12, IODIR_IN);
+
+    /* GPIO_137    7430_GP_137_MII_MDIO (option not used on D915)    I/O    GPIO    */
+    PINMUX(16, gpio_137, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_137_GPIO_137);
+    PADCTRL(9, gpio_137_pad_ctrl, PULL_NONE);
+
+    /* GPIO_138    53125_7430_RMII_TXCLK    O    MII_TX_CLK    */
+    PINMUX(16, gpio_138, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_138_MII_TX_CLK);
+    PADCTRL(9, gpio_138_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 14, IODIR_OUT);
+
+    /* GPIO_139    53125_7430_RGMII_RXD3    I    MII_RXD_03    */
+    PINMUX(16, gpio_139, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_139_MII_RXD_03);
+    PADCTRL(9, gpio_139_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 15, IODIR_IN);
+
+    /* GPIO_140    53125_7430_RGMII_RXD2    I    MII_RXD_02    */
+    PINMUX(16, gpio_140, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_140_MII_RXD_02);
+    PADCTRL(9, gpio_140_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 16, IODIR_IN);
+
+    /* GPIO_141    53125_7430_RGMII_RXD1    I    MII_RXD_01    */
+    PINMUX(17, gpio_141, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_141_MII_RXD_01);
+    PADCTRL(9, gpio_141_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 17, IODIR_IN);
+
+    /* GPIO_142    53125_7430_RGMII_RXD0    i    MII_RXD_00    */
+    PINMUX(17, gpio_142, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_142_MII_RXD_00);
+    PADCTRL(9, gpio_142_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 18, IODIR_IN);
+
+    /* GPIO_143    53125_7430_RGMII_TXD3    O    MII_TXD_03    */
+    PINMUX(17, gpio_143, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_143_MII_TXD_03);
+    PADCTRL(9, gpio_143_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 19, IODIR_OUT);
+
+    /* GPIO_144    53125_7430_RGMII_TXD2    O    MII_TXD_02    */
+    PINMUX(17, gpio_144, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_144_MII_TXD_02);
+    PADCTRL(9, gpio_144_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 20, IODIR_OUT);
+
+    /* GPIO_145    53125_7430_RGMII_TXD1    O    MII_TXD_01    */
+    PINMUX(17, gpio_145, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_145_MII_TXD_01);
+    PADCTRL(10, gpio_145_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 21, IODIR_OUT);
+
+    /* GPIO_146    53125_7430_RGMII_TXD0    O    MII_TXD_00    */
+    PINMUX(17, gpio_146, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_146_MII_TXD_00);
+    PADCTRL(10, gpio_146_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 22, IODIR_OUT);
+
+    /* GPIO_147    53125_7430_RGMII_TXDV    O    MII_TXD_EN    */
+    PINMUX(17, gpio_147, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_147_MII_TX_EN);
+    PADCTRL(10, gpio_147_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 23, IODIR_OUT);
+
+    /* GPIO_148    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(10, gpio_148_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 24, IODIR_IN);
+
+    /* GPIO_149    53125_7430_MII_MDC (option not used on D915)    O    GPIO    */
+    PINMUX(18, gpio_149, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_gpio_149_GPIO_149);
+    PADCTRL(10, gpio_149_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 25, IODIR_OUT);
+
+    /* SGPIO_00    3450_BSC_SCL         O    BSC_M3_SDA        MOCA_I2C    */
+    PINMUX(18, sgpio_00, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_sgpio_00_BSC_M3_SCL);
+    IODIR(IODIR_EXT, 0, IODIR_OUT);
+
+    /* SGPIO_01    3450_BSC_SDA         I/O    BSC_M3_SCL        MOCA_I2C    */
+    PINMUX(18, sgpio_01, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_sgpio_01_BSC_M3_SDA);
+
+    /* SGPIO_02    Unused               I    SGPIO    n/a    Low    n/a */
+    IODIR(IODIR_EXT, 2, IODIR_IN);
+
+    /* SGPIO_03    Unused               I    SGPIO    n/a    Low    n/a    */
+    IODIR(IODIR_EXT, 3, IODIR_IN);
+}
+
+void board_pinux_setup_DMC7000KLG_CADB(void)
+{
+    printk (KERN_INFO " Specific init for PACE DMC7000KLG CADB Board. \n");
+    printk (KERN_INFO " Based on D915_GPIO_MAP_CADB_d1-1_29-5.xls\n");
+
+    /* AON_GPIO_00  AON_GP0_AUD_SPDIF   O   AUD_SPDIF  N/A  PULL_NONE  totem-pole    N/A    SPDIF output + strapping for boot (strap_xcore_bias_sel_0) */
+    AON_PINMUX(0, aon_gpio_00, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_00_AUD_SPDIF);
+    AON_PADCTRL(0, aon_gpio_00_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 0, IODIR_OUT);
+    ODEN(AON_ODEN_LO, 0, TOTEM_POLE);
+
+    /* AON_GPIO_01  Moca_powerdown_n    O   GPIO       LOW  PULL_HIGH   open-drain  HIGH    0 => MoCA 3V3 off + strapping for boot (strap_xcore_bias_sel_1) */
+    AON_PINMUX(0, aon_gpio_01, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_01_AON_GPIO_01);
+    AON_PADCTRL(0, aon_gpio_01_pad_ctrl, PULL_UP);
+    IODIR(AON_IODIR_LO, 1, IODIR_OUT);
+    ODEN(AON_ODEN_LO, 1, TOTEM_POLE);
+    DATA(AON_DATA_LO, 1, 1);
+    brcm_moca_i2c_base = BPHYSADDR(BCHP_BSCD_REG_START);
+
+    /* AON_GPIO_02  CM_PWR_EN   O   GPIO    HIgh    PULL_HIGH   totem-pole  HIgh    cable modem power switch. 1=> cable modem power ON */
+    AON_PINMUX(0, aon_gpio_02, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_02_AON_GPIO_02);
+    AON_PADCTRL(0, aon_gpio_02_pad_ctrl, PULL_UP);
+    IODIR(AON_IODIR_LO, 2, IODIR_OUT);
+    ODEN(AON_ODEN_LO, 2, TOTEM_POLE);
+    DATA(AON_DATA_LO, 2, 1);
+
+    /* AON_GPIO_03  wake_on_lan I   GPIO    LOW     PULL_HIGH   N/A    N/A    From ethernet switch BCM53125 */
+    AON_PINMUX(0, aon_gpio_03, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_03_AON_GPIO_03);
+    AON_PADCTRL(0, aon_gpio_03_pad_ctrl, PULL_UP);
+    IODIR(AON_IODIR_LO, 3, IODIR_IN);
+
+    /* AON_GPIO_04    led_cathode_0     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915 - option to drive red power led with LDK to reduce power consumption in S3 mode. */
+    AON_PINMUX(0, aon_gpio_04, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_04_AON_GPIO_04);
+    AON_PADCTRL(0, aon_gpio_04_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 4, IODIR_IN);
+
+    /* AON_GPIO_05    led_cathode_1     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915 - option for wake-up of S3 mode managed by BCM3383. */
+    AON_PINMUX(0, aon_gpio_05, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_0_aon_gpio_05_AON_GPIO_05);
+    AON_PADCTRL(0, aon_gpio_05_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 5, IODIR_IN);
+
+    /* AON_GPIO_06    led_cathode_2     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_06, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_06_AON_GPIO_06);
+    AON_PADCTRL(0, aon_gpio_06_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 6, IODIR_IN);
+
+    /* AON_GPIO_07    led_cathode_3     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_07, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_07_AON_GPIO_07);
+    AON_PADCTRL(0, aon_gpio_07_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 7, IODIR_IN);
+
+    /* AON_GPIO_08    led_cathode_4     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_08, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_08_AON_GPIO_08);
+    AON_PADCTRL(1, aon_gpio_08_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 8, IODIR_IN);
+
+    /* AON_GPIO_09    led_cathode_5     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_09, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_09_AON_GPIO_09);
+    AON_PADCTRL(1, aon_gpio_09_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 9, IODIR_IN);
+
+    /* AON_GPIO_10    led_cathode_6     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_10, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_10_AON_GPIO_10);
+    AON_PADCTRL(1, aon_gpio_10_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 10, IODIR_IN);
+
+    /* AON_GPIO_11    led_cathode_7     I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_11, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_11_AON_GPIO_11);
+    AON_PADCTRL(1, aon_gpio_11_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 11, IODIR_IN);
+
+    /* AON_GPIO_12    led_anode_0n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_12, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_12_AON_GPIO_12);
+    AON_PADCTRL(1, aon_gpio_12_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 12, IODIR_IN);
+
+    /* AON_GPIO_13    led_anode_1n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(1, aon_gpio_13, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_1_aon_gpio_13_AON_GPIO_13);
+    AON_PADCTRL(1, aon_gpio_13_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 13, IODIR_IN);
+
+    /* AON_GPIO_14    led_anode_2n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(2, aon_gpio_14, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_14_AON_GPIO_14);
+    AON_PADCTRL(1, aon_gpio_14_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 14, IODIR_IN);
+
+    /* AON_GPIO_15    led_anode_3n      I   GPIO       n/a     Low    n/a    option for 7 segment display, not used on D915    */
+    AON_PINMUX(2, aon_gpio_15, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_15_AON_GPIO_15);
+    AON_PADCTRL(1, aon_gpio_15_pad_ctrl, PULL_DOWN);
+    IODIR(AON_IODIR_LO, 15, IODIR_IN);
+
+    /* AON_GPIO_16        led_pwr_red    O    GPIO    HIgh    PULL_NONE    totem-pole    HIGH    "1 => red power LED ON init value to be confirmed, depending on standby LED behavior requested at boot" */
+    AON_PINMUX(2, aon_gpio_16, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_16_AON_GPIO_16);
+    AON_PADCTRL(1, aon_gpio_16_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 16, IODIR_OUT);
+    ODEN(AON_ODEN_LO, 16, TOTEM_POLE);
+    DATA(AON_DATA_LO, 16, 1);
+
+    /* AON_GPIO_17        sw_standby_n    I    GPIO    HIgh    PULL_NONE    N/A    N/A    stand-by key input, 1 => key pressed */
+    AON_PINMUX(2, aon_gpio_17, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_17_AON_GPIO_17);
+    AON_PADCTRL(1, aon_gpio_17_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 17, IODIR_IN);
+
+    /* AON_GPIO_18        sw_ch_up_n    I    GPIO    HIgh    PULL_NONE    N/A    N/A    channel up key input, 1 => key pressed */
+     AON_PINMUX(2, aon_gpio_18, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_18_AON_GPIO_18);
+    AON_PADCTRL(1, aon_gpio_18_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 18, IODIR_IN);
+
+    /* AON_GPIO_19        sw_ch_dwn_n    I    GPIO    HIgh    PULL_NONE    N/A    N/A    channel down key input,  1 => key pressed */
+    AON_PINMUX(2, aon_gpio_19, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_19_AON_GPIO_19);
+    AON_PADCTRL(1, aon_gpio_19_pad_ctrl, PULL_NONE);
+    IODIR(AON_IODIR_LO, 19, IODIR_IN);
+
+    /* AON_GPIO_20        PVR_POWER_EN    O    GPIO    HIgh    PULL_HIGH    totem-pole    HIgh    HDD supply switch, 1=> HDD power ON */
+    AON_PINMUX(2, aon_gpio_20, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_gpio_20_AON_GPIO_20);
+    AON_PADCTRL(1, aon_gpio_20_pad_ctrl, PULL_UP);
+    IODIR(AON_IODIR_LO, 20, IODIR_OUT);
+    ODEN(AON_ODEN_LO, 20, TOTEM_POLE);
+    DATA(AON_DATA_LO, 20, 1);
+
+    /* AON_SGPIO_00        rf4ce_irq_n    I    GPIO    LOW    N/A    N/A    N/A    */
+    AON_PINMUX(2, aon_sgpio_00, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_2_aon_sgpio_00_AON_SGPIO_00);
+    IODIR(AON_IODIR_EXT, 0, IODIR_IN);
+
+    /* AON_SGPIO_01        rf4ce_wkup    O    GPIO    LOW    N/A    open-drain    High */
+    AON_PINMUX(3, aon_sgpio_01, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_01_AON_SGPIO_01);
+    IODIR(AON_IODIR_EXT, 1, IODIR_OUT);
+    ODEN(AON_ODEN_EXT, 1, OPEN_DRAIN);
+    DATA(AON_DATA_EXT, 1, 1);
+
+    /* AON_SGPIO_02        RF4CE_SCL    O    AON_BSC_M1_SCL    LOW    N/A    open-drain    High    RF4CE_I2C */
+    AON_PINMUX(3, aon_sgpio_02, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_02_AON_BSC_M1_SCL);
+    IODIR(AON_IODIR_EXT, 2, IODIR_OUT);
+    ODEN(AON_ODEN_EXT, 2, OPEN_DRAIN);
+    DATA(AON_DATA_EXT, 2, 1);
+
+    /* AON_SGPIO_03        RF4CE_SDA    I/O    AON_BSC_M1_SDA    N/A    N/A    open-drain    High    RF4CE_I2C */
+    AON_PINMUX(3, aon_sgpio_03, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_03_AON_BSC_M1_SDA);
+    ODEN(AON_ODEN_EXT, 3, OPEN_DRAIN);
+    DATA(AON_DATA_EXT, 3, 1);
+
+    /* AON_SGPIO_04        HDMI_SCL    O    AON_BSC_M2_SCL    LOW    N/A    open-drain    High    HDMI I2C */
+    AON_PINMUX(3, aon_sgpio_04, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_04_AON_BSC_M2_SCL);
+    IODIR(AON_IODIR_EXT, 4, IODIR_OUT);
+    ODEN(AON_ODEN_EXT, 4, OPEN_DRAIN);
+    DATA(AON_DATA_EXT, 4, 1);
+
+    /* AON_SGPIO_05        HDMI_SDA    I/O    AON_BSC_M2_SDA    N/A    N/A    open-drain    High    HDMI I2C */
+    AON_PINMUX(3, aon_sgpio_05, BCHP_AON_PIN_CTRL_PIN_MUX_CTRL_3_aon_sgpio_05_AON_BSC_M2_SDA);
+    ODEN(AON_ODEN_EXT, 5, OPEN_DRAIN);
+    DATA(AON_DATA_EXT, 5, 1);
+
+    /* GPIO_000    sc_pwr_fail_n        I   GPIO    LOW     HIgh    N/A    detection of power fail to interrupt smart card dialog    */
+    PINMUX(0, gpio_000, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_0_gpio_000_GPIO_000);
+    PADCTRL(0, gpio_000_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 0, IODIR_IN);
+
+    /* GPIO_001    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_001_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 1, IODIR_IN);
+
+    /* GPIO_002    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_002_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 2, IODIR_IN);
+
+    /* GPIO_003    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_003_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 3, IODIR_IN);
+
+    /* GPIO_004    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_004_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 4, IODIR_IN);
+
+    /* GPIO_005    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(0, gpio_005_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 5, IODIR_IN);
+
+    /* GPIO_006    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_006_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 6, IODIR_IN);
+
+    /* GPIO_007    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_007_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 7, IODIR_IN);
+
+    /* GPIO_008    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_008_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 8, IODIR_IN);
+
+    /* GPIO_009    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_009_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 9, IODIR_IN);
+
+    /* GPIO_010    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_010_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 10, IODIR_IN);
+
+    /* GPIO_011    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_011_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 11, IODIR_IN);
+
+    /* GPIO_012    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_012_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 12, IODIR_IN);
+
+    /* GPIO_013    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_013_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 13, IODIR_IN);
+
+    /* GPIO_014    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_014_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 14, IODIR_IN);
+
+    /* GPIO_015    BCM7430_SPIM_SS1b    I   GPIO    n/a     Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(1, gpio_015, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_1_gpio_015_GPIO_015);
+    PADCTRL(1, gpio_015_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 15, IODIR_IN);
+
+    /* GPIO_016    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_016_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 16, IODIR_IN);
+
+    /* GPIO_017    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_017_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 17, IODIR_IN);
+
+    /* GPIO_018    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_018_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 18, IODIR_IN);
+
+    /* GPIO_019    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(1, gpio_019_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 19, IODIR_IN);
+
+    /* GPIO_020        7430_NOR_CS_N    O    EBI_CS0b    low    PULL_HIGH    totem-pole    HIGH   NAND FLASH INTERFACE */
+    PINMUX(2, gpio_020, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_2_gpio_020_EBI_CS0B);
+    PADCTRL(1, gpio_020_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 20, IODIR_OUT);
+    ODEN(ODEN_LO, 20, TOTEM_POLE);
+    DATA(DATA_LO, 20, 1);
+
+    /*  GPIO_021        7430_NAND_CE_NOT    O    EBI_CS1b    low    PULL_HIGH    totem-pole    HIGH */
+    PINMUX(2, gpio_021, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_2_gpio_021_EBI_CS1B);
+    PADCTRL(2, gpio_021_pad_ctrl, PULL_UP);
+    IODIR(IODIR_LO, 21, IODIR_OUT);
+    ODEN(ODEN_LO, 21, TOTEM_POLE);
+    DATA(DATA_LO, 21, 1);
+
+    /* GPIO_022    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_022_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 22, IODIR_IN);
+
+    /* GPIO_023    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_023_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 23, IODIR_IN);
+
+    /* GPIO_024    Unused               I   GPIO    n/a     Low    n/a    */
+    PADCTRL(2, gpio_024_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_LO, 24, IODIR_IN);
+
+    /* GPIO_025    7430_NAND_DATA0      I/O    NAND_DATA_0    */
+    PINMUX(3, gpio_025, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_025_EBI_DATA0);
+    PADCTRL(2, gpio_025_pad_ctrl, PULL_NONE);
+
+    /* GPIO_026    7430_NAND_DATA1      I/O    NAND_DATA_1    */
+    PINMUX(3, gpio_026, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_026_EBI_DATA1);
+    PADCTRL(2, gpio_026_pad_ctrl, PULL_NONE);
+
+    /* GPIO_027    7430_NAND_DATA2      I/O    NAND_DATA_2    */
+    PINMUX(3, gpio_027, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_027_EBI_DATA2);
+    PADCTRL(2, gpio_027_pad_ctrl, PULL_NONE);
+
+    /* GPIO_028    7430_NAND_DATA3      I/O    NAND_DATA_3    */
+    PINMUX(3, gpio_028, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_028_EBI_DATA3);
+    PADCTRL(2, gpio_028_pad_ctrl, PULL_NONE);
+
+    /* GPIO_029    7430_NAND_DATA4      I/O    NAND_DATA_4    */
+    PINMUX(3, gpio_029, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_029_EBI_DATA4);
+    PADCTRL(2, gpio_029_pad_ctrl, PULL_NONE);
+
+    /* GPIO_030    7430_NAND_DATA5      I/O    NAND_DATA_5    */
+    PINMUX(3, gpio_030, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_030_EBI_DATA5);
+    PADCTRL(2, gpio_030_pad_ctrl, PULL_NONE);
+
+    /* GPIO_031    7430_NAND_DATA6      I/O    NAND_DATA_6    */
+    PINMUX(3, gpio_031, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_3_gpio_031_EBI_DATA6);
+    PADCTRL(2, gpio_031_pad_ctrl, PULL_NONE);
+
+    /* GPIO_032    7430_NAND_DATA7      I/O    NAND_DATA_7    */
+    PINMUX(4, gpio_032, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_032_EBI_DATA7);
+    PADCTRL(2, gpio_032_pad_ctrl, PULL_NONE);
+
+    /* GPIO_033    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(2, gpio_033_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 1, IODIR_IN);
+
+    /* GPIO_034        SCART_SBnot    O    GPIO    LOW    PULL_NONE    open-drain     LOW     1=> SB off */
+    PINMUX(4, gpio_034, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_034_GPIO_034);
+    PADCTRL(2, gpio_034_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 2, IODIR_OUT);
+    ODEN(ODEN_HI, 2, OPEN_DRAIN);
+    DATA(DATA_HI, 2, 0);
+
+    /* GPIO_035        SCART_SB_6V    O    GPIO    HIGH    PULL_NONE    totem-pole    LOW     1=> SB=6V (if  SCART_SBnot=0) */
+    PINMUX(4, gpio_035, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_035_GPIO_035);
+    PADCTRL(2, gpio_035_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 3, IODIR_OUT);
+    ODEN(ODEN_HI, 3, TOTEM_POLE);
+    DATA(DATA_HI, 3, 0);
+
+    /* GPIO_036        SCART_FB    O    GPIO    HIGH    PULL_NONE    totem-pole    LOW     1=> FB on */
+    PINMUX(4, gpio_036, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_036_GPIO_036);
+    PADCTRL(3, gpio_036_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 4, IODIR_OUT);
+    ODEN(ODEN_HI, 4, TOTEM_POLE);
+    DATA(DATA_HI, 4, 0);
+
+    /* GPIO_037        AUDIO_MUTE    O    GPIO    LOW    PULL_NONE    totem-pole    LOW    shall remain low during the boot process until the DACs are properly initialized to avoid any plop. */
+    PINMUX(4, gpio_037, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_037_GPIO_037);
+    PADCTRL(3, gpio_037_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 5, IODIR_OUT);
+    ODEN(ODEN_HI, 5, TOTEM_POLE);
+    DATA(DATA_HI, 5, 0);
+
+    /* GPIO_038    BCM7430_SPIM_MOSI    I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(4, gpio_038, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_038_GPIO_038);
+    PADCTRL(3, gpio_038_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 6, IODIR_IN);
+
+    /* GPIO_039    BCM7430_SPIM_MISO    I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(4, gpio_039, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_4_gpio_039_GPIO_039);
+    PADCTRL(3, gpio_039_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 7, IODIR_IN);
+
+    /* GPIO_040    BCM7430_SPIM_SCK     I   GPIO    n/a    Low    n/a    option for SPI bus to BCM53125 (not used on D915)    */
+    PINMUX(5, gpio_040, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_040_GPIO_040);
+    PADCTRL(3, gpio_040_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 8, IODIR_IN);
+
+    /* GPIO_041        7430_NAND_READ_N    O    NAND_REb    N/A    PULL_NONE    N/A    N/A NAND FLASH INTERFACE*/
+    PINMUX(5, gpio_041, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_041_EBI_RDB);
+    PADCTRL(3, gpio_041_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 9, IODIR_OUT);
+
+    /* GPIO_042        7430_NAND_WE_N    O    NAND_WEb    N/A    PULL_NONE    N/A    N/A NAND FLASH INTERFACE*/
+     PINMUX(5, gpio_042, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_042_EBI_WE0B);
+    PADCTRL(3, gpio_042_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 10, IODIR_OUT);
+
+    /* GPIO_043        7430_NAND_WE_ALE    I    NAND_ALE    N/A    PULL_NONE    N/A    N/A NAND FLASH INTERFACE*/
+    PINMUX(5, gpio_043, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_043_EBI_DSB);
+    PADCTRL(3, gpio_043_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 11, IODIR_IN);
+
+    /* GPIO_044        7430_NAND_WE_CLE    I    NAND_CLE    N/A    PULL_NONE    N/A    N/A NAND FLASH INTERFACE*/
+    PINMUX(5, gpio_044, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_044_EBI_TSB);
+    PADCTRL(3, gpio_044_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 12, IODIR_IN);
+
+    /* GPIO_045        7430_NAND_RB_N    I    NAND_RBb    N/A    PULL_NONE    N/A    N/A NAND FLASH INTERFACE*/
+    PINMUX(5, gpio_045, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_045_EBI_NAND_RBB);
+    PADCTRL(3, gpio_045_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 13, IODIR_IN);
+
+    /* GPIO_046        HDMI_OFF    O    GPIO    HIgh    PULL_NONE    totem-pole    HIGH    HDMI 5V switch command. 1 => HDMI 5V ON */
+    PINMUX(5, gpio_046, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_5_gpio_046_GPIO_046);
+    PADCTRL(3, gpio_046_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 14, IODIR_OUT);
+    ODEN(ODEN_HI, 14, TOTEM_POLE);
+    DATA(DATA_HI, 14, 1);
+
+    /* GPIO_047    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_047_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 15, IODIR_IN);
+
+    /* GPIO_048    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_048_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 16, IODIR_IN);
+
+    /* GPIO_049     Scart_vid_buf_enable_n  I   GPIO    N/A PULL_LOW    N/A N/A option not used on D915 (if option included: 1 => Video buffer ON) */
+    PINMUX(6, gpio_049, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_6_gpio_049_GPIO_049);
+    PADCTRL(3, gpio_049_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 17, IODIR_IN);
+
+    /* GPIO_050    Unused               I   GPIO    n/a    Low    n/a    */
+    PADCTRL(3, gpio_050_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 18, IODIR_IN);
+
+    /* GPIO_051        led_pwr_grn    O    GPIO    HIgh    PULL_NONE    totem-pole    LOW    "1 => green power LED ON init value to be confirmed, depending on standby LED behavior requested at boot" */
+    PINMUX(6, gpio_051, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_6_gpio_051_GPIO_051);
+    PADCTRL(4, gpio_051_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_HI, 19, IODIR_OUT);
+    ODEN(ODEN_HI, 19, TOTEM_POLE);
+    DATA(DATA_HI, 19, 0);
+
+    /* GPIO_052    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_052_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 20, IODIR_IN);
+
+    /* GPIO_053    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_053_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 21, IODIR_IN);
+
+    /* GPIO_054    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_054_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 22, IODIR_IN);
+
+    /* GPIO_055    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_055_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 23, IODIR_IN);
+
+    /* GPIO_056    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_056_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 24, IODIR_IN);
+
+    /* GPIO_057    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_057_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 25, IODIR_IN);
+
+    /* GPIO_058    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_058_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 26, IODIR_IN);
+
+    /* GPIO_059    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_059_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 27, IODIR_IN);
+
+    /* GPIO_060    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_060_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 28, IODIR_IN);
+
+    /* GPIO_061    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_061_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 29, IODIR_IN);
+
+    /* GPIO_062    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(7, gpio_062, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_7_gpio_062_GPIO_062);
+    PADCTRL(4, gpio_062_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 30, IODIR_IN);
+
+    /* GPIO_063    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(7, gpio_063, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_7_gpio_063_GPIO_063);
+    PADCTRL(4, gpio_063_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_HI, 31, IODIR_IN);
+
+    /* GPIO_064    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(4, gpio_064_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 4, IODIR_IN);
+
+    /* GPIO_065     UART_TXD_1  O   UART_TX1    N/A PULL_NONE   N/A HIGH    TESTTASK    interface   */
+    PINMUX(8, gpio_065, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_8_gpio_065_UART_TX1);
+    PADCTRL(4, gpio_065_pad_ctrl, PULL_NONE);
+    DATA(DATA_EXT, 5, 1);
+
+    /* GPIO_066    UART_RXD_1    UART_RX1        TESTTASK interface    */
+    PINMUX(8, gpio_066, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_8_gpio_066_UART_RX1);
+    PADCTRL(5, gpio_066_pad_ctrl, PULL_NONE);
+
+    /* GPIO_067    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_067_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 7, IODIR_IN);
+
+    /* GPIO_068    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_068_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 8, IODIR_IN);
+
+    /* GPIO_069    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_069_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 9, IODIR_IN);
+
+    /* GPIO_070    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_070_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 10, IODIR_IN);
+
+    /* GPIO_071    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_071_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 11, IODIR_IN);
+
+    /* GPIO_072        RF4CE_resetn    O    GPIO    Low    PULL_NONE    totem-pole    LOW    to reset RF4CE (0 ==> GP510 resetted). GP510 has to be resetted at start-up. */
+    PINMUX(9, gpio_072, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_072_GPIO_072);
+    PADCTRL(5, gpio_072_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 12, IODIR_OUT);
+    ODEN(ODEN_EXT, 12, TOTEM_POLE);
+    DATA(DATA_EXT, 12, 0);
+
+    /* GPIO_073    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_073_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 13, IODIR_IN);
+
+    /* GPIO_074    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_074_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 14, IODIR_IN);
+
+    /* GPIO_075        led_rec    O    GPIO    HIGH    PULL_NONE    totem-pole    LOW    1=> record LED ON */
+    PINMUX(9, gpio_075, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_075_GPIO_075);
+    PADCTRL(5, gpio_075_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 15, IODIR_OUT);
+    ODEN(ODEN_EXT, 15, TOTEM_POLE);
+    DATA(DATA_EXT, 15, 0);
+
+    /* GPIO_076    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(5, gpio_076_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 16, IODIR_IN);
+
+    /* GPIO_077    not_sc_1v8           I    GPIO    */
+    PINMUX(9, gpio_077, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_077_GPIO_077);
+    PADCTRL(5, gpio_077_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 17, IODIR_IN);
+
+    /* GPIO_078    sc_5v_not_3v         O    GPIO    */
+    PINMUX(9, gpio_078, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_078_GPIO_078);
+    PADCTRL(5, gpio_078_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 18, IODIR_OUT);
+
+    /* GPIO_079    SC_VCC               O    SC0_VCC    */
+    PINMUX(9, gpio_079, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_9_gpio_079_SC0_VCC);
+    PADCTRL(5, gpio_079_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 19, IODIR_OUT);
+
+    /* GPIO_080    SC_CLK               O    SC0_CLK    */
+    PINMUX(10, gpio_080, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_080_SC0_CLK);
+    PADCTRL(5, gpio_080_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 20, IODIR_OUT);
+
+    /* GPIO_081    SC_RST               O    SC0_RST    */
+    PINMUX(10, gpio_081, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_081_SC0_RST);
+    PADCTRL(6, gpio_081_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 21, IODIR_OUT);
+
+    /* GPIO_082    SC_data              I/O    SC0_IO    */
+    PINMUX(10, gpio_082, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_082_SC0_IO);
+    PADCTRL(6, gpio_082_pad_ctrl, PULL_NONE);
+
+    /* GPIO_083    SC_PRES              I    SC0_PRES        */
+    PINMUX(10, gpio_083, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_083_SC0_PRES);
+    PADCTRL(6, gpio_083_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 23, IODIR_IN);
+
+    /* GPIO_084    SC_AUX0              I    GPIO    n/a    Low    n/a    not used on D915    */
+    PINMUX(10, gpio_084, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_084_GPIO_084);
+    PADCTRL(6, gpio_084_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 24, IODIR_IN);
+
+    /* GPIO_085    SC_AUX1              I    GPIO    n/a    Low    n/a    not used on D915    */
+    PINMUX(10, gpio_085, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_085_GPIO_085);
+    PADCTRL(6, gpio_085_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 25, IODIR_IN);
+
+    /* GPIO_086    Unused               I    GPIO    n/a    Low    n/a    */
+    PINMUX(10, gpio_086, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_086_GPIO_086);
+    PADCTRL(6, gpio_086_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 26, IODIR_IN);
+
+    /* GPIO_087    MTSIF_CLK            I    MTSIF0_CLK        Multiplex Transport Stream interface with BCM3383    */
+    PINMUX(10, gpio_087, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_10_gpio_087_MTSIF0_CLK);
+    PADCTRL(6, gpio_087_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 27, IODIR_IN);
+
+    /* GPIO_088    MTSIF_DATA0          I    MTSIF0_DATA0    */
+    PINMUX(11, gpio_088, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_088_MTSIF0_DATA0);
+    PADCTRL(6, gpio_088_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 28, IODIR_IN);
+
+    /* GPIO_089    MTSIF_SYNC           I    MTSIF0_SYNC        */
+    PINMUX(11, gpio_089, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_089_MTSIF0_SYNC);
+    PADCTRL(6, gpio_089_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 29, IODIR_IN);
+
+    /* GPIO_090    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_090_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT, 30, IODIR_IN);
+
+    /* GPIO_091    MTSIF_DATA1          I    MTSIF0_DATA1    */
+    PINMUX(11, gpio_091, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_091_MTSIF0_DATA1);
+    PADCTRL(6, gpio_091_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT, 31, IODIR_IN);
+
+    /* GPIO_092    UART_TXD_0           UART_TX0        CFE interface    */
+    PINMUX(11, gpio_092, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_092_UART_TX0);
+    PADCTRL(6, gpio_092_pad_ctrl, PULL_NONE);
+    DATA(DATA_EXT_HI, 0, 1);
+
+    /* GPIO_093    UART_RXD_0           UART_RX0        CFE interface    */
+    PINMUX(11, gpio_093, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_11_gpio_093_UART_RX0);
+    PADCTRL(6, gpio_093_pad_ctrl, PULL_NONE);
+
+    /* GPIO_094    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_094_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 2, IODIR_IN);
+
+    /* GPIO_095    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(6, gpio_095_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 3, IODIR_IN);
+
+    /* GPIO_096    FAN_CTRL             O    PWM0    N/A    HIgh    low    fan pwm, fan speed is increased when PWM duty cycle is decreasing    */
+    PINMUX(12, gpio_096, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_096_PWM0);
+    PADCTRL(7, gpio_096_pad_ctrl, PULL_UP);
+    IODIR(IODIR_EXT_HI, 4, IODIR_OUT);
+    DATA(DATA_EXT_HI, 4, 0);
+
+    /* GPIO_097    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_097_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 5, IODIR_IN);
+
+    /* GPIO_098        fan_tacho    I    ????    N/A    PULL_NONE    N/A    N/A    This is a special GPIO. Check with BCM. */
+#if 0
+    PINMUX(12, gpio_098, 0);
+    PADCTRL(7, gpio_098_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 6, IODIR_IN);
+#else
+    #warning "GPIO_098 fan_tacho => SPEC ISSUE TBC"
+#endif
+
+    /* GPIO_099    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_099_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 7, IODIR_IN);
+
+    /* GPIO_100    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(7, gpio_100_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 8, IODIR_IN);
+
+    /* GPIO_101    MTSIF_DATA2          I    MTSIF0_DATA2        Multiplex Transport Stream interface with BCM3383 */
+    PINMUX(12, gpio_101, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_101_MTSIF0_DATA2);
+    PADCTRL(7, gpio_101_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 9, IODIR_IN);
+
+    /* GPIO_102    MTSIF_DATA3          I    MTSIF0_DATA3    */
+    PINMUX(12, gpio_102, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_102_MTSIF0_DATA3);
+    PADCTRL(7, gpio_102_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 10, IODIR_IN);
+
+    /* GPIO_103    MTSIF_DATA4          I    MTSIF0_DATA4    */
+    PINMUX(12, gpio_103, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_103_MTSIF0_DATA4);
+    PADCTRL(7, gpio_103_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 11, IODIR_IN);
+
+    /* GPIO_104        MTSIF_ATS_RST    I    MTSIF_ATS_RST    N/A        N/A    N/A */
+    PINMUX(12, gpio_104, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_12_gpio_104_MTSIF_ATS_RST);
+    IODIR(IODIR_EXT_HI, 12, IODIR_IN);
+
+    /* GPIO_105    MTSIF_DATA5          I    MTSIF0_DATA5    */
+    PINMUX(13, gpio_105, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_13_gpio_105_MTSIF0_DATA5);
+    PADCTRL(7, gpio_105_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 13, IODIR_IN);
+
+    /* GPIO_0106 to 0113 are used for dedicated USB interface */
+    /* GPIO_106 ???? */
+    /* GPIO_107 ???? */
+    /* GPIO_108 ???? */
+    /* GPIO_109 ???? */
+    /* GPIO_110 ???? */
+    /* GPIO_111 ???? */
+    /* GPIO_112 ???? */
+    /* GPIO_113 ???? */
+
+    /* GPIO_114    "GP114_ENET0_ACTIVITY    (unused, but strapping resistor connected)"    I    GPIO    */
+    PINMUX(14, gpio_114, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_114_GPIO_114);
+    PADCTRL(8, gpio_114_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 22, IODIR_IN);
+
+    /* GPIO_115 ???? */
+
+    /* GPIO_116        MTSIF_ATS_INC    I    MTSIF_ATS_INC    N/A        N/A    N/A */
+    PINMUX(14, gpio_116, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_116_MTSIF_ATS_INC);
+    IODIR(IODIR_EXT_HI, 24, IODIR_IN);
+
+    /* GPIO_117    MTSIF_DATA6          I    MTSIF0_DATA6    */
+    PINMUX(14, gpio_117, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_117_MTSIF0_DATA6);
+    PADCTRL(8, gpio_117_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 25, IODIR_IN);
+
+    /* GPIO_118    MTSIF_DATA7          I    MTSIF0_DATA7    */
+    PINMUX(14, gpio_118, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_14_gpio_118_MTSIF0_DATA7);
+    PADCTRL(8, gpio_118_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT_HI, 26, IODIR_IN);
+
+    /* GPIO_119 ???? */
+    /* GPIO_120 ???? */
+    /* GPIO_121 ???? */
+
+    /* GPIO_122    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_122_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 30, IODIR_IN);
+
+    /* GPIO_123    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_123_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT_HI, 31, IODIR_IN);
+
+    /* GPIO_124    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_124_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 0, IODIR_IN);
+
+    /* GPIO_125    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_125_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 1, IODIR_IN);
+
+    /* GPIO_126    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_126_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 2, IODIR_IN);
+
+    /* GPIO_127    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_127_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 3, IODIR_IN);
+
+    /* GPIO_128    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_128_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 4, IODIR_IN);
+
+    /* GPIO_129    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(8, gpio_129_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 5, IODIR_IN);
+
+    /* GPIO_130    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(9, gpio_130_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 6, IODIR_IN);
+
+    /* GPIO_131    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(9, gpio_131_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 7, IODIR_IN);
+
+    /* GPIO_132    53125_7430_RGMII_RXDV    I    MII_RX_DV        EMAC0 interface with ethernet switch    */
+    PINMUX(15, gpio_132, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_15_gpio_132_MII_RX_DV);
+    PADCTRL(9, gpio_132_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 8, IODIR_IN);
+
+    /* GPIO_133    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_133_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 9, IODIR_IN);
+
+    /* GPIO_134    53125_7430_RGMII_RXCLK    I    MII_RX_CLK    */
+    PINMUX(16, gpio_134, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_134_MII_RX_CLK);
+    PADCTRL(9, gpio_134_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 10, IODIR_IN);
+
+    /* GPIO_135    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_135_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 11, IODIR_IN);
+
+    /* GPIO_136    Unused               I    n/a    Low    n/a    */
+    PADCTRL(9, gpio_136_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 12, IODIR_IN);
+
+    /* GPIO_137        7430_GP_137_MII_MDIO (option not used on D915)    I    GPIO    N/A    PULL_LOW    N/A    N/A */
+    PINMUX(16, gpio_137, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_137_GPIO_137);
+    PADCTRL(9, gpio_137_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 13, IODIR_IN);
+
+    /* GPIO_138    53125_7430_RMII_TXCLK    O    MII_TX_CLK    */
+    PINMUX(16, gpio_138, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_138_MII_TX_CLK);
+    PADCTRL(9, gpio_138_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 14, IODIR_OUT);
+
+    /* GPIO_139    53125_7430_RGMII_RXD3    I    MII_RXD_03    */
+    PINMUX(16, gpio_139, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_139_MII_RXD_03);
+    PADCTRL(9, gpio_139_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 15, IODIR_IN);
+
+    /* GPIO_140    53125_7430_RGMII_RXD2    I    MII_RXD_02    */
+    PINMUX(16, gpio_140, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_16_gpio_140_MII_RXD_02);
+    PADCTRL(9, gpio_140_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 16, IODIR_IN);
+
+    /* GPIO_141    53125_7430_RGMII_RXD1    I    MII_RXD_01    */
+    PINMUX(17, gpio_141, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_141_MII_RXD_01);
+    PADCTRL(9, gpio_141_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 17, IODIR_IN);
+
+    /* GPIO_142    53125_7430_RGMII_RXD0    i    MII_RXD_00    */
+    PINMUX(17, gpio_142, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_142_MII_RXD_00);
+    PADCTRL(9, gpio_142_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 18, IODIR_IN);
+
+    /* GPIO_143    53125_7430_RGMII_TXD3    O    MII_TXD_03    */
+    PINMUX(17, gpio_143, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_143_MII_TXD_03);
+    PADCTRL(9, gpio_143_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 19, IODIR_OUT);
+
+    /* GPIO_144    53125_7430_RGMII_TXD2    O    MII_TXD_02    */
+    PINMUX(17, gpio_144, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_144_MII_TXD_02);
+    PADCTRL(9, gpio_144_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 20, IODIR_OUT);
+
+    /* GPIO_145    53125_7430_RGMII_TXD1    O    MII_TXD_01    */
+    PINMUX(17, gpio_145, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_145_MII_TXD_01);
+    PADCTRL(10, gpio_145_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 21, IODIR_OUT);
+
+    /* GPIO_146    53125_7430_RGMII_TXD0    O    MII_TXD_00    */
+    PINMUX(17, gpio_146, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_146_MII_TXD_00);
+    PADCTRL(10, gpio_146_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 22, IODIR_OUT);
+
+    /* GPIO_147    53125_7430_RGMII_TXDV    O    MII_TXD_EN    */
+    PINMUX(17, gpio_147, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_17_gpio_147_MII_TX_EN);
+    PADCTRL(10, gpio_147_pad_ctrl, PULL_NONE);
+    IODIR(IODIR_EXT2, 23, IODIR_OUT);
+
+    /* GPIO_148    Unused               I    GPIO    n/a    Low    n/a    */
+    PADCTRL(10, gpio_148_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 24, IODIR_IN);
+
+    /* GPIO_149 53125_7430_MII_MDC  (option not used on D915)   +   spare strapping for boot    I   GPIO    N/A PULL_LOW    N/A N/A */
+    PINMUX(18, gpio_149, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_gpio_149_GPIO_149);
+    PADCTRL(10, gpio_149_pad_ctrl, PULL_DOWN);
+    IODIR(IODIR_EXT2, 25, IODIR_IN);
+
+    /* SGPIO_00        3450_BSC_SCL    O    BSC_M3_SCL    LOW    N/A    open-drain    HIGH    MOCA I2C Clock */
+    PINMUX(18, sgpio_00, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_sgpio_00_BSC_M3_SCL);
+    IODIR(IODIR_EXT, 0, IODIR_OUT);
+    ODEN(DATA_EXT, 0, OPEN_DRAIN);
+    DATA(DATA_EXT, 0, 1);
+
+    /* SGPIO_01        3450_BSC_SDA    I/O    BSC_M3_SDA    N/A    N/A    open-drain    HIGH    MOCA I2C Data */
+    PINMUX(18, sgpio_01, BCHP_SUN_TOP_CTRL_PIN_MUX_CTRL_18_sgpio_01_BSC_M3_SDA);
+    ODEN(DATA_EXT, 1, OPEN_DRAIN);
+    DATA(DATA_EXT, 1, 1);
+
+    /* SGPIO_02    Unused               I    SGPIO    n/a    Low    n/a */
+    IODIR(IODIR_EXT, 2, IODIR_IN);
+
+    /* SGPIO_03    Unused               I    SGPIO    n/a    Low    n/a    */
+    IODIR(IODIR_EXT, 3, IODIR_IN);
+}
+
+void board_pinmux_setup_default(void)
+{
 #if !defined(CONFIG_BRCM_IKOS)
 #if defined(CONFIG_BCM7231)
 
@@ -632,14 +2326,15 @@
  * FLASH configuration
  ***********************************************************************/
 
+#if !defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
 #if defined(CONFIG_BRCM_FIXED_MTD_PARTITIONS)
 
 static struct mtd_partition fixed_partition_map[] = {
 	{
-		.name = "entire_device",
+		.name = "entire_device", 	
 		.size = MTDPART_SIZ_FULL,
 		.offset = 0x00000000
-	},
+	},	
 };
 
 /*
@@ -664,7 +2359,7 @@
 int __init board_get_partition_map(struct mtd_partition **p)
 {
 	struct mtd_partition *ret;
-	int nr_parts;
+int nr_parts;
 
 	if (brcm_mtd_rootfs_len == 0)
 		return -ENODEV;
@@ -696,6 +2391,8 @@
 }
 #endif /* defined(CONFIG_BRCM_FIXED_MTD_PARTITIONS) */
 
+#endif
+
 void brcm_get_ocap_info(struct brcm_ocap_info *info)
 {
 	info->ocap_part_start = brcm_mtd_ocap_start;
diff -Naur kernel-3.3-3.0a-ref/drivers/brcmstb/setup.c kernel-current/drivers/brcmstb/setup.c
--- kernel-3.3-3.0a-ref/drivers/brcmstb/setup.c	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/brcmstb/setup.c	2013-11-29 10:10:03.163205852 +0100
@@ -41,6 +41,8 @@
 #include "../drivers/mmc/host/sdhci-pltfm.h"
 
 #include <linux/brcmstb/brcmstb.h>
+#include <linux/mtd/nand_flash_mapping.h>
+#include <linux/mtd/nor_flash_mapping.h>
 
 #ifndef CONFIG_MTD
 /* squash MTD warning on IKOS builds */
@@ -419,7 +421,7 @@
 	res[1].start = BRCM_IRQ_MOCA;
 	res[1].flags = IORESOURCE_IRQ;
 
-	brcm_alloc_macaddr(macaddr);
+	brcm_alloc_moca_macaddr(macaddr);
 	mac_to_u32(&pdata.macaddr_hi, &pdata.macaddr_lo, macaddr);
 
 	strcpy(pdata.enet_name, "bcmgenet");
@@ -545,7 +547,7 @@
 
 static struct ebi_cs_info cs_info[NUM_CS];
 
-#ifdef CONFIG_BRCM_HAS_SPI
+#if defined(CONFIG_BRCM_HAS_SPI) && defined(CONFIG_SPI_MASTER)
 static int __init brcm_setup_spi_flash(int cs, int bus_num, int nr_parts,
 	struct mtd_partition *parts)
 {
@@ -658,7 +660,7 @@
 		res.start = cs_info[cs].start;
 		res.end = cs_info[cs].start + cs_info[cs].len - 1;
 		res.flags = IORESOURCE_MEM;
-
+		
 		pdev = platform_device_alloc("physmap-flash", nor_id++);
 		if (!pdev ||
 		    platform_device_add_resources(pdev, &res, 1) ||
@@ -675,8 +677,8 @@
 		pdata.chip_select = cs;
 		pdata.nr_parts = nr_parts;
 		pdata.parts = parts;
-
-		pdev = platform_device_alloc("brcmnand", nand_id++);
+		
+		pdev = platform_device_alloc("pacenand", nand_id++);
 		if (!pdev ||
 		    platform_device_add_data(pdev, &pdata, sizeof(pdata)) ||
 		    platform_device_add(pdev))
@@ -684,7 +686,7 @@
 		break;
 	}
 	case TYPE_SPI: {
-#ifdef CONFIG_BRCM_HAS_SPI
+#if defined(CONFIG_BRCM_HAS_SPI) && defined(CONFIG_SPI_MASTER)
 		const int bus_num = 0;
 		static int spi_master_registered;
 		int ret;
@@ -731,16 +733,23 @@
 #endif
 	}
 }
-
+#if !defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
 static struct map_info brcm_dummy_map = {
 	.name			= "DUMMY",
 };
+#endif
 
 static int __init brcmstb_mtd_setup(void)
 {
+#if defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+	struct brcm_mtd_partition_map *parts_array;     /* Array of parts for multiple devices */
+    int    nr_entries = 0;
+    int i;
+#else
 	struct mtd_partition *parts;
 	int nr_parts;
 	int i, first = -1, primary = -1, primary_type = TYPE_NAND;
+#endif
 
 #ifdef CONFIG_OF
 	return 0;
@@ -748,6 +757,30 @@
 	if (noflash)
 		return 0;
 
+#if defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+	nr_entries = board_get_partition_map_pace(&parts_array);
+	printk("number of entries in new partiton map = %d\n", nr_entries);
+    for (i = 0; i < nr_entries; i++) {
+        struct brcm_mtd_partition_map * part_map = &parts_array[i];
+
+        printk("Entry %d has %d partitions\n", i, part_map->num_parts);
+        if(part_map->num_parts) {
+            int j;
+            struct mtd_partition * entry = part_map->partition_map;
+
+            for (j = 0; j < part_map->num_parts; j++) {
+                printk("Partition %d has size=0x%X, offset=0x%X, name=%s\n",
+                                  j,
+                                  (unsigned int)entry[j].size,
+                                  (unsigned int)entry[j].offset,
+                                  entry[j].name);
+            }
+        }
+    }
+#else
+/* RT171011
+   we don't want to create a dummy MTD0, as there is usually a
+   command-line MTD partition definition that we prefer to use */
 	nr_parts = board_get_partition_map(&parts);
 	if (nr_parts <= 0) {
 		struct mtd_info *mtd;
@@ -778,7 +811,7 @@
 	for (i = TYPE_NOR; i <= TYPE_MAX; i++)
 		if (strcmp(brcm_mtd_flash_type, type_names[i]) == 0)
 			primary_type = i;
-
+#endif
 	/* scan each chip select to see what (if anything) lives there */
 	for (i = 0; i < NUM_CS; i++) {
 		u32 base, size, config __maybe_unused;
@@ -820,7 +853,7 @@
 		if (BDEV_RD(BCHP_NAND_CS_NAND_SELECT) & (0x100 << i))
 			cs_info[i].type = TYPE_NAND;
 #endif
-
+#if !defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
 		if (cs_info[i].type != TYPE_NAND && nandcs[i] != 0) {
 			cs_info[i].type = TYPE_NAND;
 		} else {
@@ -835,8 +868,10 @@
 		}
 		if (first == -1 && cs_info[i].type != TYPE_NONE)
 			first = i;
+#endif  /* !defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT */
 	}
 
+#if !defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
 	if (primary == -1) {
 		if (first == -1) {
 			printk(KERN_INFO "EBI: No flash devices detected\n");
@@ -845,7 +880,34 @@
 		primary = first;
 		primary_type = cs_info[primary].type;
 	}
+#endif
+
+#if defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+    /* Set up each active CS of a particular type with it's own MTD partition(s) */
+	for (i = 0; i < NUM_CS; i++) {
+        int type = cs_info[i].type;
 
+		if ((type != FLASH_TYPE_NONE) && (type <= FLASH_TYPE_MAX )) {
+            /* Find entries for this memory type */
+            int j;
+            struct brcm_mtd_partition_map * part_map = &parts_array[type - 1];
+            struct mtd_partition          * entry    = part_map->partition_map;
+
+			printk("EBI CS%d: Setting up %s flash\n", i, type_names[type]);
+			printk("EBI CS%d: Number of partitions=%d\n", i, part_map->num_parts);
+			for (j = 0; j < part_map->num_parts; j++) {
+
+			    printk("EBI CS%d: Partition %d has size=0x%X, offset=0x%X, name=%s\n",
+			                      i,
+			                      j,
+			                      (unsigned int)entry[j].size,
+			                      (unsigned int)entry[j].offset,
+			                      entry[j].name);
+			}
+			brcm_setup_cs(i, part_map->num_parts, part_map->partition_map);
+		}
+	}
+#else
 	/* set up primary first, so that it owns mtd0/mtd1/(mtd2) */
 	printk(KERN_INFO "EBI CS%d: setting up %s flash (primary)\n", primary,
 		type_names[primary_type]);
@@ -858,6 +920,7 @@
 			brcm_setup_cs(i, 0, NULL);
 		}
 	}
+#endif
 
 	return 0;
 }
@@ -956,3 +1019,92 @@
 	}
 	return str;
 }
+
+#if defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+
+static struct mtd_partition fixed_partition_map_nand[] = {  
+	{
+		.name = NAND_FLASH_LINUX_SCHNG_NAME,
+		.size = NAND_FLASH_LINUX_SCHNG_SIZE,
+		.offset = NAND_FLASH_LINUX_SCHNG_ADDRESS
+	},
+	{
+		.name = NAND_FLASH_LINUX_AXIROS_NAME,
+		.size = NAND_FLASH_LINUX_AXIROS_SIZE,
+		.offset = NAND_FLASH_LINUX_AXIROS_ADDRESS
+	},	
+	{
+		.name = NAND_FLASH_LINUX_EPG_NAME,
+		.size = NAND_FLASH_LINUX_EPG_SIZE,
+		.offset = NAND_FLASH_LINUX_EPG_ADDRESS
+	},
+	{
+		.name = NAND_FLASH_LINUX_UI_NAME,
+		.size = NAND_FLASH_LINUX_UI_SIZE,
+		.offset = NAND_FLASH_LINUX_UI_ADDRESS
+	},	
+	{
+		.name = NAND_FLASH_LINUX_VFS_NAME,
+		.size = NAND_FLASH_LINUX_VFS_SIZE,
+		.offset = NAND_FLASH_LINUX_VFS_ADDRESS
+	}
+};
+
+static struct mtd_partition fixed_partition_map_spi[] = {
+   {
+      .name   = NOR_FLASH_SDIF_NAME,
+      .size   = NOR_FLASH_SDIF_SIZE,
+      .offset = NOR_FLASH_SDIF_ADDRESS,     
+   },
+   {
+      .name   = NOR_FLASH_UTSBL_NAME,
+      .size   = NOR_FLASH_UTSBL_SIZE,
+      .offset = NOR_FLASH_UTSBL_ADDRESS,     
+   },
+   {
+      .name   = NOR_FLASH_TBX_NAME,
+      .size   = NOR_FLASH_TBX_SIZE,
+      .offset = NOR_FLASH_TBX_ADDRESS,
+   },
+   {
+      .name   = NOR_FLASH_OSY_NAME,
+      .size   = NOR_FLASH_OSY_SIZE,
+      .offset = NOR_FLASH_OSY_ADDRESS,     
+   },   
+   {
+      .name   = NOR_FLASH_FUT_NAME,
+      .size   = NOR_FLASH_FUT_SIZE,
+      .offset = NOR_FLASH_FUT_ADDRESS,     
+   },
+   {
+      .name   = NOR_FLASH_BSECK_RELOAD_NAME,
+      .size   = NOR_FLASH_BSECK_RELOAD_SIZE,
+      .offset = NOR_FLASH_BSECK_RELOAD_ADDRESS,     
+   },
+};
+
+static struct brcm_mtd_partition_map fixed_partition_map[FLASH_TYPE_MAX] = {
+   /* NORFLASH partitions */
+   {
+      0,        /* No NORFLASH partitions */
+      NULL
+   },
+   /* NANDFLASH partitions */
+   {
+      5,
+      fixed_partition_map_nand
+   },
+   /* SPIFLASH partitions */
+   {
+      6,
+      fixed_partition_map_spi
+   }
+};
+
+int __init board_get_partition_map_pace(struct brcm_mtd_partition_map  **p)
+{
+   *p = fixed_partition_map;
+   return 3;
+}
+
+#endif
diff -Naur kernel-3.3-3.0a-ref/drivers/genid/genid_driver.c kernel-current/drivers/genid/genid_driver.c
--- kernel-3.3-3.0a-ref/drivers/genid/genid_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/genid/genid_driver.c	2013-11-29 10:10:03.179205711 +0100
@@ -0,0 +1,177 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/security.h>
+#include <linux/genid_driver.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("genid interface");
+MODULE_AUTHOR("");
+ 
+DEFINE_MUTEX(genid_mutex);
+
+static int GENID_Open = 0;
+static int Major;
+
+extern void sh_reset (void) __attribute__ ((noreturn));
+
+static int genid_open(struct inode *inode, struct file *file);
+
+#if defined(HAVE_UNLOCKED_IOCTL)
+static long genid_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
+                     unsigned long genid_data);
+#else
+static int genid_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
+                     unsigned long genid_data);
+#endif
+
+static int genid_release(struct inode *inode, struct file *file);
+
+static struct file_operations genid_fops = {
+ .owner   = THIS_MODULE,
+ .open    = genid_open,
+#if defined(HAVE_UNLOCKED_IOCTL)
+ .unlocked_ioctl   = genid_ioctl,
+#else
+ .ioctl   = genid_ioctl,
+#endif
+ .release = genid_release,
+};
+
+
+#define MAX_PID 100
+#define MAX_LEN 256
+
+struct pmw_task {
+  char name[MAX_LEN];
+  unsigned int pid;
+};
+
+static struct pmw_task pmw_tasks[MAX_PID];
+static unsigned int pmw_count = 1;
+
+#if defined(HAVE_UNLOCKED_IOCTL)
+static long genid_ioctl(struct inode *inode, struct file *filp, 
+                     unsigned int cmd, unsigned long genid_data) 
+#else
+static int genid_ioctl(struct inode *inode, struct file *filp, 
+                     unsigned int cmd, unsigned long genid_data) 
+#endif
+{
+  int err=0;
+  unsigned int i = 0; 
+  unsigned int pid;
+  unsigned int res;
+  
+  if (_IOC_DIR(cmd) & _IOC_READ)
+  {
+      printk ("%s:%d ERROR access _IOC_READ\n", __FUNCTION__,__LINE__);
+      err = !access_ok(VERIFY_WRITE, (void *)genid_data, _IOC_SIZE(cmd));
+  }
+  else if (_IOC_DIR(cmd) & _IOC_WRITE)
+  {
+      printk ("%s:%d ERROR access _IOC_WRITE\n", __FUNCTION__,__LINE__);
+      err = !access_ok(VERIFY_READ, (void *)genid_data, _IOC_SIZE(cmd)); 
+  }
+  
+  if (err) 
+  {
+      printk ("%s:%d ERROR access return:%d\n", __FUNCTION__,__LINE__,-EFAULT);
+      return -EFAULT; 
+  }
+  
+  switch(cmd)
+  {
+    case GENID_GETID:
+        //printk("From kernel ===> looking for pid of %s\n", current->comm);
+        
+        while (i < MAX_PID)
+        {                         
+            res = strncmp(pmw_tasks[i].name, current->comm, strlen(current->comm));
+            if (res != 0)
+            {
+                if (strlen(pmw_tasks[i].name) == 0)
+                {
+                    //printk ("adding %s at %d pid %d!!!!!!!!!!!!!!!!\n", current->comm, i, pmw_count);
+                    strncpy(pmw_tasks[i].name, current->comm, strlen(current->comm));
+                    pmw_tasks[i].pid = pmw_count;
+                    pmw_count++;
+                    pid = pmw_tasks[i].pid;
+                    return pid;
+                }
+            }
+            else
+            {
+                pid = pmw_tasks[i].pid;
+                return pid;
+            }
+            i++;
+        }//end while
+        if  (i == MAX_PID)
+        {
+            printk ("%s:%d ERROR too much tasks return:%d\n", __FUNCTION__,__LINE__,-EFAULT);
+            return -EFAULT;
+        }
+        break;
+    default:
+      printk ("%s:%d ERROR unknown ioctl return:%d\n", __FUNCTION__,__LINE__,-ENOTTY);
+      return -ENOTTY;
+  }//end switch
+  
+  //should never be reached
+  printk ("%s:%d ERROR return:%d\n", __FUNCTION__,__LINE__,-EFAULT);
+  return -EFAULT;
+}
+
+static int genid_open(struct inode *inode, struct file *file)
+{
+  if (GENID_Open > 1)
+  {
+      printk ("%s:%d return -EBUSY=%d\n", __FUNCTION__,__LINE__,-EBUSY);
+      return -EBUSY;
+  }
+  
+  GENID_Open++;
+  try_module_get(THIS_MODULE);
+  return 0;
+}
+
+static int genid_release(struct inode *inode, struct file *file)
+{
+  GENID_Open--;/* We're now ready for our next caller */
+  module_put(THIS_MODULE);
+  return 0;
+}
+
+/* Initialization routine */ 
+static int __init genid_init(void) 
+{
+  int j = 0; 
+  
+  Major = register_chrdev(0, DEVICE_NAME, &genid_fops);
+  
+  if (Major < 0)
+  {
+      printk("registering char device failed with %d\n", Major);
+      return Major;
+  }
+  
+  printk("genid module loaded major %d \n", Major);
+  return 0;
+}
+
+
+/* Cleanup routine */
+static void __exit genid_cleanup(void) 
+{
+  int j = 0;
+  
+  unregister_chrdev(Major, DEVICE_NAME);
+ 
+  printk(" module unloaded.\n");
+}
+
+module_init(genid_init);
+module_exit(genid_cleanup);
diff -Naur kernel-3.3-3.0a-ref/drivers/genid/Kconfig kernel-current/drivers/genid/Kconfig
--- kernel-3.3-3.0a-ref/drivers/genid/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/genid/Kconfig	2013-11-29 10:10:03.179205711 +0100
@@ -0,0 +1,8 @@
+menu "Genid device support"
+     config GENID_DRIVER
+     bool "activate the genid driver for pseudo pid management"
+     default y 
+     help
+     activate the genid driver for pseudo pid management
+
+endmenu
diff -Naur kernel-3.3-3.0a-ref/drivers/genid/Makefile kernel-current/drivers/genid/Makefile
--- kernel-3.3-3.0a-ref/drivers/genid/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/genid/Makefile	2013-11-29 10:10:03.179205711 +0100
@@ -0,0 +1,6 @@
+#
+# Makefile for the GPL Pace GENID driver
+#
+
+
+obj-$(CONFIG_GENID_DRIVER)		+= genid_driver.o
diff -Naur kernel-3.3-3.0a-ref/drivers/Kconfig kernel-current/drivers/Kconfig
--- kernel-3.3-3.0a-ref/drivers/Kconfig	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/Kconfig	2013-11-29 10:10:03.247205115 +0100
@@ -2,6 +2,14 @@
 
 source "drivers/base/Kconfig"
 
+source "drivers/pdi/Kconfig"
+
+source "drivers/genid/Kconfig"
+
+source "drivers/kdev/Kconfig"
+
+source "drivers/kstorman/Kconfig"
+
 source "drivers/connector/Kconfig"
 
 source "drivers/mtd/Kconfig"
@@ -136,4 +144,7 @@
 
 source "drivers/devfreq/Kconfig"
 
+source "drivers/sysinfo/Kconfig"
+
+
 endmenu
diff -Naur kernel-3.3-3.0a-ref/drivers/kdev/Kconfig kernel-current/drivers/kdev/Kconfig
--- kernel-3.3-3.0a-ref/drivers/kdev/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kdev/Kconfig	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1,5 @@
+ config KDEV_DRIVER
+ bool "kdev driver"
+ help
+ activate the kdev driver for devices list
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kdev/kdev.c kernel-current/drivers/kdev/kdev.c
--- kernel-3.3-3.0a-ref/drivers/kdev/kdev.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kdev/kdev.c	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1,109 @@
+/*
+ *  kdev.c
+ *
+ *  This file contains the implementation of the kdev
+ *  core functions.
+ *
+ *  Created by Pace on 05/09/13.
+ *
+ */
+ 
+#include "kdev_priv.h"
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/genhd.h>
+#include <linux/kdev_t.h>
+#include <linux/kernel.h>
+#include <linux/blkdev.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/kmod.h>
+#include <linux/kobj_map.h>
+#include <linux/mutex.h>
+#include <linux/idr.h>
+#include <linux/log2.h>
+#include <linux/sched.h>
+#include <linux/nsproxy.h>
+#include <linux/security.h>
+#include <linux/fs_struct.h>
+#include <linux/device-mapper.h>
+
+/*#define KDEV_CORE_PRINT_DBG*/
+
+extern int chardev_getList(kdev_ioc_getDevices_t* listOfCharDev);
+extern int blkdev_getList(kdev_ioc_getDevices_t* listOfBlkDev);
+
+/***********************************************************************************************
+ *
+ *  static functions
+ *
+ ***********************************************************************************************/
+
+
+/***********************************************************************************************
+ *
+ *  core functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * kdev_core_init
+ */
+int kdev_core_init ( void )
+{
+    return 0;
+}
+
+/*
+ * kdev_core_cleanup
+ */
+void kdev_core_cleanup ( void )
+{
+    return;
+}
+
+
+/*
+ * kdev_core_getDevices
+ */
+int kdev_core_getDevices ( kdev_ioc_getDevices_t *devicesList )
+{
+  int ret = 0;
+  
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  devicesList->devs_nb = 0;
+  
+  /* Collect char devices */
+  ret = chardev_getList(devicesList);
+  if(ret) printk("\t-> ERROR !!! Not able to store all devices. Increase KDEV_DEVLIST_MAXSIZE !!!");
+  
+  ret = blkdev_getList(devicesList);
+  if(ret) printk("\t-> ERROR !!! Not able to store all devices. Increase KDEV_DEVLIST_MAXSIZE !!!");
+
+#ifdef KDEV_CORE_PRINT_DBG
+  {
+    int index;
+    printk("\n----------------------------------------\n");
+    printk("\n Devices list registered in the kernel:\n");
+    printk("\n----------------------------------------\n\n");
+    for(index = 0; index < devicesList->devs_nb; index++)
+    {
+      printk("\t- type: %s   name: %s\tmajor: %03d   min_minor: %03d   max_minor: %03d\n",
+             (devicesList->devs[index].device_type == KDEV_CHAR_DEV) ? "c" : "b",
+             devicesList->devs[index].device_name,
+             devicesList->devs[index].major,
+             devicesList->devs[index].min_minor,
+             devicesList->devs[index].max_minor);
+    }
+    printk("\n\n----------------------------------------\n\n");
+  }
+#endif
+  
+  return ret;
+}
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kdev/kdev_driver.c kernel-current/drivers/kdev/kdev_driver.c
--- kernel-3.3-3.0a-ref/drivers/kdev/kdev_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kdev/kdev_driver.c	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1,307 @@
+/*
+ *  kdev_driver.c
+ *
+ *  This file contains the implementation of the kdev
+ *  interface module with the user space.
+ *
+ *  Created by Pace on 05/09/13.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+
+#include <linux/kdev.h>
+
+#include "kdev_priv.h"
+
+MODULE_AUTHOR ("Pace");
+MODULE_DESCRIPTION ("kdev interface");
+MODULE_SUPPORTED_DEVICE ("");
+MODULE_LICENSE ("GPL");
+
+
+/*
+ *
+ *  Module param
+ *
+ */
+static int kdev_major = 144;
+
+module_param (kdev_major,  int, 0644);
+MODULE_PARM_DESC (kdev_major,  "Device major number");
+
+
+/*
+ *
+ *  Module data
+ *
+ */
+static kdev_info_t kdev_info;
+static char connected_id[KDEV_MAX_CONNECT];
+
+/***********************************************************************************************
+ *
+ *  ioctl functions
+ *
+ ***********************************************************************************************/
+
+/*
+ *
+ *  kdev_getblocks_ioc
+ *
+ */
+int kdev_getDevices_ioc (kdev_ioc_getDevices_t *devicesList)
+{
+  int ret;
+
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+
+  ret = kdev_core_getDevices(devicesList);
+
+  return ret;
+}
+
+
+
+/***********************************************************************************************
+ *
+ *  Char device functions
+ *
+ ***********************************************************************************************/
+
+/*
+ *
+ *  kdev_open
+ *
+ */
+int kdev_open(struct inode *inode, struct file *filp)
+{
+  int i;
+  kdev_data_t *priv_data;
+  
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  logkdev("opened = %i\n", (int) kdev_info.opened);
+  if(!kdev_info.opened) /* If first open */
+  {
+    logkdev("opening kdev\n");
+    
+    kdev_info.opened = 1;
+  }
+
+  if ( kdev_info.connected < KDEV_MAX_CONNECT )
+  {
+    kdev_info.connected++;
+    
+    /* Alloc priv_data */
+    priv_data = (kdev_data_t *) kmalloc(sizeof(kdev_data_t), GFP_ATOMIC);
+    if ( priv_data == NULL )
+    {
+      logkdev("kmalloc error\n");
+      return -ENOMEM;
+    }
+    
+    priv_data->infos = &kdev_info;
+    
+    for (i = 0; i < KDEV_MAX_CONNECT; i++)
+    {
+      if (connected_id[i] == 0)
+      {
+        priv_data->id = i;
+        connected_id[i] = 1;
+        break;
+      }
+    }
+    
+    if (!filp->private_data)
+      filp->private_data = priv_data;
+  }
+  else
+  {
+    logkdev("kdev already opened\n");
+    return -EBUSY;
+  }
+
+  logkdev("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  return 0;   /* success */
+}
+
+
+/*
+ *
+ *  kdev_release
+ *
+ */
+int kdev_release(struct inode *inode, struct file *filp)
+{
+  kdev_data_t *priv_data;
+
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  priv_data = (kdev_data_t *)filp->private_data;
+  
+  connected_id[priv_data->id] = 0;
+  
+  if( kdev_info.connected ) kdev_info.connected--;
+  
+  kfree (priv_data);
+  
+  if (filp->private_data)
+    filp->private_data = NULL;
+  
+  if (!kdev_info.connected)
+    kdev_info.opened = 0;
+  
+  logkdev("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  return 0;
+}
+
+
+/*
+ *
+ *  kdev_ioctl
+ *
+ */
+long kdev_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int err = 0;
+  kdev_data_t *priv_data;
+  
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  priv_data = (kdev_data_t *)filp->private_data;
+  
+  /*
+   *  Check IOC
+   */
+  if (_IOC_TYPE(cmd) != KDEV_IOC_MAGIC) return -ENOTTY;
+  if (_IOC_NR(cmd) > KDEV_IOC_MAXNR) return -ENOTTY;
+  
+  if (_IOC_DIR(cmd) & _IOC_READ)
+    err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+  else if (_IOC_DIR(cmd) & _IOC_WRITE)
+    err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+  if (err) return -EFAULT;
+  
+  switch(cmd)
+  {
+    case KDEV_IOC_GET_ALL_DEVICES:
+      err = kdev_getDevices_ioc (&priv_data->devicesList);
+      if (!err)
+      {
+        copy_to_user( (kdev_ioc_getDevices_t __user *)arg, &priv_data->devicesList, sizeof(kdev_ioc_getDevices_t));
+      }
+      break;
+    default:
+      return -ENOTTY;
+  }
+  
+  logkdev("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  if (err) return -EFAULT;
+  
+  return err;
+}
+
+
+struct file_operations kdev_fops =
+{
+  open:  kdev_open,
+  release: kdev_release,
+  unlocked_ioctl: kdev_ioctl,
+  owner: THIS_MODULE,
+};
+
+
+
+
+/***********************************************************************************************
+ *
+ *  init and exit functions
+ *
+ ***********************************************************************************************/
+
+/*
+ *
+ *  kdev_init
+ *
+ */
+static int __init kdev_init(void)
+{
+  int result;
+  int i;
+  
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  /*
+   *  Register char kdev device
+   */
+  result = register_chrdev(kdev_major, KDEV_NAME, &kdev_fops);
+  if (result < 0)
+  {
+    logkdev(KERN_WARNING "kdev: can't get major %d\n", kdev_major);
+    return result;
+  }
+  
+  if (kdev_major == 0) kdev_major = result; /* dynamic */
+  
+  logkdev("kdev device created with %i major number\n", kdev_major);
+  
+  /*
+   *  Init kdev_info
+   */
+  kdev_info.opened = 0;
+  kdev_info.connected = 0;
+  
+  for (i = 0; i < KDEV_MAX_CONNECT; i++)
+    connected_id[i] = 0;
+  
+  /*
+   *  Init kdev core
+   */
+  if (kdev_core_init ())
+    return ENOMEM;
+  
+  logkdev("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  return 0;
+}
+
+
+/*
+ *
+ *  kdev_cleanup
+ *
+ */
+static void __exit kdev_cleanup(void)
+{
+  logkdev("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+  
+  /*
+   *  Init kdev core
+   */
+  kdev_core_cleanup ();
+  
+  /*
+   *  Uninit kdev_info
+   */
+  
+  
+  /*
+   *  Unregister char kdev device 
+   */
+  unregister_chrdev(kdev_major, KDEV_NAME);
+  
+  logkdev("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+}
+
+module_init(kdev_init);
+module_exit(kdev_cleanup);
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kdev/kdev_priv.h kernel-current/drivers/kdev/kdev_priv.h
--- kernel-3.3-3.0a-ref/drivers/kdev/kdev_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kdev/kdev_priv.h	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1,47 @@
+/*
+ *  kdev_priv.h
+ *
+ *  This file contains the implementation of the storman
+ *  interface module with the user space.
+ *
+ *  Created by Pace on 05/09/13.
+ *
+ */
+
+#ifndef KDEV_PRIV_H
+#define KDEV_PRIV_H
+
+#include <linux/kdev.h>
+
+/*#define KDEVDEBUG*/
+
+#ifdef KDEVDEBUG
+#define logkdev(...) \
+    printk("[KDEV] "__VA_ARGS__);
+#else
+#define logkdev(...)
+#endif
+
+#define KDEV_NAME "kdev"
+
+#define KDEV_MAX_CONNECT 10
+
+typedef struct
+{
+	char opened;
+	char connected;
+} kdev_info_t;
+
+typedef struct
+{
+    int id;
+    kdev_ioc_getDevices_t devicesList;
+    kdev_info_t* infos;
+} kdev_data_t;
+
+int kdev_core_init ( void );
+void kdev_core_cleanup ( void );
+int kdev_core_getDevices ( kdev_ioc_getDevices_t *devicesList );
+
+
+#endif /* KDEV_PRIV_H */
diff -Naur kernel-3.3-3.0a-ref/drivers/kdev/Makefile kernel-current/drivers/kdev/Makefile
--- kernel-3.3-3.0a-ref/drivers/kdev/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kdev/Makefile	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_KDEV_DRIVER)		+= kdev.o kdev_driver.o
diff -Naur kernel-3.3-3.0a-ref/drivers/kstorman/Kconfig kernel-current/drivers/kstorman/Kconfig
--- kernel-3.3-3.0a-ref/drivers/kstorman/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kstorman/Kconfig	2013-11-29 10:10:03.211205431 +0100
@@ -0,0 +1,6 @@
+ config KSTORMAN_DRIVER
+ bool "kstorman driver"
+     depends on BLK_DEV_DM
+ help
+ activate the kstorman driver for device infos
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kstorman/kstorman.c kernel-current/drivers/kstorman/kstorman.c
--- kernel-3.3-3.0a-ref/drivers/kstorman/kstorman.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kstorman/kstorman.c	2013-11-29 10:10:03.211205431 +0100
@@ -0,0 +1,345 @@
+/*
+ *  kstorman.c
+ *
+ *  This file contains the implementation of the storman 
+ *  core functions.
+ *
+ *  Created by Pace on 19/07/13.
+ *
+ */
+ 
+#include "kstorman_priv.h"
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/genhd.h>
+#include <linux/kdev_t.h>
+#include <linux/kernel.h>
+#include <linux/blkdev.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/kmod.h>
+#include <linux/kobj_map.h>
+#include <linux/mutex.h>
+#include <linux/idr.h>
+#include <linux/log2.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mount.h>
+#include <linux/mnt_namespace.h>
+#include <linux/sched.h>
+#include <linux/nsproxy.h>
+#include <linux/security.h>
+#include <linux/fs_struct.h>
+#include <linux/device-mapper.h>
+#include "../../fs/mount.h"
+
+/*#define KSTORMAN_CORE_PRINT_DBG*/
+
+/***********************************************************************************************
+ *
+ *  static functions
+ *
+ ***********************************************************************************************/
+ 
+/*
+ * Copied from fs/namespace.c
+ */
+static struct mount *next_mnt(struct mount *p, struct mount *root)
+{
+	struct list_head *next = p->mnt_mounts.next;
+	if (next == &p->mnt_mounts) {
+		while (1) {
+			if (p == root)
+				return NULL;
+			next = p->mnt_child.next;
+			if (next != &p->mnt_parent->mnt_mounts)
+				break;
+			p = p->mnt_parent;
+		}
+	}
+	return list_entry(next, struct mount, mnt_child);
+}
+
+
+static int set_mount_infos ( kstorman_ioc_getmounts_t *mountlist, struct mount *s )
+{
+    struct path mnt_path = { .dentry = s->mnt.mnt_root, .mnt = &s->mnt };
+    char *pathname;
+    char *tmp;
+    
+    if ((mountlist->mounts_nb + 1) == KSTORMAN_MOUNTLIST_MAXSIZE)
+        return 1;
+    
+    tmp = (char *)__get_free_page(GFP_TEMPORARY);
+
+    if (!tmp) {
+        return -ENOMEM;
+    }
+
+    pathname = d_path(&mnt_path, tmp, PAGE_SIZE);
+
+    if (IS_ERR(pathname)) {
+        free_page((unsigned long)tmp);
+        return PTR_ERR(pathname);
+    }
+
+    /* 
+     * fill mount list
+     */
+    strncpy (mountlist->mounts[mountlist->mounts_nb].device, s->mnt_devname, KSTORMAN_STR_MAXSIZE);
+    strncpy (mountlist->mounts[mountlist->mounts_nb].dir, pathname, KSTORMAN_STR_MAXSIZE);
+    strncpy (mountlist->mounts[mountlist->mounts_nb].type, s->mnt.mnt_sb->s_type->name, KSTORMAN_STR_MAXSIZE);
+    mountlist->mounts[mountlist->mounts_nb].flags = s->mnt.mnt_flags;
+    
+    
+    /* 
+     * Print for debug
+     */
+#ifdef KSTORMAN_CORE_PRINT_DBG
+    printk ("%s on %s", mountlist->mounts[mountlist->mounts_nb].device, mountlist->mounts[mountlist->mounts_nb].dir);
+    
+    printk (" type %s", mountlist->mounts[mountlist->mounts_nb].type);
+    
+    printk (mountlist->mounts[mountlist->mounts_nb].flags & MNT_READONLY ? " (ro" : " (rw");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_NOSUID) printk (",nosuid");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_NODEV) printk (",nodev");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_NOEXEC) printk (",noexec");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_NOATIME) printk (",noatime");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_NODIRATIME) printk (",nodiratime");
+    if (mountlist->mounts[mountlist->mounts_nb].flags & MNT_RELATIME) printk (",relatime");
+
+    printk (")\n");
+#endif
+
+    free_page((unsigned long)tmp);
+    
+    mountlist->mounts_nb++;
+    
+    return 0;
+}
+
+
+static int set_block_infos ( kstorman_ioc_getblocks_t *blocklist, struct gendisk *disk )
+{
+    struct mapped_device *mp;    
+    
+    if ((blocklist->blkdevs_nb + 1) == KSTORMAN_BLKDEVLIST_MAXSIZE)
+        return 1;
+
+    strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].name, disk->disk_name, KSTORMAN_STR_MAXSIZE);
+    blocklist->blkdevs[blocklist->blkdevs_nb].major = disk->major;
+    blocklist->blkdevs[blocklist->blkdevs_nb].minor = disk->first_minor;
+    if (disk->driverfs_dev != NULL && disk->driverfs_dev->type != NULL)
+    {
+        strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].type, disk->driverfs_dev->type->name, KSTORMAN_STR_MAXSIZE);
+    }
+    else
+    {
+        strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].type, "unknown", KSTORMAN_STR_MAXSIZE);
+    }
+    
+    if ( !strncmp (blocklist->blkdevs[blocklist->blkdevs_nb].type, "scsi_device", KSTORMAN_STR_MAXSIZE))
+    {
+        if (disk->driverfs_dev != NULL && 
+            disk->driverfs_dev->parent != NULL && 
+            disk->driverfs_dev->parent->parent != NULL && 
+            disk->driverfs_dev->parent->parent->parent != NULL && 
+            disk->driverfs_dev->parent->parent->parent->type != NULL)
+        {
+            strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].parent_type, disk->driverfs_dev->parent->parent->parent->type->name, KSTORMAN_STR_MAXSIZE);
+        }
+        else
+        {
+            strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].parent_type, "unknown", KSTORMAN_STR_MAXSIZE);
+        }
+    }
+    else if ( !strncmp (blocklist->blkdevs[blocklist->blkdevs_nb].type, "mtd", KSTORMAN_STR_MAXSIZE))
+    {
+        strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].parent_type, "mtd", KSTORMAN_STR_MAXSIZE);
+    }
+    else
+    {
+        mp = dm_get_md(disk_to_dev(disk)->devt);
+        
+        if (mp)
+        {
+            strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].type, "dev-mapper", KSTORMAN_STR_MAXSIZE);
+            strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].parent_type, "dev-mapper", KSTORMAN_STR_MAXSIZE);
+        }
+        else
+        {
+            strncpy (blocklist->blkdevs[blocklist->blkdevs_nb].parent_type, "unknown", KSTORMAN_STR_MAXSIZE);
+        }
+    }
+    
+    
+    /* 
+     * Print for debug
+     */
+#ifdef KSTORMAN_CORE_PRINT_DBG
+	printk ("disk_name=%s\n", blocklist->blkdevs[blocklist->blkdevs_nb].name);
+	printk ("major=%i\n", blocklist->blkdevs[blocklist->blkdevs_nb].major);
+	printk ("first minor=%i\n", blocklist->blkdevs[blocklist->blkdevs_nb].minor);
+	printk ("type=%s\n", blocklist->blkdevs[blocklist->blkdevs_nb].type);
+	printk ("parent type=%s\n", blocklist->blkdevs[blocklist->blkdevs_nb].parent_type);
+#endif
+    
+    blocklist->blkdevs_nb++;
+    
+    return 0;
+}
+
+/***********************************************************************************************
+ *
+ *  core functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * kstorman_core_init
+ */
+int kstorman_core_init ( void )
+{		
+    return 0;
+}
+
+/*
+ * kstorman_core_cleanup
+ */
+void kstorman_core_cleanup ( void )
+{
+    return;
+}
+
+/*
+ * kstorman_core_getmounts
+ */
+int kstorman_core_getmounts ( kstorman_ioc_getmounts_t *mountlist )
+{
+	struct nsproxy *nsproxy;
+	struct mnt_namespace *namespace;
+	struct mount *r = NULL;
+	int ret = 0;
+	    
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	mountlist->mounts_nb = 0;
+	
+    
+    nsproxy = task_nsproxy(current);
+    if (nsproxy != NULL) {
+
+        namespace = nsproxy->mnt_ns;
+
+        if ((ret = set_mount_infos (mountlist, namespace->root)))
+        {
+            
+            return ret;
+        }
+
+        list_for_each_entry(r, &namespace->root->mnt_mounts, mnt_child)
+        {
+            struct mount *s;
+
+		    for (s = r; s; s = next_mnt(s, r)) {
+                if (s != NULL)
+                {
+                    if ((ret = set_mount_infos (mountlist, s)))
+                    {
+                        
+                        return ret;
+                    }
+                }
+		    }
+        }
+        
+    }
+    else
+        ret = 1;
+
+    
+    
+    return ret;
+}
+
+/*
+ * kstorman_core_getblocks
+ */
+int kstorman_core_getblocks ( kstorman_ioc_getblocks_t *blocklist )
+{
+	struct class_dev_iter iter;
+	struct device *dev;
+	int ret = 0;
+	
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	blocklist->blkdevs_nb = 0;
+	
+	class_dev_iter_init(&iter, &block_class, NULL, NULL);
+	while ((dev = class_dev_iter_next(&iter))) {
+		
+		struct gendisk *disk;
+		
+		if (strcmp(dev->type->name, "disk"))
+		    continue;
+		    
+        disk = dev_to_disk(dev);
+
+		if (get_capacity(disk) == 0 ||
+		    (disk->flags & GENHD_FL_SUPPRESS_PARTITION_INFO))
+			continue;
+			
+		if ( (ret = set_block_infos ( blocklist, disk ))) break;
+
+	}
+	class_dev_iter_exit(&iter);
+	
+    return ret;
+}
+
+
+/*
+ * kstorman_core_getmmtd
+ */
+int kstorman_core_getmtd ( kstorman_ioc_getmtd_t *mtdlist )
+{
+    struct mtd_info *mtd_info = NULL;
+    int num;
+    
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	mtdlist->mtd_nb = 0;
+    
+    for(num = 0; num < 64; num++) {
+        if ((mtdlist->mtd_nb + 1) == KSTORMAN_MTDLIST_MAXSIZE)
+            return 1;
+    
+        mtd_info = get_mtd_device(NULL, num);
+        if(IS_ERR(mtd_info)) {
+            continue;
+        }
+        
+        strncpy (mtdlist->mtd[mtdlist->mtd_nb].name, mtd_info->name, KSTORMAN_STR_MAXSIZE);
+        mtdlist->mtd[mtdlist->mtd_nb].index = mtd_info->index;
+        mtdlist->mtd[mtdlist->mtd_nb].type = mtd_info->type;
+
+        /* 
+         * Print for debug
+         */
+#ifdef KSTORMAN_CORE_PRINT_DBG
+        printk("MTD name: %s\n", mtdlist->mtd[mtdlist->mtd_nb].name);
+        printk("MTD index: mtd%i\n", mtdlist->mtd[mtdlist->mtd_nb].index);
+        printk("MTD type: %u\n", mtdlist->mtd[mtdlist->mtd_nb].type);
+#endif
+        
+        mtdlist->mtd_nb++;
+    }
+    
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+    return 0;
+}
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kstorman/kstorman_driver.c kernel-current/drivers/kstorman/kstorman_driver.c
--- kernel-3.3-3.0a-ref/drivers/kstorman/kstorman_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kstorman/kstorman_driver.c	2013-11-29 10:10:03.211205431 +0100
@@ -0,0 +1,359 @@
+/*
+ *  kstorman_driver.c
+ *
+ *  This file contains the implementation of the storman 
+ *  interface module with the user space.  
+ *
+ *  Created by Pace on 19/07/13.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+
+#include <linux/kstorman.h>
+
+#include "kstorman_priv.h"
+
+MODULE_AUTHOR ("Pace");
+MODULE_DESCRIPTION ("kstorman interface");
+MODULE_SUPPORTED_DEVICE ("");
+MODULE_LICENSE ("GPL");
+
+
+/*
+ * 
+ *  Module param
+ *
+ */
+static int kstorman_major = 0;
+
+module_param (kstorman_major,  int, 0644);
+MODULE_PARM_DESC (kstorman_major,  "Device major number");
+
+
+/*
+ * 
+ *  Module data
+ *
+ */
+static kstorman_info_t kstorman_info;
+char connected_id[KSTORMAN_MAX_CONNECT];
+
+/***********************************************************************************************
+ *
+ *  ioctl functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  kstorman_getmounts_ioc
+ *
+ */
+int kstorman_getmounts_ioc (kstorman_ioc_getmounts_t *mountlist)
+{
+	int ret;
+
+    logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+
+	ret = kstorman_core_getmounts (mountlist);
+
+	return ret;
+}
+
+
+/*
+ * 
+ *  kstorman_getblocks_ioc
+ *
+ */
+int kstorman_getblocks_ioc (kstorman_ioc_getblocks_t *blocklist)
+{
+	int ret;
+
+    logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+
+	ret = kstorman_core_getblocks (blocklist);
+
+	return ret;
+}
+
+/*
+ * 
+ *  kstorman_getmtd_ioc
+ *
+ */
+int kstorman_getmtd_ioc (kstorman_ioc_getmtd_t *mtdlist)
+{
+	int ret;
+
+    logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+
+	ret = kstorman_core_getmtd(mtdlist);
+
+	return ret;
+}
+
+
+
+
+/***********************************************************************************************
+ *
+ *  Char device functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  kstorman_open
+ *
+ */
+int kstorman_open(struct inode *inode, struct file *filp)
+{
+    int i;
+    
+    kstorman_data_t *priv_data;
+    
+    logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	logkstorman("opened = %i\n", (int) kstorman_info.opened);
+
+	if(!kstorman_info.opened) /* If first open */
+	{
+		logkstorman("opening kstorman\n");
+
+		kstorman_info.opened = 1;
+	}
+
+	if ( kstorman_info.connected < KSTORMAN_MAX_CONNECT )
+	{
+		kstorman_info.connected++;
+		
+		/* Alloc priv_data */
+		priv_data = (kstorman_data_t *) kmalloc(sizeof(kstorman_data_t), GFP_ATOMIC);
+	    if ( priv_data == NULL )
+	    {
+		    logkstorman("kmalloc error\n");
+		    return -ENOMEM;
+	    }
+	    
+	    priv_data->infos = &kstorman_info;
+		
+		for (i = 0; i < KSTORMAN_MAX_CONNECT; i++)
+		{
+	        if (connected_id[i] == 0)
+	        {
+	            priv_data->id = i;
+	            connected_id[i] = 1;
+	            break;
+            }
+        }
+        
+		if (!filp->private_data)
+    		filp->private_data = priv_data;
+	}
+	else
+	{
+		logkstorman("kstorman already opened\n");
+		return -EBUSY;
+	}
+
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	return 0;   /* success */
+}
+
+
+/*
+ * 
+ *  kstorman_release
+ *
+ */
+int kstorman_release(struct inode *inode, struct file *filp)
+{
+    kstorman_data_t *priv_data;
+
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	priv_data = (kstorman_data_t *)filp->private_data;
+	
+	connected_id[priv_data->id] = 0;
+
+	if( kstorman_info.connected ) kstorman_info.connected--;
+	
+	kfree (priv_data);
+	
+	if (filp->private_data)
+	    filp->private_data = NULL;
+	    
+    if (!kstorman_info.connected)
+        kstorman_info.opened = 0;
+
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	return 0;
+}
+
+
+/*
+ * 
+ *  kstorman_ioctl
+ *
+ */
+long kstorman_ioctl (struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+
+    kstorman_data_t *priv_data;
+
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	priv_data = (kstorman_data_t *)filp->private_data;
+
+	/*
+	 *  Check IOC
+	 */
+	if (_IOC_TYPE(cmd) != KSTORMAN_IOC_MAGIC) return -ENOTTY;
+	if (_IOC_NR(cmd) > KSTORMAN_IOC_MAXNR) return -ENOTTY;
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	if (err) return -EFAULT;
+
+	switch(cmd)
+	{
+		case KSTORMAN_IOC_GETMOUNTS:
+			err = kstorman_getmounts_ioc (&priv_data->mountlist);
+			
+			if (!err)
+			{
+			    copy_to_user( (kstorman_ioc_getmounts_t __user *)arg, &priv_data->mountlist, sizeof(kstorman_ioc_getmounts_t));
+			}
+    		break;
+		case KSTORMAN_IOC_GETBLOCKS:
+			err = kstorman_getblocks_ioc (&priv_data->blocklist);
+			
+			if (!err)
+			{
+			    copy_to_user( (kstorman_ioc_getblocks_t __user *)arg, &priv_data->blocklist, sizeof(kstorman_ioc_getblocks_t));
+			}
+    		break;
+		case KSTORMAN_IOC_GETMTD:
+			err = kstorman_getmtd_ioc (&priv_data->mtdlist);
+			
+			if (!err)
+			{
+			    copy_to_user( (kstorman_ioc_getmtd_t __user *)arg, &priv_data->mtdlist, sizeof(kstorman_ioc_getmtd_t));
+			}
+    		break;
+		default:
+			return -ENOTTY;
+	}
+	
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	if (err) return -EFAULT;
+
+	return err;
+}
+
+struct file_operations kstorman_fops = {
+	open:  kstorman_open,
+	release: kstorman_release,
+	unlocked_ioctl: kstorman_ioctl,
+	owner: THIS_MODULE,
+};
+
+
+
+
+/***********************************************************************************************
+ *
+ *  init and exit functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  kstorman_init
+ *
+ */
+static int __init kstorman_init(void)
+{
+	int result;
+	int i;
+
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	/*
+	 *  Register char kstorman device 
+	 */
+	result = register_chrdev(kstorman_major, KSTORMAN_NAME, &kstorman_fops);
+	if (result < 0) 
+	{
+		logkstorman(KERN_WARNING "kstorman: can't get major %d\n",kstorman_major);
+		return result;
+	}
+
+	if (kstorman_major == 0) kstorman_major = result; /* dynamic */
+
+	logkstorman("kstorman device created with %i major number\n", kstorman_major);
+
+	/*
+	 *  Init kstorman_info
+	 */
+	kstorman_info.opened = 0;
+	kstorman_info.connected = 0;
+	
+	for (i = 0; i < KSTORMAN_MAX_CONNECT; i++)
+	    connected_id[i] = 0;
+	    
+	/*
+	 *  Init kstorman core
+	 */
+    if (kstorman_core_init ())
+        return ENOMEM;
+
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+
+	return 0;
+}
+
+
+/*
+ * 
+ *  kstorman_cleanup
+ *
+ */
+static void __exit kstorman_cleanup(void)
+{
+	logkstorman("enter %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+	
+	/*
+	 *  Init kstorman core
+	 */
+	 kstorman_core_cleanup ();
+
+	/*
+	 *  Uninit kstorman_info
+	 */
+
+
+	/*
+	 *  Unregister char kstorman device 
+	 */
+	unregister_chrdev(kstorman_major, KSTORMAN_NAME);
+
+	logkstorman("exit %s  [%s:%d]\n", __FUNCTION__, __FILE__, __LINE__);
+}
+
+module_init(kstorman_init);
+module_exit(kstorman_cleanup);
+
diff -Naur kernel-3.3-3.0a-ref/drivers/kstorman/kstorman_priv.h kernel-current/drivers/kstorman/kstorman_priv.h
--- kernel-3.3-3.0a-ref/drivers/kstorman/kstorman_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kstorman/kstorman_priv.h	2013-11-29 10:10:03.211205431 +0100
@@ -0,0 +1,51 @@
+/*
+ *  kstorman_priv.h
+ *
+ *  This file contains the implementation of the storman 
+ *  interface module with the user space.  
+ *
+ *  Created by Pace on 19/07/13.
+ *
+ */
+
+#ifndef KSTORMAN_PRIV_H
+#define KSTORMAN_PRIV_H
+
+#include <linux/kstorman.h>
+
+/*#define KSTORMANDEBUG*/
+
+#ifdef KSTORMANDEBUG
+#define logkstorman(...) \
+		printk("[KSTORMAN] "__VA_ARGS__);
+#else
+#define logkstorman(...)
+#endif
+
+#define KSTORMAN_NAME "kstorman"
+
+#define KSTORMAN_MAX_CONNECT 10
+
+typedef struct
+{
+	char opened;
+	char connected;
+} kstorman_info_t;
+
+typedef struct
+{
+    int id;
+    kstorman_ioc_getmounts_t mountlist;
+    kstorman_ioc_getblocks_t blocklist;
+    kstorman_ioc_getmtd_t mtdlist;
+    kstorman_info_t* infos;
+} kstorman_data_t;
+
+int kstorman_core_init ( void );
+void kstorman_core_cleanup ( void );
+int kstorman_core_getmounts ( kstorman_ioc_getmounts_t *mountlist );
+int kstorman_core_getblocks ( kstorman_ioc_getblocks_t *blocklist );
+int kstorman_core_getmtd ( kstorman_ioc_getmtd_t *mtdlist );
+
+
+#endif /* KSTORMAN_PRIV_H */
diff -Naur kernel-3.3-3.0a-ref/drivers/kstorman/Makefile kernel-current/drivers/kstorman/Makefile
--- kernel-3.3-3.0a-ref/drivers/kstorman/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/kstorman/Makefile	2013-11-29 10:10:03.211205431 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_KSTORMAN_DRIVER)		+= kstorman.o kstorman_driver.o
diff -Naur kernel-3.3-3.0a-ref/drivers/Makefile kernel-current/drivers/Makefile
--- kernel-3.3-3.0a-ref/drivers/Makefile	2013-08-28 01:30:58.000000000 +0200
+++ kernel-current/drivers/Makefile	2013-11-29 10:10:03.247205115 +0100
@@ -9,6 +9,10 @@
 # GPIO must come after pinctrl as gpios may need to mux pins etc
 obj-y				+= pinctrl/
 obj-y				+= gpio/
+obj-$(CONFIG_PDI_DRIVER)	+= pdi/
++obj-$(CONFIG_GENID_DRIVER)	+= genid/
+obj-$(CONFIG_KDEV_DRIVER)	+= kdev/
+obj-$(CONFIG_KSTORMAN_DRIVER)	+= kstorman/
 obj-$(CONFIG_PCI)		+= pci/
 obj-$(CONFIG_PARISC)		+= parisc/
 obj-$(CONFIG_RAPIDIO)		+= rapidio/
@@ -127,6 +131,7 @@
 obj-$(CONFIG_HWSPINLOCK)	+= hwspinlock/
 obj-$(CONFIG_NFC)		+= nfc/
 obj-$(CONFIG_IOMMU_SUPPORT)	+= iommu/
+obj-$(CONFIG_SYSINFO_SUPPORT)				+= sysinfo/
 
 # Virtualization drivers
 obj-$(CONFIG_VIRT_DRIVERS)	+= virt/
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/devices/m25p80.c kernel-current/drivers/mtd/devices/m25p80.c
--- kernel-3.3-3.0a-ref/drivers/mtd/devices/m25p80.c	2013-08-28 01:30:59.000000000 +0200
+++ kernel-current/drivers/mtd/devices/m25p80.c	2013-11-29 10:10:03.159205887 +0100
@@ -644,6 +644,10 @@
 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
 
+	/* Pace change start */
+	{ "MX25L3255D",  INFO(0xc29e16, 0, 64 * 1024,  64, 0) },
+	/* Pace change end */
+
 	/* Macronix */
 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
 	{ "mx25l8005",   INFO(0xc22014, 0, 64 * 1024,  16, 0) },
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/Kconfig kernel-current/drivers/mtd/Kconfig
--- kernel-3.3-3.0a-ref/drivers/mtd/Kconfig	2013-08-28 01:30:59.000000000 +0200
+++ kernel-current/drivers/mtd/Kconfig	2013-11-29 10:10:03.159205887 +0100
@@ -322,6 +322,8 @@
 
 source "drivers/mtd/nand/Kconfig"
 
+source "drivers/mtd/pacenand/Kconfig"
+
 source "drivers/mtd/onenand/Kconfig"
 
 source "drivers/mtd/lpddr/Kconfig"
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/Makefile kernel-current/drivers/mtd/Makefile
--- kernel-3.3-3.0a-ref/drivers/mtd/Makefile	2013-08-28 01:30:59.000000000 +0200
+++ kernel-current/drivers/mtd/Makefile	2013-11-29 10:10:03.163205852 +0100
@@ -33,3 +33,5 @@
 obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
 
 obj-$(CONFIG_MTD_UBI)		+= ubi/
+
+obj-$(CONFIG_MTD_PACENAND)		+= pacenand/
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/maps/physmap.c kernel-current/drivers/mtd/maps/physmap.c
--- kernel-3.3-3.0a-ref/drivers/mtd/maps/physmap.c	2013-08-28 01:30:59.000000000 +0200
+++ kernel-current/drivers/mtd/maps/physmap.c	2013-11-29 10:10:03.167205818 +0100
@@ -79,6 +79,11 @@
 					NULL };
 static const char *part_probe_types[] = { "cmdlinepart", "RedBoot", "afs",
 					  NULL };
+					  
+#ifdef CONFIG_PDI_DRIVER
+//PACE PATCH
+extern int pdi_add_device (char *name, int type, int id);
+#endif
 
 static int physmap_flash_probe(struct platform_device *dev)
 {
@@ -89,6 +94,11 @@
 	int err = 0;
 	int i;
 	int devices_found = 0;
+	
+#ifdef CONFIG_PDI_DRIVER
+ 	//PACE PATCH
+	const struct mtd_partition *pdi_part;
+#endif
 
 	physmap_data = dev->dev.platform_data;
 	if (physmap_data == NULL)
@@ -173,6 +183,15 @@
 		goto err_out;
 
 	part_types = physmap_data->part_probe_types ? : part_probe_types;
+	
+#ifdef CONFIG_PDI_DRIVER
+    //PACE PATCH
+    for (i = 0; i < physmap_data->nr_parts; i++)
+    {
+        pdi_part=physmap_data->parts + i;
+        pdi_add_device (pdi_part->name, 2, i);
+    }
+#endif
 
 	mtd_device_parse_register(info->cmtd, part_types, 0,
 				  physmap_data->parts, physmap_data->nr_parts);
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/mtdcore.c kernel-current/drivers/mtd/mtdcore.c
--- kernel-3.3-3.0a-ref/drivers/mtd/mtdcore.c	2013-08-28 01:30:59.000000000 +0200
+++ kernel-current/drivers/mtd/mtdcore.c	2013-11-29 10:10:03.167205818 +0100
@@ -278,6 +278,10 @@
 	.release	= mtd_release,
 };
 
+#if defined CONFIG_PDI_DRIVER
+extern int pdi_update_devices_list (char* name, char *device, int connected );
+#endif
+
 /**
  *	add_mtd_device - register an MTD device
  *	@mtd: pointer to new MTD device info structure
@@ -366,6 +370,9 @@
 	list_for_each_entry(not, &mtd_notifiers, list)
 		not->add(mtd);
 
+#if defined (CONFIG_PDI_DRIVER)
+	pdi_update_devices_list ((char *)mtd->name, (char *)mtd->name, 1);
+#endif
 	mutex_unlock(&mtd_table_mutex);
 	/* We _know_ we aren't being removed, because
 	   our caller is still holding us here. So none
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/pacenand/Kconfig kernel-current/drivers/mtd/pacenand/Kconfig
--- kernel-3.3-3.0a-ref/drivers/mtd/pacenand/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/mtd/pacenand/Kconfig	2013-11-29 10:10:03.159205887 +0100
@@ -0,0 +1,87 @@
+#
+# linux/drivers/mtd/pacenand/Kconfig
+#
+
+config MTD_PACENAND
+        tristate "Pace NAND device support using Broadcom NAND controller"
+        default n
+        depends on MTD && MTD_BRCMNAND = n
+        select BRCM_SKIP_CHECK_BOOTROM
+        select LONG_LONG_SUPPORT
+        ---help---
+          This enables support for accessing selected types of NAND flash
+          devices through the Broadcom NAND controller using the Pace driver
+
+config MTD_PACENAND_VERIFY_WRITE
+        bool "Verify Pace NAND page writes"
+        default y
+        depends on MTD_PACENAND
+        ---help---
+          This adds an extra check when data is written to the flash. The
+          Broadcom NAND flash device internally checks only bits transitioning
+          from 1 to 0. There is a rare possibility that even though the
+          device thinks the write was successful, a bit could have been
+          flipped accidentaly due to device wear or something else.
+
+config PACE_NAND_FORCE_2K_PAGEWRITES
+        bool "Set virtual page size to be same size as native page size"
+        default n
+        depends on MTD_PACENAND
+        ---help---
+                If enabled this will allow the driver to use native page sizes rather than virtual  
+
+config PACE_NAND_FIX_BROKEN_BCM_AUTODETECT
+        bool "Fix Autodetect for old NAND devices"
+        default n
+        depends on MTD_PACENAND
+        ---help---
+          Fixes an issue with older chips not being autodetected by the BCM NAND 
+          controller, this option must not be used for 4/8/12 bit ECC devices
+
+config READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE
+        bool "Read nand layout from stored cookie"
+        default n
+        depends on MTD_PACENAND
+        ---help---
+          Reads the NAND ECC type/Layout from a cookie stored in the NAND 
+          controller registers (only for NOR+NAND configs), note that you
+          will need a version of CFE/BOOTLOADER which sets the cookie,
+          currently this is only used by the Sky Italia 5000
+
+config FORCE_ECC_SPARE_AREA_LAYOUT_FLAG
+        bool "Force ECC type and NAND layout"
+        default n
+        depends on MTD_PACENAND
+        ---help---
+          Forces the NAND ECC type (Hamming or BCH) and 
+          Layout (16/27 or 32 byte spare area)
+
+config FORCE_ECC_SPARE_AREA_LAYOUT
+       depends on FORCE_ECC_SPARE_AREA_LAYOUT_FLAG
+       int "Selects ECC type and NAND layout"
+       range 0 5
+       ---help---
+         0 is Hamming with 16 byte spare area
+         1 is BCH4 with 16 byte spare area
+         2 is BCH8 with 27 byte spare area
+         3 is BCH8 with 32 byte spare area
+         4 is BCH12 with 27 byte spare area (JFFS2 not supported)
+         5 is BCH12 with 32 buye spare area
+
+config MTD_PACENAND_DEBUG
+   bool "Turn on Pace NAND driver debug"
+   default n
+   depends on MTD_PACENAND
+   ---help---
+      Turn this flag on to enable extra debug output from the Pace NAND driver.
+
+config MTD_PACENAND_CLEAR_BAD_BLOCK_MARKERS
+   bool "Automatically erase blocks and clear the markers for bad blocks"
+   default n
+   depends on MTD_PACENAND
+   ---help---
+      Turn this flag on to automatically erase blocks that are bad, and 
+      clear their bad block markers.
+      
+      This option has been added so that the NAND can be initialised.
+      Do not leave this option enabled!
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/pacenand/Makefile kernel-current/drivers/mtd/pacenand/Makefile
--- kernel-3.3-3.0a-ref/drivers/mtd/pacenand/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/mtd/pacenand/Makefile	2013-11-29 10:10:03.163205852 +0100
@@ -0,0 +1,7 @@
+#
+# Makefile for the Pace NAND MTD
+#
+#-include include/config/auto.conf
+
+obj-$(CONFIG_MTD_PACENAND)		+=  pacenand.o
+pacenand-objs = pacenand_base.o nand_dev_new_73xx.o
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/pacenand/nand_dev_new_73xx.c kernel-current/drivers/mtd/pacenand/nand_dev_new_73xx.c
--- kernel-3.3-3.0a-ref/drivers/mtd/pacenand/nand_dev_new_73xx.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/mtd/pacenand/nand_dev_new_73xx.c	2013-11-29 10:10:03.163205852 +0100
@@ -0,0 +1,4159 @@
+/****************************************************************************
+ *                                                                          *
+ * File        : nand_dev_new.c                                             *
+ *                                                                          *
+ * Description : Low level read/write functions for NAND flash using the    *
+ *               NEW Broadcom NAND flash controller                         *
+ *                                                                          *
+ * Author      : Neil Crossley (crossln1)                                   *
+ *                                                                          *
+ * Copyright   : Pace Micro Technology 2007 (c)                             *
+ *                                                                          *
+ *               The copyright in this material is owned by                 *
+ *               Pace Microtechnology PLC ("Pace"). This                    *
+ *               material is regarded as a highly confidential              *
+ *               trade secret of Pace. It may not be reproduced,            *
+ *               used, sold or in any other way exploited or                *
+ *               transferred to any third party without the prior           *
+ *               written permission of Pace.                                *
+ *                                                                          *
+ * Notes       : Thanks to Simon Hemming for the previous driver (and also  *
+ *               figuring out how the hardware works) as well as John Smith *
+ *               for additional help                                        *
+ *                                                                          *
+ * History     : Initial Version                                            *
+ *                                                                          *
+ ****************************************************************************/
+
+/* Notes ...
+
+   - Delay timing calculations ...
+
+     Any reads of the NAND controller registers lock the CPU to approx 100Mhz
+     so to delay for one second we simply read the status register 100 million
+     times. Note that due to the overhead of the loop logic this will actually
+     wait for slightly longer (though this should not cause any problems).
+
+   - OS Dependance ...
+
+     This module does not rely on any paticular operating system.
+
+   - Object file size ...
+
+     Currently the stripped version of the .o file this produces is approx 10K
+     If anyone needs a smaller version then please let me know (though the code
+     may not be as readable afterwards!)
+
+   - Broadcom Controller Specific ...
+
+     The controller always writes the ECC data for the block using the offsets
+     defined in the 'small page' spare area format even for devices with large
+     pages.  Also the controller does NOT calc the ECC data for the 'logical
+     sector number' bytes.
+
+     There is now an option to calculate/check an additional CRC32 in addition
+     to the controllers ECC checks, this is guaranteed to spot uncorrectable
+     errors correctly however this decreases the reading speed significantly
+     (especially if you build this driver with no optimizations!)
+
+   - Changes for Multibit ECC
+
+     We no longer support small page devices (in fact we only support
+     devices with a 2K page size for now)
+
+   - Style notes
+
+     Can whoever keeps removing the padding lines after comments PLEASE STOP
+     DOING THIS, it makes things less readable (and before anyone mentions
+     things fitting in an 80x25 terminal window in VI then please dont, it's
+     2013 for heavens sake!)
+*/
+
+
+/****************************************************************************/
+
+
+/************
+ * Includes *
+ ************/
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <stdbool.h>
+#include <linux/mtd/pacenand.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#include <generated/autoconf.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
+#if defined(LINUX) || defined(__linux__)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+#include "linux/brcmstb/brcmstb.h"
+#else
+#include "asm/brcmstb/brcmstb.h"
+#endif
+#else
+#include "bchp_nand.h"
+#include "bchp_ebi.h"
+#endif
+
+#if defined(CONFIG_PACE_SYSTEM_IS_NAND_ONLY)
+#define SYSTEM_IS_NAND_ONLY
+#endif
+
+#if defined(CONFIG_PACE_NAND_FIX_BROKEN_BCM_AUTODETECT)
+#define FIX_BROKEN_BCM_NAND_AUTODETECT
+#endif
+
+#if defined(CONFIG_PACE_NAND_FORCE_2K_PAGEWRITES)
+#define FORCE_2K_PAGEWRITES
+#endif
+
+#if defined(CONFIG_FORCE_ECC_SPARE_AREA_LAYOUT)
+#define FORCE_ECC_SPARE_AREA_LAYOUT CONFIG_FORCE_ECC_SPARE_AREA_LAYOUT
+#endif
+
+#if defined(CONFIG_READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE)
+#define READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE CONFIG_READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE
+#endif
+
+/* RT091111 disable this as there are problems with it */
+
+#define ASM_SPEEDUP 0
+
+/* Sort out the stupid new chip select nonsense on later controllers
+   New NAND controller has different registers for CS0 and CS1 */
+
+#ifdef BCHP_NAND_ACC_CONTROL_CS1
+  #ifdef SYSTEM_IS_NAND_ONLY
+    #ifdef BCHP_NAND_ACC_CONTROL_CS0
+      #define REG_ACC_CONTROL    BCHP_NAND_ACC_CONTROL_CS0
+      #define REG_CONFIG         BCHP_NAND_CONFIG_CS0
+    #else
+      #define REG_ACC_CONTROL    BCHP_NAND_ACC_CONTROL
+      #define REG_CONFIG         BCHP_NAND_CONFIG
+    #endif
+  #else
+    #define REG_ACC_CONTROL    BCHP_NAND_ACC_CONTROL_CS1
+    #define REG_CONFIG         BCHP_NAND_CONFIG_CS1
+  #endif
+#else
+  #define REG_ACC_CONTROL    BCHP_NAND_ACC_CONTROL
+  #define REG_CONFIG         BCHP_NAND_CONFIG
+#endif
+
+/* The headers for the latest NAND controllers break compatibility with the old ones
+   for a few registers, rather than have this code turn into even more of a mess of
+   #ifdef's we'll fix that here (this is really getting silly now!)                  */
+
+#ifndef BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK          BCHP_NAND_ACC_CONTROL_CS0_RD_ECC_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_WR_ECC_EN_MASK          BCHP_NAND_ACC_CONTROL_CS0_WR_ECC_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_ECC_LEVEL_MASK          BCHP_NAND_ACC_CONTROL_CS0_ECC_LEVEL_MASK
+#define BCHP_NAND_ACC_CONTROL_ECC_LEVEL_SHIFT         BCHP_NAND_ACC_CONTROL_CS0_ECC_LEVEL_SHIFT
+#define BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_MASK    BCHP_NAND_ACC_CONTROL_CS0_SPARE_AREA_SIZE_MASK
+#define BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_SHIFT   BCHP_NAND_ACC_CONTROL_CS0_SPARE_AREA_SIZE_SHIFT
+#define BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK          BCHP_NAND_ACC_CONTROL_CS0_RD_ECC_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_WR_ECC_EN_MASK          BCHP_NAND_ACC_CONTROL_CS0_WR_ECC_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_WR_PREEMPT_EN_MASK      BCHP_NAND_ACC_CONTROL_CS0_WR_PREEMPT_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_PAGE_HIT_EN_MASK        BCHP_NAND_ACC_CONTROL_CS0_PAGE_HIT_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK    BCHP_NAND_ACC_CONTROL_CS0_PARTIAL_PAGE_EN_MASK
+#define BCHP_NAND_ACC_CONTROL_FAST_PGM_RDIN_MASK      BCHP_NAND_ACC_CONTROL_CS0_FAST_PGM_RDIN_MASK
+#define BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_512MB   BCHP_NAND_CONFIG_CS0_DEVICE_SIZE_DVC_SIZE_512MB
+#define BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB   BCHP_NAND_CONFIG_CS0_DEVICE_SIZE_DVC_SIZE_256MB
+#define BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB   BCHP_NAND_CONFIG_CS0_DEVICE_SIZE_DVC_SIZE_128MB
+#define BCHP_NAND_CONFIG_DEVICE_SIZE_MASK             BCHP_NAND_CONFIG_CS0_DEVICE_SIZE_MASK
+#define BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT            BCHP_NAND_CONFIG_CS0_DEVICE_SIZE_SHIFT
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_MASK              BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_MASK
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT             BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_SHIFT
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_512KB     BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_BK_SIZE_512KB
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_256KB     BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_BK_SIZE_256KB
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB     BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_BK_SIZE_128KB
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_16KB      BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_BK_SIZE_16KB
+#define BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_8KB       BCHP_NAND_CONFIG_CS0_BLOCK_SIZE_BK_SIZE_8KB
+#define BCHP_NAND_CONFIG_PAGE_SIZE_MASK               BCHP_NAND_CONFIG_CS0_PAGE_SIZE_MASK
+#define BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT              BCHP_NAND_CONFIG_CS0_PAGE_SIZE_SHIFT
+#define BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_512        BCHP_NAND_CONFIG_CS0_PAGE_SIZE_PG_SIZE_512
+#define BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB        BCHP_NAND_CONFIG_CS0_PAGE_SIZE_PG_SIZE_2KB
+#endif
+
+
+/*************
+ * DataTypes *
+ *************/
+
+/* Lets just fix this here then the source still looks nice */
+
+#ifndef __BLI_TYPES_DEFINED__
+#define __BLI_TYPES_DEFINED__
+#define BLI_INT8    int8_t
+#define BLI_UINT8   uint8_t
+#define BLI_INT16   int16_t
+#define BLI_UINT16  uint16_t
+#define BLI_INT32   int32_t
+#define BLI_UINT32  uint32_t
+#define BLI_INT64   int64_t
+#define BLI_UINT64  uint64_t
+#define BLI_VOID    void
+#define BLI_BOOL    uint32_t
+#define TRUE        true
+#define FALSE       false
+#endif
+
+
+/***********
+ * Defines *
+ ***********/
+
+/* Enable parameter checking
+
+   - Only disable if you REALLY need the extra few cycles! */
+
+#define PARAM_CHECK                     1
+
+/* Polynomial for CRC table generator */
+
+#define CRC32_POLY                      0x04c11db7
+
+/* ASSEMBLER SPEEDUPS */
+
+#if !defined(ASM_SPEEDUP)
+#define ASM_SPEEDUP                     1
+#endif
+
+/* Hardware Access*/
+
+#define BCHP_HARDWARE_BASE              0x10000000
+
+#define NAND_CACHE_BASE                 (BCHP_HARDWARE_BASE + BCHP_NAND_FLASH_CACHEi_ARRAY_BASE)
+#define NAND_CACHE_SIZE                 512
+
+/* Delay constants */
+
+#define DELAY_ONE_USEC                  100
+#define DELAY_ONE_MSEC                  100000
+#define DELAY_ONE_SECOND                100000000
+
+/* Sizes */
+
+#ifndef KILO
+
+#define KILO                            1024
+#define MEGA                            (1024 * 1024)
+#define GIGA                            (1024 * 1024 * 1024)
+
+#endif
+
+/* Bits from the status register of the flash device
+   These bits are fairly common, but newer devices may have other bits */
+
+#define DEVICE_STATUS_NOT_WRITE_PROTECT (1 << 7)
+#define DEVICE_STATUS_CONTROLLER_READY  (1 << 6)
+#define DEVICE_STATUS_ERROR             (1 << 0)
+
+
+/**********
+ * Macros *
+ **********/
+
+/* RT050711 Pace change */
+
+/* Temporarily changing the KSEG1 */
+
+/* CROSSLN1 - How come these both OR with 0xa0000000, surely we should
+   be using 0x90000000 if CONFIG_BRCM_UPPER_MEMORY is defined????      */
+
+#ifdef CONFIG_BRCM_UPPER_MEMORY
+#define PHYS_TO_KSEG1(v)  ((v) | 0x90000000)
+#else
+#define PHYS_TO_KSEG1(v)  ((v) | 0xa0000000)
+#endif
+#define BCHP_REG(r)       *((volatile uint32_t*) PHYS_TO_KSEG1(BCHP_HARDWARE_BASE | r))
+
+
+/**************
+ * Prototypes *
+ *************/
+
+/* this section needs sorting out! */
+
+static NDR_ERROR  is_vpage_erased(BLI_UINT32 vpage);
+static NDR_ERROR  read_nand(BLI_UINT64 unit_size, BLI_UINT32 unit_count, BLI_UINT32 unit, BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags, BLI_BOOL *pageused);
+static NDR_ERROR  write_nand(BLI_UINT64 unit_size, BLI_UINT32 unit_count, BLI_UINT32 unit, BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags);
+static BLI_BOOL   initialise_hardware(BLI_UINT32 *config);
+static NDR_ERROR  wait_ready(BLI_VOID);
+static BLI_UINT64 get_device_size(BLI_UINT32 nand_config);
+static BLI_INT32  get_block_size(BLI_UINT32 nand_config);
+static BLI_INT32  get_page_size(BLI_UINT32 nand_config);
+static BLI_UINT32 force_native_endian(BLI_UINT32 value);
+#if ASM_SPEEDUP
+static BLI_VOID   __attribute__((__noinline__)) memcopy08(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len);
+static BLI_VOID   __attribute__((__noinline__)) memcopy32(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len);
+static BLI_BOOL   __attribute__((__noinline__)) memcompare08(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len);
+static BLI_BOOL   __attribute__((__noinline__)) memcompare32(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len);
+#else
+static BLI_VOID   memcopy08(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len);
+static BLI_VOID   memcopy32(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len);
+static BLI_BOOL   memcompare08(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len);
+static BLI_BOOL   memcompare32(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len);
+#endif
+static BLI_VOID   generate_crc_table(BLI_VOID);
+#if ASM_SPEEDUP
+static BLI_UINT32 __attribute__((__noinline__)) calc_crc32(BLI_VOID *source, BLI_UINT32 crc, BLI_UINT32 *crctable, BLI_UINT32 count);
+#else
+static BLI_UINT32 calc_crc32(BLI_VOID *source, BLI_UINT32 crc, BLI_UINT32 *crctable, BLI_UINT32 count);
+#endif
+static BLI_UINT64 lrshift64(BLI_UINT64 arg, BLI_UINT8 shift);
+
+
+/**************
+ * Structures *
+ **************/
+
+/* Flash device entry */
+
+typedef struct
+{
+  BLI_UINT32  dev_id;
+  BLI_UINT32  config;
+} FLASH_DEVICE;
+
+/* Spare area layout */
+
+typedef struct
+{
+  BLI_UINT32  sparemask;
+  BLI_UINT32  sparemask_ext;
+  BLI_UINT32  badblock_pos;
+  BLI_UINT32  usedmarker_pos;
+  BLI_UINT32  crc_pos;
+  BLI_UINT32  crc_bytes;
+  BLI_UINT32  ecc_pos;
+  BLI_UINT32  ecc_bytes;
+  BLI_UINT32  bytes_free;
+  BLI_UINT32  bytes_free_ext;
+  BLI_UINT32  corr_stat_threshold;
+} SPARE_MAP;
+
+
+/**********
+ * Tables *
+ **********/
+
+/* Device information structure */
+
+static NAND_DEV_INFO nd_info =
+{
+  {0xDE,0xAD,0xBE,0xEF},        /* See Notes Above                                          */
+  0,                            /* Device size in bytes                                     */
+  0,                            /* Block size in bytes                                      */
+  0,                            /* Number of blocks on device                               */
+  0,                            /* Page size in bytes                                       */
+  0,                            /* Number of pages on device                                */
+  0,                            /* Virtual page size in bytes                               */
+  0,                            /* Number of virtual pages on device                        */
+  0,                            /* Number of pages per block                                */
+  0,                            /* Number of virtual pages per page                         */
+  0,                            /* Number of virtual pages per block                        */
+  0,                            /* ECC Type + spare area layout                             */
+  0,                            /* Type of ECC used                                         */
+  0,                            /* Number of bits ECC can handle                            */
+  0,                            /* ECC Enabled readback                                     */
+  0,                            /* Highest number of error bits per page after last read op */
+  0,                            /* Size of the spare area                                   */
+  0,                            /* Number of free bytes in spare area                       */
+  0,                            /* Number of free bytes in spare area (extended mode)       */
+  0,                            /* Number of bytes used to store ECC data                   */
+  {0},                          /* Spare area free bitmask                                  */
+  {0},                          /* Spare area free bytes                                    */
+  {0},                          /* Spare area free bitmask (extended mode)                  */
+  {0},                          /* Spare area free bytes (extended mode)                    */
+  {0},                          /* Spare area ECC byte positions                            */
+};
+
+
+/* Table of flash devices and geometries
+
+   Needed to fix the 40nm autodetect issue
+
+   *NOTE* if a new 8 bit ECC chip we may have to
+          check the entire 4 byte device code!     */
+
+#ifdef FIX_BROKEN_BCM_NAND_AUTODETECT
+
+#define NUM_FLASH_DEVICES 15
+
+static FLASH_DEVICE flash_parameter_table[NUM_FLASH_DEVICES] =
+{
+  /* ST/Numonyx 128MB */
+  {0x20f1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* ST/Numonyx 256MB */
+  {0x20da, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Hynix 128MB */
+  {0xadf1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Hynix 256MB */
+  {0xadda, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Samsung 128MB */
+  {0xecf1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Samsung 256MB */
+  {0xecda, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Toshiba 128MB */
+  {0x98d1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Toshiba 256MB */
+  {0x98da, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* EON 128MB */
+  {0x92f1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* MXIC 128MB */
+  {0xc2f1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Micron 128MB */
+  {0x2cf1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Spansion 128MB */
+  {0x01f1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Spansion 256MB */
+  {0x01da, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_256MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Spansion 512MB */
+  {0x01dc, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_512MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+
+  /* Toshiba 128MB 8bit ECC, 32 byte spare area */
+  {0x98f1, (BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB << BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)       |
+           (BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB << BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)   |
+           (BCHP_NAND_CONFIG_DEVICE_SIZE_DVC_SIZE_128MB << BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT)},
+};
+
+#endif // #ifdef FIX_BROKEN_BCM_NAND_AUTODETECT
+
+
+/* Spare area usage maps
+
+   Usage type ...
+
+   B = Badblock marker
+   s = Spare
+   E = ECC data
+   U = Page Used
+   C = CRC32
+
+   NOTE - For efficiency the page used marker and CRC MUST
+          be placed in the first 16 bytes
+*/
+
+static SPARE_MAP sparemaps[6] =
+{
+  /* Hamming / 16 byte spare area
+
+     Byte   0123456789ABCDEF
+     Usage  BsssssEEEssUCCCC
+
+     7/12 Bytes unused (spare)   */
+
+  {
+    0x0000fe3e,         /* sparemask           */
+    0x0000063e,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    11,                 /* usedmarker_pos      */
+    12,                 /* crc_pos             */
+    4,                  /* crc_bytes           */
+    5,                  /* ecc_pos             */
+    3,                  /* ecc_bytes           */
+    12,                 /* bytes_free          */
+    7,                  /* bytes_free_ext      */
+    1,                  /* CORR_STAT_THRESHOLD */
+  },
+
+  /* BCH4 / 16 byte spare area
+
+     Byte   0123456789ABCDEF
+     Usage  BsssCCCCUEEEEEEE
+
+     3/8 Bytes unused (spare)   */
+
+  {
+    0x000001fe,         /* sparemask           */
+    0x0000000e,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    8,                  /* usedmarker_pos      */
+    4,                  /* crc_pos             */
+    4,                  /* crc_bytes           */
+    9,                  /* ecc_pos             */
+    7,                  /* ecc_bytes           */
+    8,                  /* bytes_free          */
+    3,                  /* bytes_free_ext      */
+    2,                  /* CORR_STAT_THRESHOLD */
+  },
+
+  /* BCH8 / 27 byte spare area
+
+     Byte   0123456789ABCDEF 0123456789A
+     Usage  BsssssssCCCCUEEE EEEEEEEEEEE
+
+     7/12 Bytes unused (spare)   */
+
+  {
+    0x00001ffe,         /* sparemask           */
+    0x000000fe,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    12,                 /* usedmarker_pos      */
+    8,                  /* crc_pos             */
+    4,                  /* crc_bytes           */
+    13,                 /* ecc_pos             */
+    14,                 /* ecc_bytes           */
+    12,                 /* bytes_free          */
+    7,                  /* bytes_free_ext      */
+    4,                  /* CORR_STAT_THRESHOLD */
+  },
+
+  /* BCH8 / 32 byte spare area
+
+     Byte   0123456789ABCDEF 0123456789ABCDEF
+     Usage  BUssssssssssCCCC ssEEEEEEEEEEEEEE
+
+     12/17 Bytes unused (spare)   */
+
+  {
+    0x0002fffe,         /* sparemask           */
+    0x00020ffc,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    1,                  /* usedmarker_pos      */
+    12,                 /* crc_pos             */
+    4,                  /* crc_bytes           */
+    18,                 /* ecc_pos             */
+    14,                 /* ecc_bytes           */
+    17,                 /* bytes_free          */
+    12,                 /* bytes_free_ext      */
+    4,                  /* CORR_STAT_THRESHOLD */
+  },
+
+  /* BCH12 / 27 byte spare area
+
+     Byte   0123456789ABCDEF 0123456789A
+     Usage  BUCCCCEEEEEEEEEE EEEEEEEEEEE
+
+     0/5 Bytes unused (spare)   */
+
+  {
+    0x0000002e,         /* sparemask           */
+    0x00000000,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    1,                  /* usedmarker_pos      */
+    2,                  /* crc_pos             */
+    4,                  /* crc_bytes           */
+    6,                  /* ecc_pos             */
+    21,                 /* ecc_bytes           */
+    5,                  /* bytes_free          */
+    0,                  /* bytes_free_ext      */
+    6,                  /* CORR_STAT_THRESHOLD */
+  },
+
+  /* BCH12 / 32 byte spare area
+
+     Byte   0123456789ABCDEF 0123456789ABCDEF
+     Usage  BsssssUCCCCEEEEE EEEEEEEEEEEEEEEE
+
+     5/10 Bytes unused (spare)   */
+  {
+    0x000007fe,         /* sparemask           */
+    0x0000002e,         /* sparemask_ext       */
+    0,                  /* badblock_pos        */
+    6,                  /* usedmarker_pos      */
+    7,                  /* crc_pos             */
+    4,                  /* crc_bytes           */
+    11,                 /* ecc_pos             */
+    21,                 /* ecc_bytes           */
+    5,                  /* bytes_free          */
+    10,                 /* bytes_free_ext      */
+    6,                  /* CORR_STAT_THRESHOLD */
+  },
+};
+
+
+/***********
+ * Buffers *
+ ***********/
+
+/* Page Buffer */
+
+static BLI_UINT8  pagebuffer_r[2048];
+static BLI_UINT8  pagebuffer_w[2048];
+static BLI_UINT8  pagecopybuffer[2048];
+
+/* 'Spare' Area buffer */
+
+static BLI_UINT8  sparebuffer[128];
+
+/* CRC Table */
+
+static BLI_UINT32 nand_crc_table[256];
+
+
+/***************
+ * Global Data *
+ ***************/
+
+static BLI_BOOL   nand_driver_initialised = FALSE;
+static BLI_UINT32 nand_bad_block_offset;
+static BLI_UINT32 nand_data_crc32_offset;
+static BLI_UINT32 nand_data_valid_offset;
+static BLI_BOOL   little_endian;
+static BLI_UINT32 cs_ext_select;
+static BLI_UINT32 ecctype;
+static BLI_UINT32 ecc_spare_area_layout;
+static BLI_UINT32 errorbits;
+static BLI_UINT32 spare_area_size;
+static BLI_UINT32 sub_pages_per_page;
+static BLI_UINT32 virt_page_size;
+static BLI_UINT32 virt_page_mask;
+static BLI_UINT32 virt_page_shift;
+
+static struct semaphore nand_dev_sema;
+
+
+/****************************************************************************
+ *                                 Exported Routines                        *
+ ****************************************************************************/
+
+/*********************
+ * Initialise Driver *
+ *********************/
+
+/* Entry   : NO PARAMETERS
+
+   Returns : NDR error code (see header file)  */
+
+NDR_ERROR nand_dev_init(BLI_VOID)
+{
+  /* Locals */
+
+  BLI_UINT32            nand_config;
+  BLI_UINT64            device_size;
+  BLI_UINT32            block_size, page_size;
+  BLI_UINT32            device_size_kilo, block_size_kilo;
+  BLI_UINT32            vpages_per_page;
+  BLI_UINT32            dev_id;
+  volatile BLI_UINT32   endlong;
+  volatile BLI_UINT8    *endptr08;
+  BLI_INT32             i,j;
+  BLI_UINT32            sm,sme,smp,smep,mask;
+
+  /* If driver already initialised return an error */
+
+  if (nand_driver_initialised)
+  {
+    return(NDR_ALREADY_INITIALISED);
+  }
+
+  /* Initialise Mutex */
+
+  sema_init(&nand_dev_sema, 0);
+
+  /* Determian endian mode */
+
+  endlong  = 0xDEADBEEF;
+  endptr08 = (BLI_UINT8*) &endlong;
+  little_endian = FALSE;
+
+  if ((endptr08[0] == 0xEF) && (endptr08[1] == 0xBE) && (endptr08[2] == 0xAD) && (endptr08[3] == 0xDE))
+  {
+    little_endian = TRUE;
+  }
+
+  /* Initialise hardware registers */
+
+  if (!(initialise_hardware(&nand_config)))
+  {
+    up(&nand_dev_sema);
+    return(NDR_UNSUPPORTED_DEVICE);
+  }
+
+  /* Sanity check, need the extended registers if >16 byte spare area */
+
+  if (spare_area_size > 16)
+  {
+    #if !defined(BCHP_NAND_SPARE_AREA_READ_OFS_10) || !defined(BCHP_NAND_SPARE_AREA_WRITE_OFS_10)
+    up(&nand_dev_sema);
+    return(NDR_FATAL_ERROR);
+    #endif
+  }
+
+  /* Get the device ID, bail if no NAND found */
+
+  dev_id = BCHP_REG(BCHP_NAND_FLASH_DEVICE_ID);
+
+  if (dev_id == 0)
+  {
+    up(&nand_dev_sema);
+    return(NDR_NO_NAND_PRESENT);
+  }
+
+  /* Get the device, block and page size from the config register */
+
+  device_size = get_device_size(nand_config);
+  block_size  = get_block_size(nand_config);
+  page_size   = get_page_size(nand_config);
+
+  /* Bail out now if the device, block or page sizes were invalid */
+
+  if ((device_size == -1) || (block_size == -1) || (page_size == -1))
+  {
+    up(&nand_dev_sema);
+    return(NDR_UNSUPPORTED_DEVICE);
+  }
+
+  /* The page size *MUST* be 2K
+
+     Yet another nasty fix for later :( */
+
+  if (page_size != 2048)
+  {
+    up(&nand_dev_sema);
+    return(NDR_UNSUPPORTED_DEVICE);
+  }
+
+  /* Build the information structure */
+
+  #ifdef FORCE_2K_PAGEWRITES
+
+  virt_page_size = 2048;
+  virt_page_mask = 0x7ff;
+  virt_page_shift = 11;
+  sub_pages_per_page = 4;
+
+  #else
+
+  virt_page_size = NAND_CACHE_SIZE;
+  virt_page_mask = 0x1ff;
+  virt_page_shift = 9;
+  sub_pages_per_page = 1;
+
+  #endif
+
+  nand_data_valid_offset = sparemaps[ecc_spare_area_layout].usedmarker_pos;
+  nand_data_crc32_offset = sparemaps[ecc_spare_area_layout].crc_pos;
+  nand_bad_block_offset  = sparemaps[ecc_spare_area_layout].badblock_pos;
+
+  vpages_per_page = page_size / virt_page_size;
+
+  device_size_kilo = device_size >> 10;
+  block_size_kilo  = block_size >> 10;
+
+  nd_info.Device_ID[0]                = (BLI_UINT8)(dev_id >> 24);
+  nd_info.Device_ID[1]                = (BLI_UINT8)(dev_id >> 16);
+  nd_info.Device_ID[2]                = (BLI_UINT8)(dev_id >> 8);
+  nd_info.Device_ID[3]                = (BLI_UINT8)(dev_id);
+  nd_info.Device_Size                 = device_size;
+  nd_info.Block_Size                  = block_size;
+  nd_info.Block_Count                 = device_size_kilo / block_size_kilo;
+  nd_info.Page_Size                   = page_size;
+  nd_info.Page_Count                  = nd_info.Block_Count * (block_size / page_size);
+  nd_info.Virt_Page_Size              = virt_page_size;
+  nd_info.Virt_Page_Count             = nd_info.Page_Count * vpages_per_page;
+  nd_info.Pages_Per_Block             = block_size / page_size;
+  nd_info.Virt_Pages_Per_Page         = vpages_per_page;
+  nd_info.Virt_Pages_Per_Block        = block_size / virt_page_size;
+  nd_info.ECC_Spare_Area_Layout       = ecc_spare_area_layout;
+  nd_info.ECC_Type                    = ecctype;
+  nd_info.ECC_Bits                    = errorbits;
+  nd_info.ECC_Enabled                 = TRUE;
+  nd_info.ECC_ErrorBits               = 0;
+  nd_info.Spare_Area_Size             = spare_area_size * sub_pages_per_page;
+  nd_info.Spare_Area_Free             = sparemaps[ecc_spare_area_layout].bytes_free * sub_pages_per_page;
+  nd_info.Spare_Area_Free_Ext         = sparemaps[ecc_spare_area_layout].bytes_free_ext * sub_pages_per_page;
+  nd_info.Spare_Area_ECC_Bytes        = sparemaps[ecc_spare_area_layout].ecc_bytes * sub_pages_per_page;
+
+  /* Build the spare area usage data */
+
+  sm  = sparemaps[ecc_spare_area_layout].sparemask;
+  sme = sparemaps[ecc_spare_area_layout].sparemask_ext;
+  smp = 0;
+  smep = 0;
+
+  for (i = 0; i < sub_pages_per_page; i++)
+  {
+    nd_info.Spare_Free_Mask[i] = sm;
+    nd_info.Spare_Free_Mask_Ext[i] = sme;
+    mask = 1;
+    for (j = 0; j < spare_area_size; j++)
+    {
+      if (sm & mask)
+      {
+        nd_info.Spare_Area_Bytes[smp] = j + (i * spare_area_size);
+        smp++;
+      }
+
+      if (sme & mask)
+      {
+        nd_info.Spare_Area_Bytes_Ext[smep] = j + (i * spare_area_size);
+        smep++;
+      }
+      mask <<= 1;
+    }
+  }
+
+  smp = 0;
+
+  for (i = 0; i < sub_pages_per_page; i++)
+  {
+    for (j = 0; j < sparemaps[ecc_spare_area_layout].ecc_bytes; j++)
+    {
+      nd_info.Spare_Area_ECC_bytes[smp] = (sparemaps[ecc_spare_area_layout].ecc_pos + j) + (i * spare_area_size);
+      smp++;
+    }
+  }
+
+  /* Build the CRC table */
+
+  generate_crc_table();
+
+  /* Driver is now initialised */
+
+  nand_driver_initialised = TRUE;
+
+  /* Return success */
+
+  up(&nand_dev_sema);
+  return(NDR_SUCCESS);
+}
+
+
+/********************
+ * Shut Down Driver *
+ ********************/
+
+/* Entry   : NO PARAMETERS
+
+   Returns : NDR error code (see header file)  */
+
+NDR_ERROR nand_dev_shutdown(BLI_VOID)
+{
+  /* Clear initialised flag */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  nand_driver_initialised = FALSE;
+
+  up(&nand_dev_sema);
+
+  /* Return success */
+
+  return(NDR_SUCCESS);
+}
+
+
+/*****************************
+ * Return Device Information *
+ *****************************/
+
+/* Entry   : Pointer to pointer to information block
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The returned pointer will point to a blank
+             information structure if this function is
+             called before the driver is inialised, this
+             avoids any nasty NULL pointer issues!       */
+
+NDR_ERROR nand_dev_get_info(NAND_DEV_INFO **info)
+{
+  /* Return pointer to information block */
+
+  *info = &nd_info;
+
+  /* Return an error if the driver has not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Return success */
+
+  return(NDR_SUCCESS);
+}
+
+
+/**************
+ * Enable ECC *
+ **************/
+
+/* Entry   : Pass FALSE to DISABLE ECC
+             Pass TRUE  to ENABLE  ECC
+
+   Returns : NDR error code (see header file)  */
+
+NDR_ERROR nand_dev_enable_ecc(BLI_BOOL enable)
+{
+  /* Locals */
+
+  BLI_UINT32 reg;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Enable or Disable ECC */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  reg  = BCHP_REG(REG_ACC_CONTROL);
+
+  if (enable)
+  {
+    reg |= BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK;        /* Enable Read ECC for blocks 1-?  */
+    reg |= BCHP_NAND_ACC_CONTROL_WR_ECC_EN_MASK;        /* Enable write ECC for all blocks */
+    #if defined(BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK)
+    reg |= BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK;   /* Enable Read ECC for block 0     */
+    #endif
+  }
+  else
+  {
+    reg &= ~BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK;        /* Enable Read ECC for blocks 1-?  */
+    reg &= ~BCHP_NAND_ACC_CONTROL_WR_ECC_EN_MASK;        /* Enable write ECC for all blocks */
+    #if defined(BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK)
+    reg &= ~BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK;   /* Enable Read ECC for block 0     */
+    #endif
+  }
+
+  BCHP_REG(REG_ACC_CONTROL) = reg;
+
+  /* Update the info structure */
+
+  nd_info.ECC_Enabled = enable;
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+
+  return(NDR_SUCCESS);
+}
+
+
+/****************
+ * Read a block *
+ ****************/
+
+/* Entry   : block  - The block number to start at
+             data   - Destination address for data
+             offset - Offset within the block to begin reading at
+             length - The number of bytes to read
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one block
+           : If the destination address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_read_block(BLI_UINT32 block, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = read_nand((BLI_UINT64)nd_info.Block_Size, nd_info.Block_Count, block, data, (BLI_UINT64)offset, length, flags, NULL);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/***************
+ * Read a page *
+ ***************/
+
+/* Entry   : page   - The page number to start at
+             data   - Destination address for data
+             offset - Offset within the page to begin reading at
+             length - The number of bytes to read
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one page
+           : If the destination address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_read_page(BLI_UINT32 page, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = read_nand((BLI_UINT64)nd_info.Page_Size, nd_info.Page_Count, page, data, (BLI_UINT64)offset, length, flags, NULL);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/***********************
+ * Read a virtual page *
+ ***********************/
+
+/* Entry   : page   - The virtual page number to start at
+             data   - Destination address for data
+             offset - Offset within the page to begin reading at
+             length - The number of bytes to read
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one page
+           : If the destination address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_read_vpage(BLI_UINT32 vpage, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = read_nand((BLI_UINT64)nd_info.Virt_Page_Size, nd_info.Virt_Page_Count, vpage, data, (BLI_UINT64)offset, length, flags, NULL);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/******************
+ * Read anywhere *
+ ******************/
+
+/* Entry   : data   - Source address of data
+             offset - Offset within the page to begin writing to
+             length - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : If the source address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_read_anywhere(BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = read_nand((BLI_UINT64)nd_info.Device_Size, 1, 0, data, (BLI_UINT64)offset, length, flags, NULL);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/*****************
+ * Write a block *
+ *****************/
+
+/* Entry   : block  - The block number to start at
+             data   - Source address of data
+             offset - Offset within the block to begin writing to
+             length - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one block
+           : If the source address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_write_block(BLI_UINT32 block, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length,BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = write_nand((BLI_UINT64)nd_info.Block_Size, nd_info.Block_Count, block, data, (BLI_UINT64)offset, length, flags);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/****************
+ * Write a page *
+ ****************/
+
+/* Entry   : block  - The page number to start at
+             data   - Source address of data
+             offset - Offset within the page to begin writing to
+             length - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one block
+           : If the source address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_write_page(BLI_UINT32 page, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = write_nand((BLI_UINT64)nd_info.Page_Size, nd_info.Page_Count, page, data, (BLI_UINT64)offset, length, flags);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/************************
+ * Write a virtual page *
+ ************************/
+
+/* Entry   : block  - The page number to start at
+             data   - Source address of data
+             offset - Offset within the page to begin writing to
+             length - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : The maximum read length is one block
+           : If the source address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_write_vpage(BLI_UINT32 vpage, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = write_nand((BLI_UINT64)nd_info.Virt_Page_Size, nd_info.Virt_Page_Count, vpage, data, (BLI_UINT64)offset, length, flags);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/******************
+ * Write anywhere *
+ ******************/
+
+/* Entry   : data   - Source address of data
+             offset - Offset within the page to begin writing to
+             length - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : If the source address is misaligned then performance will suffer. */
+
+NDR_ERROR nand_dev_write_anywhere(BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = write_nand((BLI_UINT64)nd_info.Device_Size, 1, 0, data, (BLI_UINT64)offset, length, flags);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/*****************
+ * Erase a block *
+ *****************/
+
+/* Entry   : block - The block number erase
+
+   Returns : NDR error code (see header file)  */
+
+NDR_ERROR nand_dev_erase_block(BLI_UINT32 block)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  block_address;
+  BLI_UINT32  status;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check block in range */
+
+  #if PARAM_CHECK
+  if (block >= nd_info.Block_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Calculate address of block to be erased */
+
+  block_address = (block * nd_info.Block_Size);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Set Base Address */
+
+  BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = block_address & 0xFFFFFFFF;
+  BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(block_address, 32) | cs_ext_select;
+
+  /* Tell the controller to erase the block */
+
+  BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_BLOCK_ERASE << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+  /* Wait for controller ready */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Check for error */
+
+  status = BCHP_REG(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_FLASH_STATUS_MASK;
+
+  if (status & DEVICE_STATUS_ERROR)
+  {
+    up(&nand_dev_sema);
+    return(NDR_DEVICE_ERASE_ERROR);
+  }
+
+  #ifdef CHECK_WRITEPROTECT
+  if (!(status & DEVICE_STATUS_NOT_WRITE_PROTECT))
+  {
+    up(&nand_dev_sema);
+    return(NDR_WRITE_PROTECTED);
+  }
+  #endif
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+  return(NDR_SUCCESS);
+}
+
+
+/****************
+ * Copy a block *
+ ****************/
+
+/* Entry   : destblock   - The block to copy TO
+             sourceblock - The block to copy FROM
+             vpignore    - The virtual page not to copy (set to 0xffffffff to disable)
+             flags       - Flags for Verify/CRC/UsedMarker
+
+   Returns : NDR error code (see header file)
+
+   Notes   : Normal people (ie the people who think that the C memcopy has the
+             source and destination parameters the wrong may around) will probably
+             overwrite a block by accident the first time they use this!!!         */
+
+NDR_ERROR nand_dev_copy_block(BLI_UINT32 destblock, BLI_UINT32 sourceblock, BLI_UINT32 vpignore, BLI_UINT32 flags)
+{
+  /* Locals */
+
+  NDR_ERROR   result;
+  BLI_UINT32  vppb;
+  BLI_INT32   i;
+  BLI_BOOL    pageused;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check source and dest blocks in range and not the same */
+
+  #if PARAM_CHECK
+  if (sourceblock == destblock) return(NDR_ERROR_COPY_TO_SAME_BLOCK);
+  if (sourceblock >= nd_info.Block_Count) return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  if (destblock >= nd_info.Block_Count) return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Copy all the vpages in the block, exit if error */
+
+  vppb = nd_info.Virt_Pages_Per_Block;
+
+  for (i = 0; i < vppb; i++)
+  {
+    /* Check we're not skipping this vpage */
+
+    if (i != vpignore)
+    {
+      /* Read the vpage (also reads the spare area) */
+
+      result = read_nand((BLI_UINT64)nd_info.Virt_Page_Size, nd_info.Virt_Page_Count,
+                         (sourceblock * vppb) + i, &pagecopybuffer, (BLI_UINT64) 0, nd_info.Virt_Page_Size, flags, &pageused);
+
+      /* If we're only copying used vpages then do the check
+         skip over the write if the vpage has not been written */
+
+      if (flags & NDR_FLAGS_USEDMARKER)
+      {
+        if (!pageused) continue;
+      }
+
+      /* abort the copy if we got an error during the read */
+
+      if (result < NDR_SUCCESS) break;
+
+      /* Write the vpage, any error here aborts the copy */
+
+      result = write_nand((BLI_UINT64)nd_info.Virt_Page_Size, nd_info.Virt_Page_Count,
+                          (destblock * vppb) + i, &pagecopybuffer, 0, nd_info.Virt_Page_Size, (flags | NDR_FLAGS_VERIFY));
+
+      if (result != NDR_SUCCESS) break;
+    }
+  }
+
+  /* Return Result */
+
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/*****************
+ * Is Vpage Used *
+ *****************/
+
+NDR_ERROR nand_dev_is_vpage_used(BLI_UINT32 vpage)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT32  *sparebuff;
+  BLI_UINT8   pageused;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (vpage >= nd_info.Virt_Page_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (vpage * nd_info.Virt_Page_Size);
+  vpage_address += (sub_pages_per_page - 1) * NAND_CACHE_SIZE;
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Set Base Address */
+
+  BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+  BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+  /* Tell the controller to read the spares */
+
+  BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_SPARE_AREA_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+  /* Wait for controller ready */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Check page used */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0));
+  sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4));
+  sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8));
+  sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C));
+
+  /* Check the page used marker */
+
+  pageused = sparebuffer[nand_data_valid_offset];
+
+  up(&nand_dev_sema);
+
+  switch(pageused)
+  {
+    case 0xff:
+      return(NDR_VPAGE_NOT_USED);
+    break;
+
+    case 0xf0:
+    case 0xf1:
+    case 0xf2:
+    case 0xf3:
+      return(NDR_VPAGE_IS_USED);
+    break;
+
+    default:
+      return(NDR_VPAGE_IS_DEACTIVATED);
+    break;
+  }
+}
+
+
+/*******************
+ * Read spare area *
+ *******************/
+
+/* Entry   : vpage - The virtual page who's spare bytes you want to read
+             data  - Destination Address for data
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This function will probably only be of use if you are
+             implementing your own error correction (or detection)
+             routines.                                             */
+
+NDR_ERROR nand_dev_read_spare(BLI_UINT32 vpage, BLI_VOID* data)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT8   *d;
+  BLI_UINT32  *sparebuff;
+  BLI_INT32   i;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (vpage >= nd_info.Virt_Page_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (vpage * nd_info.Virt_Page_Size);
+
+  /* Setup destination buffer */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Read all the spares */
+
+  for (i = 0; i < sub_pages_per_page; i++)
+  {
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+    vpage_address += NAND_CACHE_SIZE;
+
+    /* Tell the controller to read the spares */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_SPARE_AREA_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      up(&nand_dev_sema);
+      return(result);
+    }
+
+    /* Transfer the data to the buffer */
+
+    sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0));
+    sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4));
+    sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8));
+    sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C));
+    sparebuff += 4;
+    if (spare_area_size > 16)
+    {
+      #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10)
+      sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10));
+      sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14));
+      sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18));
+      sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C));
+      #endif
+      sparebuff += 4;
+    }
+  }
+
+  /* Copy data back to caller ... */
+
+  if (spare_area_size > 16)
+  {
+    if (spare_area_size == 27)
+    {
+      d = (BLI_UINT8*)data;
+      for (i = 0; i < sub_pages_per_page; i++)
+      {
+        memcopy08(d, &sparebuffer[i*32], 27);
+        d += 27;
+      }
+    }
+    else
+    {
+      memcopy08(data, &sparebuffer[0], 32 * sub_pages_per_page);
+    }
+  }
+  else
+  {
+    memcopy08(data, &sparebuffer[0], 16 * sub_pages_per_page);
+  }
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+  return(NDR_SUCCESS);
+}
+
+
+/********************
+ * Write spare area *
+ ********************/
+
+/* Entry   : vpage - The virtual page who's spare bytes you want to write
+             data  - Source Address for data
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This function will probably only be of use if you are
+             implementing your own error correction (or detection)
+             routines.                                              */
+
+NDR_ERROR nand_dev_write_spare(BLI_UINT32 vpage, BLI_VOID* data)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT8   *d;
+  BLI_UINT32  *sparebuff;
+  BLI_UINT32  status;
+  BLI_UINT32  reg;
+  BLI_INT32   i;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (vpage >= nd_info.Virt_Page_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (vpage * nd_info.Virt_Page_Size);
+
+  /* Copy data to aligned buffer */
+
+  if (spare_area_size > 16)
+  {
+    if (spare_area_size == 27)
+    {
+      d = (BLI_UINT8*)data;
+      for (i = 0; i < sub_pages_per_page; i++)
+      {
+        memcopy08(&sparebuffer[i*32], d, 27);
+        d += 27;
+      }
+    }
+    else
+    {
+      memcopy08(&sparebuffer[0], data, 32 * sub_pages_per_page);
+    }
+  }
+  else
+  {
+    memcopy08(&sparebuffer[0], data, 16 * sub_pages_per_page);
+  }
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Backup ACC control and Reenable Partial page enable */
+
+  #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+  reg  = BCHP_REG(REG_ACC_CONTROL);
+  BCHP_REG(REG_ACC_CONTROL) = reg | BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK;
+  #endif
+
+  for (i = 0; i < sub_pages_per_page; i++)
+  {
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+    vpage_address += NAND_CACHE_SIZE;
+
+    /* Transfer the data to the spare holding registers */
+
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_0) = force_native_endian(sparebuff[0]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_4) = force_native_endian(sparebuff[1]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_8) = force_native_endian(sparebuff[2]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_C) = force_native_endian(sparebuff[3]);
+    sparebuff += 4;
+    if (spare_area_size > 16)
+    {
+      #if defined(BCHP_NAND_SPARE_AREA_WRITE_OFS_10)
+      BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_10) = force_native_endian(sparebuff[0]);
+      BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_14) = force_native_endian(sparebuff[1]);
+      BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_18) = force_native_endian(sparebuff[2]);
+      BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_1C) = force_native_endian(sparebuff[3]);
+      #endif
+      sparebuff += 4;
+    }
+
+    /* Tell the controller to write the spares */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PROGRAM_SPARE_AREA << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+      BCHP_REG(REG_ACC_CONTROL) = reg;
+      #endif
+      up(&nand_dev_sema);
+      return(result);
+    }
+  }
+
+  /* Reset partial page enable state */
+
+  #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+  BCHP_REG(REG_ACC_CONTROL) = reg;
+  #endif
+
+  /* Check for error */
+
+  status = BCHP_REG(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_FLASH_STATUS_MASK;
+
+  if (status & DEVICE_STATUS_ERROR)
+  {
+    up(&nand_dev_sema);
+    return(NDR_DEVICE_PROGRAM_ERROR);
+  }
+
+  #ifdef CHECK_WRITEPROTECT
+  if (!(status & DEVICE_STATUS_NOT_WRITE_PROTECT))
+  {
+    up(&nand_dev_sema);
+    return(NDR_WRITE_PROTECTED);
+  }
+  #endif
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+  return(NDR_SUCCESS);
+}
+
+
+/**********************
+ * Is a block erased? *
+ **********************/
+
+/* block   : block - The block to check
+
+   Returns : NDR error code (see header file)
+
+   Notes   : Returns
+             the pages in the block to determine if it is erased.     */
+
+NDR_ERROR nand_dev_is_block_erased(BLI_UINT32 block)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT32  vppb;
+  BLI_UINT32  i;
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Check all virtial pages in this block */
+
+  vppb = nd_info.Virt_Pages_Per_Block;
+
+  for (i = 0; i < vppb; i++)
+  {
+    result = is_vpage_erased((block * vppb) + i);
+
+    if (result != NDR_IS_ERASED)
+    {
+      up(&nand_dev_sema);
+      return(result);
+    }
+  }
+
+  /* return block erased */
+
+  up(&nand_dev_sema);
+  return(NDR_IS_ERASED);
+}
+
+
+/*******************
+ * Is page erased? *
+ *******************/
+
+/* block   : page - The Page to check
+
+   Returns : NDR error code (see header file)
+
+   Notes   : Returns
+             the pages in the block to determine if it is erased.     */
+
+NDR_ERROR nand_dev_is_page_erased(BLI_UINT32 page)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT32  vppp;
+  BLI_UINT32  i;
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Check all virtial pages in this page */
+
+  vppp = nd_info.Virt_Pages_Per_Page;
+
+  for (i = 0; i < vppp; i++)
+  {
+    result = is_vpage_erased((page * vppp) + i);
+
+    if (result != NDR_IS_ERASED)
+    {
+      up(&nand_dev_sema);
+      return(result);
+    }
+  }
+
+  /* return block erased */
+
+  up(&nand_dev_sema);
+  return(NDR_IS_ERASED);
+}
+
+
+/*****************************
+ * Is a virtual page erased? *
+ *****************************/
+
+/* Entry   : page - The page to check
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This function is quite slow as it has to actually read
+             the entire page (including the spare area) to determine
+             if it is erased.                                        */
+
+NDR_ERROR nand_dev_is_vpage_erased(BLI_UINT32 vpage)
+{
+  NDR_ERROR result;
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+  result = is_vpage_erased(vpage);
+  up(&nand_dev_sema);
+  return(result);
+}
+
+
+/*******************
+ * Is a block bad? *
+ *******************/
+
+/* Entry   : block - The block to check
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This reads the bad block information byte located in the spare
+             area of the first or second page in the block.                  */
+
+NDR_ERROR nand_dev_is_block_bad(BLI_UINT32 block)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT32  *sparebuff;
+  BLI_UINT32  i;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (block >= nd_info.Block_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Setup destination buffer */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (block * nd_info.Block_Size);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* We need to check the first two pages of the block */
+
+  for (i = 0; i < 2; i++)
+  {
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+    /* Tell the controller to read the spares */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_SPARE_AREA_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      up(&nand_dev_sema);
+      return(result);
+    }
+
+    /* Transfer the data from the spare holding registers */
+
+    sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0));
+    sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4));
+    sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8));
+    sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C));
+
+    /* Check the Bad block marker */
+
+    if (sparebuffer[nand_bad_block_offset] != 0xFF)
+    {
+      up(&nand_dev_sema);
+      return(NDR_BLOCK_IS_BAD);
+    }
+
+    /* Advance to next page */
+
+    vpage_address += nd_info.Page_Size;
+  }
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+  return(NDR_BLOCK_IS_GOOD);
+}
+
+
+/*********************
+ * Mark Block as bad *
+ *********************/
+
+/* Entry   : block - The block to mark as bad
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This writes the bad block information bytes located in the spare
+             area of the first and second page in the block.                   */
+
+NDR_ERROR nand_dev_mark_block_bad(BLI_UINT32 block)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT32  *sparebuff;
+  BLI_UINT32  i;
+  BLI_UINT32  reg;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (block >= nd_info.Block_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Take Mutex */
+
+  if (down_interruptible(&nand_dev_sema)) return(NDR_SYS_ERROR);
+
+  /* Setup destination buffer */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  sparebuff[0] = 0xFFFFFFFF;
+  sparebuff[1] = 0xFFFFFFFF;
+  sparebuff[2] = 0xFFFFFFFF;
+  sparebuff[3] = 0xFFFFFFFF;
+
+  sparebuffer[nand_bad_block_offset] = 0xF0;
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (block * nd_info.Block_Size);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    up(&nand_dev_sema);
+    return(result);
+  }
+
+  /* Backup ACC control and Reenable Partial page enable */
+
+  #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+  reg  = BCHP_REG(REG_ACC_CONTROL);
+  BCHP_REG(REG_ACC_CONTROL) = reg | BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK;
+  #endif
+
+  /* We need to mark bad in the first two pages of the block */
+
+  for (i = 0; i < 2; i++)
+  {
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+    /* Transfer the data to the spare holding registers */
+
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_0) = force_native_endian(sparebuff[0]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_4) = force_native_endian(sparebuff[1]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_8) = force_native_endian(sparebuff[2]);
+    BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_C) = force_native_endian(sparebuff[3]);
+
+    /* Tell the controller to write the spares */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PROGRAM_SPARE_AREA << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+      BCHP_REG(REG_ACC_CONTROL) = reg;
+      #endif
+      up(&nand_dev_sema);
+      return(result);
+    }
+
+    /* Advance to next page */
+
+    vpage_address += nd_info.Page_Size;
+  }
+
+  /* Reset partial page enable state */
+
+  #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+  BCHP_REG(REG_ACC_CONTROL) = reg;
+  #endif
+
+  /* Return Success */
+
+  up(&nand_dev_sema);
+  return(NDR_SUCCESS);
+}
+
+
+/****************
+ * Return CRC32 *
+ ****************/
+
+/* We may as well export this so higher levels can do their own CRC checks */
+
+BLI_UINT32 nand_dev_calc_crc32(BLI_VOID* data, BLI_UINT32 crc, BLI_UINT32 count)
+{
+  return(calc_crc32(data, crc, nand_crc_table, count));
+}
+
+
+/************************************************************************
+ *                     Internal -  IsErased, Read, Write                *
+ ************************************************************************/
+
+/*****************************
+ * Is a virtual page erased? *
+ *****************************/
+
+/* Entry   : page - The page to check
+
+   Returns : NDR error code (see header file)
+
+   Notes   : This function is quite slow as it has to actually read
+             the entire page (including the spare area) to determine
+             if it is erased.                                        */
+
+static NDR_ERROR is_vpage_erased(BLI_UINT32 vpage)
+{
+  /* Locals */
+
+  BLI_INT32   result;
+  BLI_UINT64  vpage_address;
+  BLI_UINT32  *data;
+  BLI_INT32   i,j;
+  BLI_BOOL    used;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+  /* Check page in range */
+
+  #if PARAM_CHECK
+  if (vpage >= nd_info.Virt_Page_Count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+  #endif
+
+  /* Calculate address of virtual page */
+
+  vpage_address = (vpage * nd_info.Virt_Page_Size);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    return(result);
+  }
+
+  for (i = 0; i < sub_pages_per_page; i++)
+  {
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = vpage_address & 0xFFFFFFFF;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(vpage_address, 32) | cs_ext_select;
+
+    vpage_address += NAND_CACHE_SIZE;
+
+    /* Tell the controller to read the data area + spares */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PAGE_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      return(result);
+    }
+
+    /* Check all spares are 0xFFFFFFFF */
+
+    used  = (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0) != 0xFFFFFFFF);
+    used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4) != 0xFFFFFFFF);
+    used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8) != 0xFFFFFFFF);
+    used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C) != 0xFFFFFFFF);
+
+    if (spare_area_size > 16)
+    {
+      #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10)
+      used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10) != 0xFFFFFFFF);
+      used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14) != 0xFFFFFFFF);
+
+      if (spare_area_size == 27)
+      {
+        used |= ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) & 0xFFFFFF00) != 0xFFFFFF00);
+      }
+      else
+      {
+        used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) != 0xFFFFFFFF);
+        used |= (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C) != 0xFFFFFFFF);
+      }
+      #endif
+    }
+
+    if (used) return (NDR_NOT_ERASED);
+
+    /* Check slice erased */
+
+    data = (BLI_UINT32*)PHYS_TO_KSEG1(NAND_CACHE_BASE);
+
+    for (j = 0; j < NAND_CACHE_SIZE / 4; j++)
+    {
+      if (*data++ != 0xFFFFFFFF)
+      {
+        return (NDR_NOT_ERASED);
+      }
+    }
+  }
+
+  /* Return virtual page erassed */
+
+  return(NDR_IS_ERASED);
+}
+
+
+/*************************
+ * Read a block or page  *
+ *************************/
+
+/* Entry   : unit_size - Size of a block or page
+             num_units - The number of blocks or pages on the device
+             unit      - The block or page number to start at
+             data      - Destination address
+             offset    - Offset within the block or page to begin reading at
+             length    - The number of bytes to read
+
+   Returns : NDR error code (see header file)
+
+   Notes   : If the destination address is misaligned then performance will suffer. */
+
+static NDR_ERROR read_nand(BLI_UINT64 unit_size, BLI_UINT32 unit_count, BLI_UINT32 unit, BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags, BLI_BOOL *pageused)
+{
+  /* Locals */
+
+  BLI_UINT64  source_address;
+  BLI_UINT32  dest_address;
+  BLI_UINT8   *crc_source;
+  BLI_UINT8   b;
+  BLI_UINT64  start_offs;
+  BLI_UINT64  slice;
+  BLI_UINT32  slices;
+  BLI_UINT32  offs;
+  BLI_UINT32  len;
+  BLI_UINT32  crc;
+  BLI_UINT32  crc_calc;
+  BLI_BOOL    uncorr_error;
+  BLI_BOOL    corr_error;
+  BLI_BOOL    crc_error;
+  BLI_BOOL    eccerased;
+  BLI_BOOL    page_used;
+  BLI_UINT32  *check;
+  BLI_UINT32  *sparebuff;
+  BLI_INT32   result;
+  BLI_UINT32  i,j;
+  #if defined(BCHP_NAND_READ_ERROR_COUNT)
+  BLI_INT32   errorcount;
+  BLI_INT32   last_errorcount;
+  #endif
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check the unit number, offset and length are legal */
+
+  #if PARAM_CHECK
+  if (unit >= unit_count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+
+  if (offset >= unit_size)
+  {
+    return(NDR_ILLEGAL_OFFSET);
+  }
+
+  if ((length == 0) || (length > unit_size))
+  {
+    return(NDR_ILLEGAL_LENGTH);
+  }
+
+  if ((offset + length) > unit_size)
+  {
+    return(NDR_CANT_CROSS_BOUNDARY);
+  }
+
+  if (flags & NDR_FLAGS_LONGREADWRITE)
+  {
+    if ( (offset != 0) || ((length % NAND_CACHE_SIZE) != 0) )
+    {
+      return(NDR_ILLEGAL_PARAMETER);
+    }
+  }
+
+  #endif
+
+  /* Calculate the start address and offset in NAND */
+
+  start_offs     = (unit * unit_size) + offset;
+  slice          = start_offs / NAND_CACHE_SIZE;
+  offs           = start_offs % NAND_CACHE_SIZE;
+  source_address = (slice * NAND_CACHE_SIZE);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    return(result);
+  }
+
+  /* Set the destination address */
+
+  dest_address = (BLI_UINT32) data;
+
+  /* Calculate the number of slices we need to read */
+
+  slices = length / NAND_CACHE_SIZE;
+  slices += ((length % NAND_CACHE_SIZE) + offs + (NAND_CACHE_SIZE - 1)) / NAND_CACHE_SIZE;
+
+  /* Clear the correctable / unncorrectable error registers */
+
+  BCHP_REG(BCHP_NAND_ECC_CORR_ADDR)     = 0;
+  BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_ADDR)      = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR)  = 0;
+
+  /* Clear the last two extended spare area read words (in case 27bye spare area) */
+
+  BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C) = 0xffffffff;
+
+  /* Pointer to spare buffer (dwords) */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  /* Read the slices */
+
+  uncorr_error = FALSE;
+  corr_error   = FALSE;
+  crc_error    = FALSE;
+
+  nd_info.ECC_ErrorBits = 0;
+
+  for (i = 0; i < slices; i++)
+  {
+    /* Read the READ_ERROR_COUNT register */
+
+    #if defined(BCHP_NAND_READ_ERROR_COUNT)
+    last_errorcount = BCHP_REG(BCHP_NAND_READ_ERROR_COUNT);
+    #endif
+
+    /* Calculate the length for this slice */
+
+    if (length > (NAND_CACHE_SIZE - offs))
+    {
+      len = (NAND_CACHE_SIZE - offs);
+    }
+    else
+    {
+      len = length;
+    }
+
+    /* Set Base Address */
+
+    BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = source_address & 0xffffffff;
+    BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64(source_address, 32) | cs_ext_select;
+
+    /* Tell the controller to read the data */
+
+    BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PAGE_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+    /* Wait for controller ready */
+
+    result = wait_ready();
+
+    if (result != NDR_SUCCESS)
+    {
+      return(result);
+    }
+
+    /* How many bits in error? */
+
+    #if defined(BCHP_NAND_READ_ERROR_COUNT)
+    errorcount = BCHP_REG(BCHP_NAND_READ_ERROR_COUNT);
+    errorcount -= last_errorcount;
+    if (errorcount < 0) errorcount = 0;
+    if (errorcount > nd_info.ECC_Bits) errorcount = nd_info.ECC_Bits;
+    if (errorcount > nd_info.ECC_ErrorBits) nd_info.ECC_ErrorBits = (BLI_UINT32)errorcount;
+    #endif
+
+    /* Now we copy the data from the slice cache ...
+
+       - We leave crcsource set up for the CRC routine
+
+       - We clear offs after the transfer as it is only needed for
+         the first slice
+
+       - If the destination is mislaigned OR we're doing a partial
+         slice then we have to use a slow byte transfer!              */
+
+    if ((dest_address & 3) || (offs) || (len != NAND_CACHE_SIZE))
+    {
+      /* Transfer to aligned buffer for the CRC routine as we don't
+         want to read the controller cache twice as it's much slower
+         than normal memory!!                                        */
+
+      crc_source = (BLI_UINT8*)&pagebuffer_r[0];
+      memcopy32(crc_source, (BLI_UINT8*)PHYS_TO_KSEG1(NAND_CACHE_BASE), NAND_CACHE_SIZE);
+
+      /* Copy from the pagebuffer back to the user */
+
+      memcopy08((BLI_UINT8*)dest_address, (BLI_UINT8*)&pagebuffer_r[offs], len);
+    }
+    else
+    {
+      crc_source = (BLI_UINT8*)dest_address;
+      memcopy32(crc_source, (BLI_UINT8*)PHYS_TO_KSEG1(NAND_CACHE_BASE), NAND_CACHE_SIZE);
+    }
+
+    /* Transfer the data from the spare holding registers */
+
+    sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0));
+    sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4));
+    sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8));
+    sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C));
+    if (spare_area_size > 16)
+    {
+      #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10)
+      sparebuff[4] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10));
+      sparebuff[5] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14));
+      sparebuff[6] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18));
+      sparebuff[7] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C));
+      #endif
+    }
+
+    /* Copy the data back to the user if in "read long" mode */
+
+    if (flags & NDR_FLAGS_LONGREADWRITE)
+    {
+      if (spare_area_size == 16)
+      {
+        memcopy08((BLI_UINT8*)(dest_address + len), &sparebuffer, 16);
+        dest_address += 16;
+      }
+      else
+      {
+        memcopy08((BLI_UINT8*)(dest_address + len), &sparebuffer, 32);
+        dest_address += 32;
+      }
+    }
+
+    /* Was the page used marker set? */
+
+    page_used = false;
+
+    if (flags & NDR_FLAGS_USEDMARKER)
+    {
+      b = sparebuffer[nand_data_valid_offset];
+      if ((b >= 0xf0) && (b <= 0xf3)) page_used = true;
+    }
+    else
+    {
+      page_used = true;
+    }
+
+    if (pageused) *pageused = page_used;
+
+    /* Check the CRC */
+
+    if ((flags & NDR_FLAGS_CRC) && (page_used))
+    {
+      crc  = sparebuffer[nand_data_crc32_offset + 0];
+      crc <<= 8;
+      crc |= sparebuffer[nand_data_crc32_offset + 1];
+      crc <<= 8;
+      crc |= sparebuffer[nand_data_crc32_offset + 2];
+      crc <<= 8;
+      crc |= sparebuffer[nand_data_crc32_offset + 3];
+
+      crc_calc = calc_crc32(crc_source, 0, nand_crc_table, NAND_CACHE_SIZE);
+
+      if (crc != crc_calc)
+      {
+        crc_error = TRUE;
+      }
+    }
+
+    /* Advance the source and destination addresses, decrement the length
+       also clear offset (offs) as it is only needed for the first loop   */
+
+    source_address += NAND_CACHE_SIZE;
+    dest_address   += len;
+    length         -= len;
+    offs            = 0;
+
+    if (nd_info.ECC_Enabled)
+    {
+      /* Check for correctable error */
+
+      if ((BCHP_REG(BCHP_NAND_ECC_CORR_ADDR) != 0) || (BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) != 0))
+      {
+        BCHP_REG(BCHP_NAND_ECC_CORR_ADDR) = 0;
+        BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) = 0;
+        corr_error = TRUE;
+      }
+
+      /* Check for uncorrectable error */
+
+      if ((BCHP_REG(BCHP_NAND_ECC_UNC_ADDR) != 0) || (BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR) != 0))
+      {
+        BCHP_REG(BCHP_NAND_ECC_UNC_ADDR) = 0;
+        BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR) = 0;
+
+        /* Only do more checks if we know we've used the page! */
+
+        if (page_used)
+        {
+          /* Fix BCM's hardware bug (version 3 controllers onwards)
+
+             The docs say a page is considered erased if the ECC bytes and
+             the data area are all set to 0xFF, other spare area bytes are
+             not considered. The only problem is that this is bobbins and
+             if any other spare area byte is set then you do in fact get an
+             uncorrectable error.  This is a problem for JFFS2 (as far as
+             I can remember) so we're going to have to do this hack :(     */
+
+          if (BCHP_REG(BCHP_NAND_REVISION) >= 0x0300)
+          {
+            eccerased = FALSE;
+
+            /* Check the ECC bytes are erased! */
+
+            switch(ecc_spare_area_layout)
+            {
+              case NDR_LAYOUT_HAMMING_16B_SPARE:
+              {
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4) & 0xffff) == 0xffff) &&
+                     ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8) & 0xff000000) == 0xff000000) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              case NDR_LAYOUT_BCH4_16B_SPARE:
+              {
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8) & 0x00ffffff) == 0x00ffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C) == 0xffffffff) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              /* Dont build the stuff below if this register doesnt exist! */
+
+              #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10)
+
+              case NDR_LAYOUT_BCH8_27B_SPARE:
+              {
+
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C) & 0x00ffffff) == 0x00ffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14) == 0xffffffff) &&
+                     ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) & 0xffffff00) == 0xffffff00) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              case NDR_LAYOUT_BCH8_32B_SPARE:
+              {
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10) & 0x0000ffff) == 0x0000ffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C) == 0xffffffff) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              case NDR_LAYOUT_BCH12_27B_SPARE:
+              {
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4) & 0x0000ffff) == 0x0000ffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8)  == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C)  == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14) == 0xffffffff) &&
+                     ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) & 0xffffff00) == 0xffffff00) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              case NDR_LAYOUT_BCH12_32B_SPARE:
+              {
+                if ( ((BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8) & 0x000000ff) == 0x000000ff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C)  == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18) == 0xffffffff) &&
+                      (BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C) == 0xffffffff) )
+                {
+                  eccerased = TRUE;
+                }
+              }
+              break;
+
+              #endif /* #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10) */
+            }
+
+            /* If the ECC bytes seem to be erased correctly, check the data area */
+
+            if (eccerased)
+            {
+              check = (BLI_UINT32*)PHYS_TO_KSEG1(NAND_CACHE_BASE);
+
+              j  = (NAND_CACHE_SIZE / 4);
+              while (j--)
+              {
+                /* Whoops, unerased byte, error is genuine */
+
+                if (*check++ != 0xffffffff)
+                {
+                  uncorr_error = TRUE;
+                  break;
+                }
+              }
+            }
+
+            /* The ECC bytes were not erased, error is genuine */
+
+            else
+            {
+              uncorr_error = TRUE;
+            }
+
+          } /* if (BCHP_REG(BCHP_NAND_REVISION) >= 0x0300) */
+
+          else
+          {
+            /* Must be genuine */
+            uncorr_error = TRUE;
+          }
+
+        } /* if (page_used) */
+
+      } /* if ((BCHP_REG(BCHP_NAND_ECC_UNC_ADDR) != 0) || (BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR) != 0)) */
+
+    } /* if (nd_info.ECC_Enabled) */
+
+  } /* for (i = 0; i < slices; i++) */
+
+  /* Return if crc/correctable/uncorrectable error detected */
+
+  if ((uncorr_error) || (crc_error))
+  {
+    return(NDR_UNCORRECTABLE_ERROR);
+  }
+
+  if (corr_error)
+  {
+    return(NDR_CORRECTABLE_ERROR);
+  }
+
+  /* Return success */
+
+  return(NDR_SUCCESS);
+}
+
+
+/**************************
+ * Write a block or page  *
+ **************************/
+
+/* Entry   : unit_size - Size of a block or page
+             num_units - The number of blocks or pages on the device
+             unit      - The block or page number to start at
+             data      - Source address
+             offset    - Offset within the block or page to begin writing from
+             length    - The number of bytes to write
+
+   Returns : NDR error code (see header file)
+
+   Notes   : If the source address is misaligned then performance will suffer. */
+
+static NDR_ERROR write_nand(BLI_UINT64 unit_size, BLI_UINT32 unit_count, BLI_UINT32 unit, BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags)
+{
+  /* Locals */
+
+  BLI_UINT32  source_address_wr;
+  BLI_UINT32  source_address_rd;
+  BLI_UINT64  dest_address;
+  BLI_UINT64  start_offs;
+  BLI_UINT64  slice;
+  BLI_UINT32  slices;
+  BLI_UINT32  source;
+  BLI_UINT32  offs;
+  BLI_UINT32  len;
+  BLI_UINT32  llen;
+  BLI_UINT32  clen;
+  BLI_UINT32  crc;
+  BLI_UINT32  status;
+  BLI_UINT32  *clear;
+  BLI_UINT32  *sparebuff;
+  BLI_INT32   result;
+  BLI_BOOL    uncorr_error;
+  BLI_BOOL    corr_error;
+  BLI_UINT32  i,j,k;
+
+  /* Bail if the driver is not initialised */
+
+  if (!nand_driver_initialised)
+  {
+    return(NDR_NOT_INITIALISED);
+  }
+
+  /* Check the unit number, offset and length are legal */
+
+  #if PARAM_CHECK
+  if (unit >= unit_count)
+  {
+    return(NDR_ILLEGAL_BLOCK_OR_PAGE);
+  }
+
+  if (offset >= unit_size)
+  {
+    return(NDR_ILLEGAL_OFFSET);
+  }
+
+  if ((length == 0) || (length > unit_size))
+  {
+    return(NDR_ILLEGAL_LENGTH);
+  }
+
+  if ((offset + length) > unit_size)
+  {
+    return(NDR_CANT_CROSS_BOUNDARY);
+  }
+
+  if (flags & NDR_FLAGS_LONGREADWRITE)
+  {
+    if ( (offset != 0) || ((length % NAND_CACHE_SIZE) != 0) )
+    {
+      return(NDR_ILLEGAL_PARAMETER);
+    }
+  }
+  #endif
+
+  /* Deactivate SYNCSPAREONWRITE flag if ECC is hamming */
+
+  if (ecctype == NDR_ECC_TYPE_HAMMING)
+  {
+    flags &= ~NDR_FLAGS_SYNCSPAREONWRITE;
+  }
+
+  /* Calculate the start address and offset in NAND */
+
+  start_offs   = (unit * unit_size) + offset;
+  slice        = lrshift64(start_offs, virt_page_shift);
+  offs         = start_offs & virt_page_mask;
+  dest_address = (slice * virt_page_size);
+
+  /* Ensure controller is ready before we start */
+
+  result = wait_ready();
+
+  if (result != NDR_SUCCESS)
+  {
+    return(result);
+  }
+
+  /* Set the destination address */
+
+  source_address_wr = (BLI_UINT32) data;
+  source_address_rd = (BLI_UINT32) data;
+
+  /* Initially dont touch the spare area */
+
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_0) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_4) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_8) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_C) = 0xffffffff;
+  #if defined(BCHP_NAND_SPARE_AREA_WRITE_OFS_10)
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_10) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_14) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_18) = 0xffffffff;
+  BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_1C) = 0xffffffff;
+  #endif
+
+  /* Get Pointer to spare buffer (dwords) and pre-clear */
+
+  sparebuff = (BLI_UINT32*)&sparebuffer[0];
+
+  sparebuff[0] = 0xffffffff;
+  sparebuff[1] = 0xffffffff;
+  sparebuff[2] = 0xffffffff;
+  sparebuff[3] = 0xffffffff;
+  if (spare_area_size > 16)
+  {
+    sparebuff[4] = 0xffffffff;
+    sparebuff[5] = 0xffffffff;
+    sparebuff[6] = 0xffffffff;
+    sparebuff[7] = 0xffffffff;
+  }
+
+  /* Clear the correctable / uncorrectable error readback */
+
+  BCHP_REG(BCHP_NAND_ECC_CORR_ADDR)     = 0;
+  BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_ADDR)      = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR)  = 0;
+
+  /* Calculate the number of slices we need to write */
+
+  slices = length / virt_page_size;
+  slices += ((length % virt_page_size) + offs + (virt_page_size - 1)) / virt_page_size;
+
+  /* Write the slices */
+
+  for (i = 0; i < slices; i++)
+  {
+    /* Calculate the length for this slice */
+
+    if (length > (virt_page_size - offs))
+    {
+      len = (virt_page_size - offs);
+    }
+    else
+    {
+      len = length;
+    }
+
+    /* WRITE - Inner_loop */
+
+    llen = len;
+
+    for (j = 0; j < sub_pages_per_page; j++)
+    {
+      /* Are we writing less than the NAND_CACHE_SIZE? */
+
+      if (llen < NAND_CACHE_SIZE)
+      {
+        clen = llen;
+      }
+      else
+      {
+        clen = NAND_CACHE_SIZE;
+      }
+
+      llen -= NAND_CACHE_SIZE;
+
+      /* If source misaligned (or writing less than a page) then copy to aligned buffer */
+
+      if ((source_address_wr & 3) || (clen != NAND_CACHE_SIZE))
+      {
+        clear = (BLI_UINT32*)&pagebuffer_w[0];
+        k = virt_page_size / 16;
+
+        while (k--)
+        {
+          *clear++ = 0xffffffff;
+          *clear++ = 0xffffffff;
+          *clear++ = 0xffffffff;
+          *clear++ = 0xffffffff;
+        }
+        memcopy08((BLI_UINT8*)&pagebuffer_w[offs], (BLI_UINT8*)source_address_wr, clen);
+        source = (BLI_UINT32)&pagebuffer_w[0];
+      }
+      else
+      {
+        source = source_address_wr;
+      }
+
+      /* Set Base Address */
+
+      BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = (dest_address + (j * NAND_CACHE_SIZE)) & 0xFFFFFFFF;
+      BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64((dest_address + (j * NAND_CACHE_SIZE)), 32) | cs_ext_select;
+
+      /* Preload the spare area write registers */
+
+      if (flags & NDR_FLAGS_LONGREADWRITE)
+      {
+        if (spare_area_size == 16)
+        {
+          memcopy08(&sparebuffer[0], (BLI_UINT8*)source_address_wr + clen, 16);
+          source_address_wr += 16;
+        }
+        else
+        {
+          memcopy08(&sparebuffer[0], (BLI_UINT8*)source_address_wr + clen, 32);
+          source_address_wr += 32;
+        }
+      }
+
+      /* Sync spare area from device - This flag CANNOT be used if NDR_FLAGS_LONGREADWRITE is set */
+
+      else
+      {
+        if (flags & NDR_FLAGS_SYNCSPAREONWRITE)
+        {
+          /* Tell the controller to read the spares */
+
+          BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_SPARE_AREA_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+          /* Wait for controller ready */
+
+          result = wait_ready();
+
+          if (result != NDR_SUCCESS)
+          {
+            return(result);
+          }
+
+          /* Transfer the data to the buffer */
+
+          sparebuff[0] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_0));
+          sparebuff[1] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_4));
+          sparebuff[2] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_8));
+          sparebuff[3] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_C));
+          if (spare_area_size > 16)
+          {
+            #if defined(BCHP_NAND_SPARE_AREA_READ_OFS_10)
+            sparebuff[4] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_10));
+            sparebuff[5] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_14));
+            sparebuff[6] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_18));
+            sparebuff[7] = force_native_endian(BCHP_REG(BCHP_NAND_SPARE_AREA_READ_OFS_1C));
+            #endif
+          }
+        }
+      }
+
+      /* Increment source address now! */
+
+      source_address_wr += NAND_CACHE_SIZE;
+
+      /* Now copy the data to the slice cache - MUST USE WORD TRANSFERS! */
+
+      memcopy32((BLI_UINT8*)PHYS_TO_KSEG1(NAND_CACHE_BASE), (BLI_UINT8*)source, NAND_CACHE_SIZE);
+
+      if ((flags & NDR_FLAGS_CRC) || (flags & NDR_FLAGS_USEDMARKER) || (flags & NDR_FLAGS_LONGREADWRITE) || (flags & NDR_FLAGS_SYNCSPAREONWRITE))
+      {
+        /* Generate the CRC - Place in spare area */
+
+        if (flags & NDR_FLAGS_CRC)
+        {
+          crc = calc_crc32((BLI_UINT8*)source, 0, nand_crc_table, NAND_CACHE_SIZE);
+          sparebuffer[nand_data_crc32_offset + 3] = (crc >> 0)  & 0xff;
+          sparebuffer[nand_data_crc32_offset + 2] = (crc >> 8)  & 0xff;
+          sparebuffer[nand_data_crc32_offset + 1] = (crc >> 16) & 0xff;
+          sparebuffer[nand_data_crc32_offset + 0] = (crc >> 24) & 0xff;
+        }
+
+        /* Set PAGEUSED */
+
+        if (flags & NDR_FLAGS_USEDMARKER)
+        {
+          sparebuffer[nand_data_valid_offset] = 0xf0 + j;
+        }
+
+        BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_0) = force_native_endian(sparebuff[0]);
+        BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_4) = force_native_endian(sparebuff[1]);
+        BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_8) = force_native_endian(sparebuff[2]);
+        BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_C) = force_native_endian(sparebuff[3]);
+        if (spare_area_size > 16)
+        {
+          #if defined(BCHP_NAND_SPARE_AREA_WRITE_OFS_10)
+          BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_10) = force_native_endian(sparebuff[4]);
+          BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_14) = force_native_endian(sparebuff[5]);
+          BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_18) = force_native_endian(sparebuff[6]);
+          BCHP_REG(BCHP_NAND_SPARE_AREA_WRITE_OFS_1C) = force_native_endian(sparebuff[7]);
+          #endif
+        }
+      }
+
+      /* Tell the controller to write the data */
+
+      BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PROGRAM_PAGE << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+      /* Wait for controller ready */
+
+      result = wait_ready();
+
+      if (result != NDR_SUCCESS)
+      {
+        return(result);
+      }
+
+      /* Check for error */
+
+      status = BCHP_REG(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_FLASH_STATUS_MASK;
+
+      if (status & DEVICE_STATUS_ERROR)
+      {
+        return(NDR_DEVICE_PROGRAM_ERROR);
+      }
+
+      #ifdef CHECK_WRITEPROTECT
+      if (!(status & DEVICE_STATUS_NOT_WRITE_PROTECT))
+      {
+        return(NDR_WRITE_PROTECTED);
+      }
+      #endif
+    } /* for (j = 0; j < sub_pages_per_page; j++) */
+
+    /* Verify */
+
+    if (flags & NDR_FLAGS_VERIFY)
+    {
+      corr_error = false;
+      uncorr_error = false;
+      llen = len;
+
+      for (j = 0; j < sub_pages_per_page; j++)
+      {
+        /* Are we writing less than the NAND_CACHE_SIZE? */
+
+        if (llen < NAND_CACHE_SIZE)
+        {
+          clen = llen;
+        }
+        else
+        {
+          clen = NAND_CACHE_SIZE;
+        }
+
+        llen -= NAND_CACHE_SIZE;
+
+        /* Set Base Address */
+
+        BCHP_REG(BCHP_NAND_CMD_ADDRESS)     = (dest_address + (j * NAND_CACHE_SIZE)) & 0xffffffff;
+        BCHP_REG(BCHP_NAND_CMD_EXT_ADDRESS) = lrshift64((dest_address + (j * NAND_CACHE_SIZE)), 32) | cs_ext_select;
+
+        /* Tell the controller to read the data */
+
+        BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_PAGE_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+
+        /* Wait for controller ready */
+
+        result = wait_ready();
+
+        if (result != NDR_SUCCESS)
+        {
+          return(result);
+        }
+
+        /* Set corr/uncorr error vars */
+
+        if ((BCHP_REG(BCHP_NAND_ECC_CORR_ADDR) != 0) || (BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) != 0))
+        {
+          corr_error = TRUE;
+        }
+
+        if ((BCHP_REG(BCHP_NAND_ECC_UNC_ADDR) != 0) || (BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR) != 0))
+        {
+          uncorr_error = TRUE;
+        }
+
+        /* Now Check we got back what we wrote */
+
+        if ((source_address_rd & 3) || (offs) || (clen != NAND_CACHE_SIZE))
+        {
+          memcopy32(&pagebuffer_r, (BLI_UINT8*)PHYS_TO_KSEG1(NAND_CACHE_BASE), clen);
+
+          if (!memcompare08((BLI_UINT8*)source_address_rd, &pagebuffer_r[0], clen))
+          {
+            return(NDR_DEVICE_VERIFY_ERROR);
+          }
+        }
+        else
+        {
+          if (!memcompare32((BLI_UINT8*)source_address_rd, (BLI_UINT8*)PHYS_TO_KSEG1(NAND_CACHE_BASE), NAND_CACHE_SIZE))
+          {
+            return(NDR_DEVICE_VERIFY_ERROR);
+          }
+        }
+
+        /* Fix the source address */
+
+        source_address_rd += NAND_CACHE_SIZE;
+
+        if (flags & NDR_FLAGS_LONGREADWRITE)
+        {
+          if (spare_area_size == 16)
+          {
+            source_address_rd += 16;
+          }
+          else
+          {
+            source_address_rd += 32;
+          }
+        }
+
+        /* IF ECC is enabled check the hardware for errors */
+
+        if (nd_info.ECC_Enabled)
+        {
+          if ((corr_error) || (uncorr_error))
+          {
+            BCHP_REG(BCHP_NAND_ECC_CORR_ADDR) = 0;
+            BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) = 0;
+            BCHP_REG(BCHP_NAND_ECC_UNC_ADDR) = 0;
+            BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR) = 0;
+            return(NDR_DEVICE_ECC_ERROR);
+          }
+        }
+
+      } /* for (j = 0; j < sub_pages_per_page; j++) */
+    } /* if (verify) */
+
+    /* Fix source address offset and length, increment dest address */
+
+    dest_address   += virt_page_size;
+    length         -= len;
+    offs            = 0;
+
+  } /* for (i = 0; i < slices; i++) */
+
+  /* Return success */
+
+  return(NDR_SUCCESS);
+}
+
+
+/****************************************************************************
+ *                               Subroutines                                *
+ ****************************************************************************/
+
+/***********************
+ * Initialise Hardware *
+ ***********************/
+
+/* Entry   : Pointer to variable to recieve NAND_CONFIG
+
+   Returns : TRUE (success), FALSE (failed)
+
+   Notes   : This does all the nasty setup to get the NAND device up and running */
+
+static BLI_BOOL initialise_hardware(BLI_UINT32 *config)
+{
+  /* Locals */
+
+  volatile BLI_INT32  delay;
+  volatile BLI_UINT32 reg;
+  BLI_BOOL            valid;
+  #ifdef FIX_BROKEN_BCM_NAND_AUTODETECT
+  volatile BLI_UINT32 dev_id;
+  BLI_BOOL            found;
+  BLI_INT32           result;
+  BLI_INT32           i;
+  #endif
+  #if defined(FORCE_ECC_SPARE_AREA_LAYOUT) || defined (READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE)
+  BLI_UINT32          brcmecc;
+  BLI_UINT32          v1;
+  BLI_UINT32          v2;
+  #endif
+
+  /*-----------------------------------------------------------------------*/
+
+  /* The first thing to do is to determine the geometry
+     of the flash device, on older controllers this is
+     automatic, on newer 40nm+ controllers this has to
+     be done the hard way :(                            */
+
+  /* Set the chip select */
+
+  reg = BCHP_REG(BCHP_NAND_CS_NAND_SELECT);
+
+  #ifdef SYSTEM_IS_NAND_ONLY
+  reg |= BCHP_NAND_CS_NAND_SELECT_EBI_CS_0_SEL_MASK;
+  #else
+  reg |= BCHP_NAND_CS_NAND_SELECT_EBI_CS_1_SEL_MASK;
+  #endif
+
+  BCHP_REG(BCHP_NAND_CS_NAND_SELECT) = reg;
+
+  /* Request Autodetect of flash chip ID and size */
+
+  reg  = BCHP_REG(BCHP_NAND_CS_NAND_SELECT);
+  reg  |= BCHP_NAND_CS_NAND_SELECT_AUTO_DEVICE_ID_CONFIG_MASK;
+
+  BCHP_REG(BCHP_NAND_CS_NAND_SELECT) = reg;
+
+  /* Wait 20 milliseconds for autodetect to complete */
+
+  delay = DELAY_ONE_MSEC * 20;
+  while (delay--) reg = BCHP_REG(REG_CONFIG);
+
+  #ifdef FIX_BROKEN_BCM_NAND_AUTODETECT
+
+  /* This next code is needed for newer 40nm (and later)
+     controllers as the autodetect is seriously broken!
+
+     We use the CHIP ID to populate the NAND_CONFIG register
+     from a table of known flash devices, if your device isn't in
+     the table then please add an entry into the table and check
+     this file back in (on the head please, no branches) also
+     drop me an email to tell me you've done this :)               */
+
+  BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_FLASH_RESET << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+  result = wait_ready();
+  if (result != NDR_SUCCESS) return(FALSE);
+
+  BCHP_REG(BCHP_NAND_CMD_START) = BCHP_NAND_CMD_START_OPCODE_DEVICE_ID_READ << BCHP_NAND_CMD_START_OPCODE_SHIFT;
+  result = wait_ready();
+  if (result != NDR_SUCCESS) return(FALSE);
+
+  dev_id = BCHP_REG(BCHP_NAND_FLASH_DEVICE_ID) >> 16;
+
+  found = false;
+  for (i = 0; i < NUM_FLASH_DEVICES; i++)
+  {
+    if (flash_parameter_table[i].dev_id == dev_id)
+    {
+      found = true;
+      reg = BCHP_REG(REG_CONFIG);
+      reg &= ~(BCHP_NAND_CONFIG_BLOCK_SIZE_MASK | BCHP_NAND_CONFIG_DEVICE_SIZE_MASK | BCHP_NAND_CONFIG_PAGE_SIZE_MASK);
+      reg |= flash_parameter_table[i].config;
+      BCHP_REG(REG_CONFIG) = reg;
+      break;
+    }
+  }
+
+  if (!found) return(FALSE);
+
+  #endif /* FIX_BROKEN_BCM_NAND_AUTODETECT */
+
+  /*-----------------------------------------------------------------------*/
+
+  /* Now we read the ECC type and spare area size and use
+     this to calculate 'ecc_spare_area_layout' for later  */
+
+  #if !defined(FORCE_ECC_SPARE_AREA_LAYOUT) && !defined(READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE)
+
+  #if defined(BCHP_NAND_ACC_CONTROL_ECC_LEVEL_MASK)
+
+  reg   = BCHP_REG(REG_ACC_CONTROL);
+  reg  &= BCHP_NAND_ACC_CONTROL_ECC_LEVEL_MASK;
+  reg >>= BCHP_NAND_ACC_CONTROL_ECC_LEVEL_SHIFT;
+
+  switch(reg)
+  {
+    case 4:
+      ecctype = NDR_ECC_TYPE_BCH4;
+      errorbits = 4;
+    break;
+
+    case 8:
+      ecctype = NDR_ECC_TYPE_BCH8;
+      errorbits = 8;
+    break;
+
+    case 12:
+      ecctype = NDR_ECC_TYPE_BCH12;
+      errorbits = 12;
+    break;
+
+    case 15:
+      ecctype = NDR_ECC_TYPE_HAMMING;
+      errorbits = 1;
+    break;
+
+    default:
+      return(FALSE);
+    break;
+  }
+
+  #else
+
+  ecctype = NDR_ECC_TYPE_HAMMING;
+  errorbits = 1;
+
+  #endif
+
+  /* Get the spare area size */
+
+  #if defined(BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_MASK)
+
+  reg   = BCHP_REG(REG_ACC_CONTROL);
+  reg  &= BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_MASK;
+  reg >>= BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_SHIFT;
+
+  spare_area_size = reg;
+
+  #else
+
+  spare_area_size = 16;
+
+  #endif
+
+  /* Now check to see if the above correponds to one
+     of our supported modes!
+
+     We only check 16/27 byte spare area size here
+     as thats all you can select with the strapping
+     resistors (on NOR + NAND boxes you always get
+     hamming + 16 byte spare area)
+                                                    */
+  valid = false;
+
+  if ((ecctype == NDR_ECC_TYPE_HAMMING) && (spare_area_size == 16))
+  {
+    ecc_spare_area_layout = NDR_LAYOUT_HAMMING_16B_SPARE;
+    valid = true;
+  }
+
+  if ((ecctype == NDR_ECC_TYPE_BCH4) && (spare_area_size == 16))
+  {
+    ecc_spare_area_layout = NDR_LAYOUT_BCH4_16B_SPARE;
+    valid = true;
+  }
+
+  if ((ecctype == NDR_ECC_TYPE_BCH8) && (spare_area_size == 27))
+  {
+    ecc_spare_area_layout = NDR_LAYOUT_BCH8_27B_SPARE;
+    valid = true;
+  }
+
+
+  if ((ecctype == NDR_ECC_TYPE_BCH12) && (spare_area_size == 27))
+  {
+    ecc_spare_area_layout = NDR_LAYOUT_BCH12_27B_SPARE;
+    valid = true;
+  }
+
+  if (!valid) return(false);
+
+  #endif /* #ifndef FORCE_ECC_SPARE_AREA_LAYOUT */
+
+  /*-----------------------------------------------------------------------*/
+
+  /* If we're NOR+NAND then we can force a new ECC type and Spare
+     area layout here, as otherwise we'll be in Hamming mode with
+     a 16 byte spare area (which is no use if we want BCH ECC) */
+
+  #if defined(FORCE_ECC_SPARE_AREA_LAYOUT) || defined (READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE)
+
+  #ifdef READ_ECC_SPARE_AREA_LAYOUT_FROM_COOKIE
+
+  reg = BCHP_REG(BCHP_NAND_SEMAPHORE);
+
+ 	//printk("-- SETTING LAYOUT FROM COOKIE (0x%08x=0x%02x) -- \n", (0xb0000000 | BCHP_NAND_SEMAPHORE), reg);
+
+  if ((reg & 0xc0) != 0xc0)
+  {
+    return(false);
+  }
+
+  v1  = reg & 7;
+  v2  = (reg >> 3) & 7;
+  v2 ^=7;
+  if (v1 != v2)
+  {
+    return(false);
+  }
+
+  ecc_spare_area_layout = v1;
+
+  #else
+
+  ecc_spare_area_layout = FORCE_ECC_SPARE_AREA_LAYOUT;
+
+  #endif
+
+  switch(ecc_spare_area_layout)
+  {
+    case  NDR_LAYOUT_HAMMING_16B_SPARE:
+      brcmecc = 15;
+      ecctype = NDR_ECC_TYPE_HAMMING;
+      spare_area_size = 16;
+      errorbits = 1;
+    break;
+
+    case  NDR_LAYOUT_BCH4_16B_SPARE:
+      brcmecc = 4;
+      ecctype = NDR_ECC_TYPE_BCH4;
+      spare_area_size = 16;
+      errorbits = 4;
+    break;
+
+    case  NDR_LAYOUT_BCH8_27B_SPARE:
+      brcmecc = 8;
+      ecctype = NDR_ECC_TYPE_BCH8;
+      spare_area_size = 27;
+      errorbits = 8;
+    break;
+
+    case  NDR_LAYOUT_BCH8_32B_SPARE:
+      brcmecc = 8;
+      ecctype = NDR_ECC_TYPE_BCH8;
+      spare_area_size = 32;
+      errorbits = 8;
+    break;
+
+    case  NDR_LAYOUT_BCH12_27B_SPARE:
+      brcmecc = 12;
+      ecctype = NDR_ECC_TYPE_BCH12;
+      spare_area_size = 27;
+      errorbits = 12;
+    break;
+
+    case  NDR_LAYOUT_BCH12_32B_SPARE:
+      brcmecc = 12;
+      ecctype = NDR_ECC_TYPE_BCH12;
+      spare_area_size = 32;
+      errorbits = 12;
+    break;
+
+    default:
+      return(false);
+    break;
+  }
+
+  /* Sanity check that the fields exist! */
+
+  #if !defined(BCHP_NAND_ACC_CONTROL_ECC_LEVEL_MASK) || !defined(BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_MASK)
+  #error ERROR - No Fields in NAND_ACC_CONTROL for ECC level / Spare area size
+  #endif
+
+  /* Now set the Level / Spare area size */
+
+  reg = BCHP_REG(REG_ACC_CONTROL);
+
+  reg &= ~BCHP_NAND_ACC_CONTROL_ECC_LEVEL_MASK;
+  reg |= brcmecc << BCHP_NAND_ACC_CONTROL_ECC_LEVEL_SHIFT;
+
+  #if defined(BCHP_NAND_ACC_CONTROL_ECC_LEVEL_0_MASK)
+  reg &= ~BCHP_NAND_ACC_CONTROL_ECC_LEVEL_0_MASK;
+  reg |= brcmecc << BCHP_NAND_ACC_CONTROL_ECC_LEVEL_0_SHIFT;
+  #endif
+
+  reg &= ~BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_MASK;
+  reg |= spare_area_size << BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_SHIFT;
+
+  #if defined(BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_0_MASK)
+  reg &= ~BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_0_MASK;
+  reg |= spare_area_size << BCHP_NAND_ACC_CONTROL_SPARE_AREA_SIZE_0_SHIFT;
+  #endif
+
+  BCHP_REG(REG_ACC_CONTROL) = reg;
+
+  #endif /* FORCE_ECC_SPARE_AREA_LAYOUT */
+
+  /*-----------------------------------------------------------------------*/
+
+  /* Set the Correctable Error Threshold */
+
+  #if defined(BCHP_NAND_CORR_STAT_THRESHOLD)
+
+  reg = sparemaps[ecc_spare_area_layout].corr_stat_threshold;
+
+  #if !defined(SYSTEM_IS_NAND_ONLY) && defined(BCHP_NAND_CORR_STAT_THRESHOLD_CORR_STAT_THRESHOLD_CS1_SHIFT)
+
+  reg <<= BCHP_NAND_CORR_STAT_THRESHOLD_CORR_STAT_THRESHOLD_CS1_SHIFT;
+
+  #endif
+
+  BCHP_REG(BCHP_NAND_CORR_STAT_THRESHOLD) = reg;
+
+  #endif
+
+  /* Set The NAND Access Control */
+
+  reg  =  BCHP_REG(REG_ACC_CONTROL);
+
+  reg |=  BCHP_NAND_ACC_CONTROL_RD_ECC_EN_MASK;         /* Enable Read ECC for blocks 1-?             */
+  reg |=  BCHP_NAND_ACC_CONTROL_WR_ECC_EN_MASK;         /* Enable write ECC for all blocks            */
+  #if defined(BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK)
+  reg |=  BCHP_NAND_ACC_CONTROL_RD_ECC_BLK0_EN_MASK;    /* Enable Read ECC for block 0                */
+  #endif
+  reg |=  BCHP_NAND_ACC_CONTROL_WR_PREEMPT_EN_MASK;     /* Enable Pre-emption                         */
+  reg |=  BCHP_NAND_ACC_CONTROL_PAGE_HIT_EN_MASK;       /* Enable page hit detection                  */
+  #if defined(BCHP_NAND_ACC_CONTROL_RD_ERASED_ECC_EN_MASK)
+  reg &= ~BCHP_NAND_ACC_CONTROL_RD_ERASED_ECC_EN_MASK;  /* Reading erased blocks DOES NOT cause error */
+  #endif
+  #if defined(BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK)
+  #ifdef FORCE_2K_PAGEWRITES
+  reg &= ~BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK;   /* New controller behaviour                   */
+  reg &= ~BCHP_NAND_ACC_CONTROL_FAST_PGM_RDIN_MASK;     /* Disable program page random data input     */
+  //reg &= ~BCHP_NAND_ACC_CONTROL_PAGE_HIT_EN_MASK;       /* Disable page hit detection                 */
+  #else
+  reg |= BCHP_NAND_ACC_CONTROL_PARTIAL_PAGE_EN_MASK;    /* Old controller behaviour                   */
+  reg |= BCHP_NAND_ACC_CONTROL_FAST_PGM_RDIN_MASK;      /* Enable program page random data input      */
+  #endif
+  #endif
+
+  BCHP_REG(REG_ACC_CONTROL) = reg;
+
+  /* Clear the correctable and uncorrectable addresses */
+
+  BCHP_REG(BCHP_NAND_ECC_CORR_ADDR)     = 0;
+  BCHP_REG(BCHP_NAND_ECC_CORR_EXT_ADDR) = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_ADDR)      = 0;
+  BCHP_REG(BCHP_NAND_ECC_UNC_EXT_ADDR)  = 0;
+
+  /* Clear the Address bus XORing */
+
+  BCHP_REG(BCHP_NAND_CS_NAND_XOR) = 0;
+
+  /* Disable chip select so we can use the slice cache directly
+
+     - Also sets cs_ext_select for later access                  */
+
+  reg = BCHP_REG(BCHP_NAND_CS_NAND_SELECT);
+  #ifdef SYSTEM_IS_NAND_ONLY
+  reg &= ~BCHP_NAND_CS_NAND_SELECT_EBI_CS_0_SEL_MASK;
+  BCHP_REG(BCHP_NAND_CS_NAND_SELECT) = reg | 0x100;
+  cs_ext_select = 0x00000000;
+  #else
+  reg &= ~BCHP_NAND_CS_NAND_SELECT_EBI_CS_1_SEL_MASK;
+  BCHP_REG(BCHP_NAND_CS_NAND_SELECT) = reg | 0x200;
+  cs_ext_select = 0x00010000;
+  #endif
+
+  /*-----------------------------------------------------------------------*/
+
+  /* Return the contents config register */
+
+  *config = BCHP_REG(REG_CONFIG);
+
+  return(TRUE);
+}
+
+
+/*****************************
+ * Wait for Controller ready *
+ *****************************/
+
+/* Entry   : ** NO ARGUMENTS **
+
+   Returns : either NDR_SUCCESS or DEVICE_NOT_READY
+
+   Notes   : We use a nice long timeout of approx 200 milliseconds which
+             is more than enough time for any NAND command to complete.  */
+
+static NDR_ERROR wait_ready(BLI_VOID)
+{
+  /* Locals */
+
+  BLI_INT32 delay;
+
+  /* Maximum wait time = 200 milliseconds */
+
+  delay = DELAY_ONE_MSEC * 200;
+
+  /* Wait for controller ready */
+
+  while (delay--)
+  {
+    if (BCHP_REG(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_CTLR_READY_MASK)
+    {
+      return(NDR_SUCCESS);
+    }
+  }
+
+  /* If we get here then we timed out */
+
+  return(NDR_DEVICE_NOT_READY);
+}
+
+
+/**********************
+ * Return Device Size *
+ **********************/
+
+static BLI_UINT64 get_device_size(BLI_UINT32 nand_config)
+{
+  BLI_UINT64 shft,size;
+  BLI_INT32  i;
+  shft = ((nand_config & BCHP_NAND_CONFIG_DEVICE_SIZE_MASK) >> BCHP_NAND_CONFIG_DEVICE_SIZE_SHIFT);
+  size = (4 * MEGA);
+  for (i = 0; i < shft; i++)
+  {
+    size += size;
+  }
+  return(size);
+}
+
+
+/*********************
+ * Return Block Size *
+ *********************/
+
+static BLI_INT32 get_block_size(BLI_UINT32 nand_config)
+{
+  switch((nand_config & BCHP_NAND_CONFIG_BLOCK_SIZE_MASK) >> BCHP_NAND_CONFIG_BLOCK_SIZE_SHIFT)
+  {
+    #if defined(BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_512KB)
+    case BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_512KB:
+      return  512 * 1024;
+    #endif
+
+    #if defined(BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_256KB)
+    case BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_256KB:
+      return  256 * 1024;
+    #endif
+
+    case BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_128KB:
+      return  128 * 1024;
+
+    case BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_16KB:
+      return  16 * 1024;
+
+    case BCHP_NAND_CONFIG_BLOCK_SIZE_BK_SIZE_8KB:
+      return  8 * 1024;
+
+    default:
+      return -1;
+  }
+}
+
+
+/********************
+ * Return Page Size *
+ ********************/
+
+static BLI_INT32 get_page_size(BLI_UINT32 nand_config)
+{
+  switch((nand_config & BCHP_NAND_CONFIG_PAGE_SIZE_MASK) >> BCHP_NAND_CONFIG_PAGE_SIZE_SHIFT)
+  {
+    case BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_512:
+      return 512;
+
+    case BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_2KB:
+      return 2 * 1024;
+
+    #if defined(BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_4KB)
+    case BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_4KB:
+      return 4 * 1024;
+    #endif
+
+    #if defined(BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_8KB)
+    case BCHP_NAND_CONFIG_PAGE_SIZE_PG_SIZE_8KB:
+      return 8 * 1024;
+    #endif
+
+    default:
+      return -1;
+  }
+}
+
+
+/********************************
+ * Force dword to native endian *
+ ********************************/
+
+/* To be more accurate, flip the word if needed so when you
+   store it in memory and cast a byte pointer to that address
+   the data is read back correctly                            */
+
+static BLI_UINT32 force_native_endian(BLI_UINT32 value)
+{
+  /* Locals */
+
+  BLI_UINT32 a,b,c,d;
+
+  /* Only flip if on a little endian system */
+
+  if (little_endian)
+  {
+    a = (value >> 24) & 0xff;
+    b = (value >> 16) & 0xff;
+    c = (value >> 8)  & 0xff;
+    d = (value)       & 0xff;
+    return((d << 24) | (c << 16) | (b << 8) | a);
+  }
+
+  /* System is big endian - Do nothing */
+
+  else
+  {
+    return(value);
+  }
+
+}
+
+
+/************
+ * MEMCOPY8 *
+ ************/
+
+/* Copies n bytes from source to dest
+
+   source and dest *MUST* be word aligned
+
+   ISSUES ...
+
+   - If the assembler version is used then You will get a warning from GCC when
+     this builds, if anyone knows how to fix this then please let me know!!!      */
+
+#if ASM_SPEEDUP
+
+static BLI_VOID __attribute__((__noinline__)) memcopy08(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len)
+{
+  __asm__ volatile
+  (
+    "__mcpy8loop: lbu     $8,(%1)                     \n"
+    "             sb      $8,(%0)                     \n"
+    "             addi    %1,1                        \n"
+    "             addi    %0,1                        \n"
+    "             addi    %2,-1                       \n"
+    "             bne     $0,%2,__mcpy8loop           \n"
+    "             nop                                 \n"
+    : /* returns void */ : "r"(dest), "r"(source), "r"(len) : "$8"
+  );
+}
+
+#else
+
+static BLI_VOID memcopy08(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len)
+{
+  BLI_UINT8 *d = (BLI_UINT8*)dest;
+  BLI_UINT8 *s = (BLI_UINT8*)source;
+
+  while(len--)
+  {
+    *d++ = *s++;
+  }
+}
+
+#endif
+
+
+/*************
+ * MEMCOPY32 *
+ *************/
+
+/* Copies len bytes from source to dest
+
+   len must be a multiple of 16 bytes (4 words)
+
+   source and dest *MUST* be word aligned
+
+   ISSUES ...
+
+   - If the assembler version is used then You will get a warning from GCC when
+     this builds, if anyone knows how to fix this then please let me know!!!      */
+
+#if ASM_SPEEDUP
+
+static BLI_VOID __attribute__((__noinline__)) memcopy32(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len)
+{
+  __asm__ volatile
+  (
+    "             srl     %2,%2,4                     \n" /* len / 16  */
+    "__mcpy32loop:lw      $8,0(%1)                    \n"
+    "             lw      $9,4(%1)                    \n"
+    "             lw      $10,8(%1)                   \n"
+    "             lw      $11,12(%1)                  \n"
+    "             sw      $8,0(%0)                    \n"
+    "             sw      $9,4(%0)                    \n"
+    "             sw      $10,8(%0)                   \n"
+    "             sw      $11,12(%0)                  \n"
+    "             addi    %1,16                       \n"
+    "             addi    %0,16                       \n"
+    "             addi    %2,-1                       \n"
+    "             bne     $0,%2,__mcpy32loop          \n"
+    "             nop                                 \n"
+    : /* returns void */ : "r"(dest), "r"(source), "r"(len) : "$8", "$9", "$10", "$11"
+  );
+}
+
+#else
+
+static BLI_VOID memcopy32(BLI_VOID *dest, BLI_VOID *source, BLI_UINT32 len)
+{
+  BLI_UINT32  *d  = (BLI_UINT32*)dest;
+  BLI_UINT32  *s  = (BLI_UINT32*)source;
+
+  len /= 16;
+
+  while(len--)
+  {
+    *d++ = *s++;
+    *d++ = *s++;
+    *d++ = *s++;
+    *d++ = *s++;
+  }
+}
+
+#endif
+
+
+/***************
+ * MEMCOMPARE8 *
+ ***************/
+
+/* Compares len bytes between source and dest
+
+   ISSUES ...
+
+   - If the assembler version is used then You will get a warning from GCC when
+     this builds, if anyone knows how to fix this then please let me know!!!      */
+
+#if ASM_SPEEDUP
+
+static BLI_BOOL __attribute__((__noinline__)) memcompare08(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len)
+{
+  BLI_BOOL result = NDR_SUCCESS;
+
+  __asm__ volatile
+  (
+    "             ori     %0,$0,0                     \n"
+    "__mcmp8loop: lbu     $8,(%1)                     \n"
+    "             lbu     $9,(%2)                     \n"
+    "             bne     $8,$9,__mcmp8out            \n"
+    "             addi    %1,1                        \n"
+    "             addi    %2,1                        \n"
+    "             addi    %3,-1                       \n"
+    "             bne     $0,%3,__mcmp8loop           \n"
+    "             nop                                 \n"
+    "             ori     %0,$0,1                     \n"
+    "__mcmp8out:                                      \n"
+    : "=r"(result) : "r"(source1), "r"(source2), "r"(len) : "$8", "$9"
+  );
+  return result = NDR_SUCCESS;
+}
+
+#else
+
+static BLI_BOOL memcompare08(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len)
+{
+  BLI_UINT8 *s1 = (BLI_UINT8*)source1;
+  BLI_UINT8 *s2 = (BLI_UINT8*)source2;
+
+  while(len--)
+  {
+    if (*s1++ != *s2++) return(FALSE);
+  }
+
+  return(TRUE);
+}
+
+#endif
+
+
+/****************
+ * MEMCOMPARE32 *
+ ****************/
+
+/* Compares len bytes between source and dest
+
+   len must be a multiple of 32 bytes (8 words)
+
+   source and dest *MUST* be word aligned
+
+   ISSUES ...
+
+   - If the assembler version is used then You will get a warning from GCC when
+     this builds, if anyone knows how to fix this then please let me know!!!      */
+
+#if ASM_SPEEDUP
+
+static BLI_BOOL __attribute__((__noinline__)) memcompare32(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len)
+{
+
+  BLI_BOOL result = NDR_SUCCESS;
+
+  __asm__ volatile
+  (
+    "             srl     %3,%3,5                     \n" /* len / 32  */
+    "             ori     %0,$0,0                     \n"
+    "__mcmp32loop:lw      $8,0(%1)                    \n"
+    "             lw      $9,0(%2)                    \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,4(%1)                    \n"
+    "             lw      $9,4(%2)                    \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,8(%1)                    \n"
+    "             lw      $9,8(%2)                    \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,12(%1)                   \n"
+    "             lw      $9,12(%2)                   \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,16(%1)                   \n"
+    "             lw      $9,16(%2)                   \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,20(%1)                   \n"
+    "             lw      $9,20(%2)                   \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,24(%1)                   \n"
+    "             lw      $9,24(%2)                   \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             lw      $8,28(%1)                   \n"
+    "             lw      $9,28(%2)                   \n"
+    "             bne     $8,$9,__mcmp32out           \n"
+    "             addi    %1,32                       \n"
+    "             addi    %2,32                       \n"
+    "             addi    %3,-1                       \n"
+    "             bne     $0,%3,__mcmp32loop          \n"
+    "             nop                                 \n"
+    "             ori     %0,$0,1                     \n"
+    "__mcmp32out:                                     \n"
+    : "=r"(result) : "r"(source1), "r"(source2), "r"(len) : "$8", "$9"
+  );
+  return result = NDR_SUCCESS;
+}
+
+#else
+
+static BLI_BOOL memcompare32(BLI_VOID *source1, BLI_VOID *source2, BLI_UINT32 len)
+{
+  BLI_UINT32 *s1 = (BLI_UINT32*)source1;
+  BLI_UINT32 *s2 = (BLI_UINT32*)source2;
+  len /= 32;
+
+  while(len--)
+  {
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+    if (*s1++ != *s2++) return(FALSE);
+  }
+
+  return(TRUE);
+}
+#endif
+
+
+/**********************
+ * Generate CRC Table *
+ **********************/
+
+static void generate_crc_table(void)
+{
+  /* Locals */
+
+  int32_t   i,j;
+  uint32_t  c;
+
+  /* Generate */
+
+  for (i = 0; i < 256; ++i)
+  {
+    for (c = i << 24, j = 8; j > 0; --j)
+    {
+      c = c & 0x80000000 ? (c << 1) ^ CRC32_POLY : (c << 1);
+    }
+    nand_crc_table[i] = c;
+  }
+}
+
+
+/*****************
+ * Calculate CRC *
+ *****************/
+
+/* Calculates the CRC of count bytes
+
+   count must be a multiple of 4 bytes!
+
+   ISSUES ...
+
+   - If the assembler version is used then You will get a warning from GCC when
+     this builds, if anyone knows how to fix this then please let me know!!!      */
+
+#if ASM_SPEEDUP
+
+BLI_UINT32  __attribute__((__noinline__)) calc_crc32(BLI_VOID *source, BLI_UINT32 crc, BLI_UINT32* crctable, BLI_UINT32 count)
+{
+  BLI_UINT32  result = NDR_SUCCESS;
+
+  __asm__ volatile
+  (
+    "           srl     %4,%4,2                     \n" /* count / 4                   */
+    "__crcloop: lbu     $8,0(%1)                    \n" /* sourcebyte = *source + 0    */
+    "           srl     $9,%2,24                    \n" /* temp = crc >> 24            */
+    "           sll     %2,%2,8                     \n" /* crc <<= 8                   */
+    "           xor     $9,$9,$8                    \n" /* tlook = (sourcebyte ^ temp) */
+    "           sll     $9,$9,2                     \n" /* tlook *= 4               */
+    "           addu    $10,$9,%3                   \n" /* tlook += &crctable[0]       */
+    "           lw      $8,($10)                    \n" /* crcval = *tlook          */
+    "           xor     %2,%2,$8                    \n" /* crc ^= crcval               */
+    "           lbu     $8,1(%1)                    \n" /* sourcebyte = *source + 1    */
+    "           srl     $9,%2,24                    \n" /* temp = crc >> 24            */
+    "           sll     %2,%2,8                     \n" /* crc <<= 8                   */
+    "           xor     $9,$9,$8                    \n" /* tlook = (sourcebyte ^ temp) */
+    "           sll     $9,$9,2                     \n" /* tlook *= 4               */
+    "           addu    $10,$9,%3                   \n" /* tlook += &crctable[0]       */
+    "           lw      $8,($10)                    \n" /* crcval = *tlook          */
+    "           xor     %2,%2,$8                    \n" /* crc ^= crcval               */
+    "           lbu     $8,2(%1)                    \n" /* sourcebyte = *source + 2    */
+    "           srl     $9,%2,24                    \n" /* temp = crc >> 24            */
+    "           sll     %2,%2,8                     \n" /* crc <<= 8                   */
+    "           xor     $9,$9,$8                    \n" /* tlook = (sourcebyte ^ temp) */
+    "           sll     $9,$9,2                     \n" /* tlook *= 4               */
+    "           addu    $10,$9,%3                   \n" /* tlook += &crctable[0]       */
+    "           lw      $8,($10)                    \n" /* crcval = *tlook          */
+    "           xor     %2,%2,$8                    \n" /* crc ^= crcval               */
+    "           lbu     $8,3(%1)                    \n" /* sourcebyte = *source + 3    */
+    "           srl     $9,%2,24                    \n" /* temp = crc >> 24            */
+    "           sll     %2,%2,8                     \n" /* crc <<= 8                   */
+    "           xor     $9,$9,$8                    \n" /* tlook = (sourcebyte ^ temp) */
+    "           sll     $9,$9,2                     \n" /* tlook *= 4               */
+    "           addu    $10,$9,%3                   \n" /* tlook += &crctable[0]       */
+    "           lw      $8,($10)                    \n" /* crcval = *tlook          */
+    "           xor     %2,%2,$8                    \n" /* crc ^= crcval               */
+    "           addi    %1,4                        \n" /* source += 4                 */
+    "           addi    %4,-1                       \n" /* count -= 1                  */
+    "           bne     $0,$7,__crcloop             \n" /* while (count)            */
+    "           nop                                 \n"
+    "           or      %0,$0,%2                    \n" /* result = crc             */
+    : "=r"(result) : "r"(source), "r"(crc), "r"(crctable), "r"(count) : "$8", "$9", "$10"
+  );
+  return result = NDR_SUCCESS;
+}
+
+#else
+
+BLI_UINT32 calc_crc32(BLI_VOID *source, BLI_UINT32 crc, BLI_UINT32* crctable, BLI_UINT32 count)
+{
+  BLI_UINT8* s   = (BLI_UINT8*)source;
+  count /= 4;
+
+  while(count--)
+  {
+    crc = (crc << 8) ^ crctable[(crc >> 24) ^ *s++];
+    crc = (crc << 8) ^ crctable[(crc >> 24) ^ *s++];
+    crc = (crc << 8) ^ crctable[(crc >> 24) ^ *s++];
+    crc = (crc << 8) ^ crctable[(crc >> 24) ^ *s++];
+  }
+
+  return(crc);
+}
+
+#endif
+
+
+/****************
+ * 64 bit shift *
+ ****************/
+
+/* 64-bit logical right shift that allows this driver not to depend on libgcc */
+
+static BLI_UINT64 lrshift64(BLI_UINT64 arg, BLI_UINT8 shift)
+{
+  BLI_INT32 shift32, carry;
+  union
+  {
+    BLI_UINT64 LL;
+    BLI_UINT32 L[2];
+    BLI_UINT8  B[8];
+  } t1 , t2;
+
+  if (shift == 0)
+  {
+    t2.LL = arg;
+  }
+  else if (shift >= 64)
+  {
+    t2.LL = 0;
+  }
+  else
+  {
+    t1.LL = arg;
+
+    /* Decide if we are little or big-endian */
+    t2.LL = 1;
+    if (t2.B[0] == 1)
+    {
+      /* Little endian */
+
+      /* Is the shift >= 32? */
+      if ((shift32 = 32 - shift) <= 0)
+      {
+        t2.L[1] = 0;
+        t2.L[0] = t1.L[1] >> (-shift32);
+      }
+      else
+      {
+        /* Work out the carry from the higher word to the lower word */
+        carry = t1.L[1] << shift32;
+
+        /* Shift the higher word in the right direction */
+        t2.L[1] = t1.L[1] >> shift;
+
+        /* Shift the lower word and OR in the carry */
+        t2.L[0] = (t1.L[0] >> shift) | carry;
+      }
+    }
+    else
+    {
+      /* Big endian */
+
+      /* Is the shift >= 32? */
+      if ((shift32 = 32 - shift) <= 0)
+      {
+        t2.L[0] = 0;
+        t2.L[1] = t1.L[0] >> (-shift32);
+      }
+      else
+      {
+        /* Work out the carry from the higher word to the lower word */
+        carry = t1.L[0] << shift32;
+
+        /* Shift the higher word in the right direction */
+        t2.L[0] = t1.L[0] >> shift;
+
+        /* Shift the lower word and OR in the carry */
+        t2.L[1] = (t1.L[1] >> shift) | carry;
+      }
+    }
+  }
+  return t2.LL;
+}
+
+
+/****************************************************************************
+ *                                 Export Symbols                           *
+ ****************************************************************************/
+
+#if defined(LINUX) || defined(__linux__)
+MODULE_AUTHOR("Pace PLC");
+MODULE_LICENSE("GPL");
+EXPORT_SYMBOL(nand_dev_init);
+EXPORT_SYMBOL(nand_dev_get_info);
+EXPORT_SYMBOL(nand_dev_enable_ecc);
+EXPORT_SYMBOL(nand_dev_read_block);
+EXPORT_SYMBOL(nand_dev_read_page);
+EXPORT_SYMBOL(nand_dev_read_vpage);
+EXPORT_SYMBOL(nand_dev_read_anywhere);
+EXPORT_SYMBOL(nand_dev_write_block);
+EXPORT_SYMBOL(nand_dev_write_page);
+EXPORT_SYMBOL(nand_dev_write_vpage);
+EXPORT_SYMBOL(nand_dev_write_anywhere);
+EXPORT_SYMBOL(nand_dev_erase_block);
+EXPORT_SYMBOL(nand_dev_copy_block);
+EXPORT_SYMBOL(nand_dev_is_vpage_used);
+EXPORT_SYMBOL(nand_dev_read_spare);
+EXPORT_SYMBOL(nand_dev_write_spare);
+EXPORT_SYMBOL(nand_dev_is_block_erased);
+EXPORT_SYMBOL(nand_dev_is_page_erased);
+EXPORT_SYMBOL(nand_dev_is_vpage_erased);
+EXPORT_SYMBOL(nand_dev_is_block_bad);
+EXPORT_SYMBOL(nand_dev_mark_block_bad);
+EXPORT_SYMBOL(nand_dev_calc_crc32);
+#endif
diff -Naur kernel-3.3-3.0a-ref/drivers/mtd/pacenand/pacenand_base.c kernel-current/drivers/mtd/pacenand/pacenand_base.c
--- kernel-3.3-3.0a-ref/drivers/mtd/pacenand/pacenand_base.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/mtd/pacenand/pacenand_base.c	2013-11-29 10:10:03.163205852 +0100
@@ -0,0 +1,1302 @@
+/****************************************************************************
+ *                                                                          *
+ * File        : pacenand_base.c                                            *
+ *                                                                          *
+ * Description : Interface between the low-level Pace NAND driver and the   *
+ *               Linux kernel MTD subsystem                                 *
+ *                                                                          *
+ * Author      : Arif Hussain / Neil Crossley                               *
+ *                                                                          *
+ * Copyright   : Pace Micro Technology 2011/2013 (c)                        *
+ *                                                                          *
+ *               The copyright in this material is owned by                 *
+ *               Pace Microtechnology PLC ("Pace"). This                    *
+ *               material is regarded as a highly confidential              *
+ *               trade secret of Pace. It may not be reproduced,            *
+ *               used, sold or in any other way exploited or                *
+ *               transferred to any third party without the prior           *
+ *               written permission of Pace.                                *
+ *                                                                          *
+ * History     : Second version, supports BCH ECC                           *
+ *                                                                          *
+ ****************************************************************************/
+
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/types.h>
+#include <stdbool.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/flashchip.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include <linux/mtd/pacenand.h>
+#ifdef CONFIG_NS_ABS_POS
+#include <asm/io.h>
+#endif
+
+#if defined(LINUX) || defined(__linux__)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0)
+#include "linux/brcmstb/brcmstb.h"
+#else
+#include "asm/brcmstb/brcmstb.h"
+#endif
+#else
+#include "bchp_nand.h"
+#endif
+
+#define DRIVER_NAME "pacenand"
+#define DRIVER_INFO  "Pace STB NAND driver"
+#define CONTROLLER_VER    (10 * CONFIG_BRCMNAND_MAJOR_VERS + \
+    CONFIG_BRCMNAND_MINOR_VERS)
+
+
+#if defined(CONFIG_PACE_SYSTEM_IS_NAND_ONLY)
+#define SYSTEM_IS_NAND_ONLY            1
+#endif
+
+#if CONTROLLER_VER >= 60
+
+#define REG_ACC_CONTROL(cs) (BCHP_NAND_ACC_CONTROL_CS0 + ((cs) << 4))
+
+#define REG_CONFIG(cs) (BCHP_NAND_CONFIG_CS0 + ((cs) << 4))
+
+#define REG_TIMING_1(cs) (BCHP_NAND_TIMING_1_CS0 + ((cs) << 4))
+#define REG_TIMING_2(cs) (BCHP_NAND_TIMING_2_CS0 + ((cs) << 4))
+
+#else /* CONTROLLER_VER < 60 */
+
+#define REG_ACC_CONTROL(cs) \
+  ((cs) == 0 ? BCHP_NAND_ACC_CONTROL : \
+   (BCHP_NAND_ACC_CONTROL_CS1 + (((cs) - 1) << 4)))
+
+#define REG_CONFIG(cs) \
+  ((cs) == 0 ? BCHP_NAND_CONFIG : \
+   (BCHP_NAND_CONFIG_CS1 + (((cs) - 1) << 4)))
+
+#define REG_TIMING_1(cs) \
+  ((cs) == 0 ? BCHP_NAND_TIMING_1 : \
+   (BCHP_NAND_TIMING_1_CS1 + (((cs) - 1) << 4)))
+#define REG_TIMING_2(cs) \
+  ((cs) == 0 ? BCHP_NAND_TIMING_2 : \
+   (BCHP_NAND_TIMING_2_CS1 + (((cs) - 1) << 4)))
+
+#define WR_CORR_THRESH(cs, val) do { \
+  BDEV_WR(BCHP_NAND_CORR_STAT_THRESHOLD, \
+    ((val) & BCHP_NAND_CORR_STAT_THRESHOLD_CORR_STAT_THRESHOLD_MASK) \
+        << BCHP_NAND_CORR_STAT_THRESHOLD_CORR_STAT_THRESHOLD_SHIFT); \
+  } while (0);
+
+#endif /* CONTROLLER_VER < 60 */
+
+//#define CONFIG_MTD_PACENAND_DEBUG
+
+static struct mtd_partition *parts = NULL;
+static const char           *part_probes[] = { "cmdlinepart", NULL };
+static unsigned int         nr_parts = 0;
+static spinlock_t           chip_lock;
+static wait_queue_head_t    wq;
+static flstate_t            state = FL_READY;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#define device_size(mtd)   ((mtd)->size)
+#endif
+
+#define BREG_PA(x)    (BPHYSADDR(BCHP_##x##_REG_START))
+#define BREG_LEN(x)   (BCHP_##x##_REG_END + 4 - BCHP_##x##_REG_START)
+
+
+struct pacenand_pm_info 
+{
+  #ifdef CONFIG_BRCM_HAS_EDU
+  uint32_t edu_config;
+  #endif
+  uint32_t nand_cs_nand_select;
+  uint32_t nand_cs_nand_xor;
+  uint32_t corr_stat_threshold;
+  uint32_t acc_control;
+  uint32_t config;
+  uint32_t timing_1;
+  uint32_t timing_2;
+};
+
+struct pacenand_info 
+{
+  struct platform_device  *pdev;
+  struct mtd_info         mtd;
+  struct mtd_partition    *parts;
+  NAND_DEV_INFO           *pacenand;
+  struct pacenand_pm_info *pm_info;
+  uint32_t                cs;
+};
+
+static struct nand_ecclayout  nand_oob;
+static struct pacenand_info   *info;
+
+static int      pacenand_get_device(struct mtd_info *mtd, int new_state);
+static void     pacenand_release_device(struct mtd_info *mtd);
+static void     pacenand_init_mtd(struct pacenand_info *info);
+
+
+/**
+* pacenand_write -  [MTD Interface] NAND write 
+* @param mtd        MTD device structure
+* @param to         offset to write to
+* @param len        number of bytes to write
+* @param retlen     pointer to variable to store the number of written bytes
+* @param buf        the data to write
+*
+* Pace driver NAND write
+*
+* Note - Patched for BCH ECC support, now syncs the oob (spare area) on the first data write, this is
+*        needed as the ECC covers both the data area and the OOB too (except the OOB used to store
+*        the ECC data)
+*/
+
+static int pacenand_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const uint8_t *buf)
+{
+  int ret = 0;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s to %0llx len %d\n", __FUNCTION__, to, len);
+  #endif
+  
+  pacenand_get_device(mtd, FL_WRITING);
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s calling write_nand mtd->size %lx to %llx len %d\n", __FUNCTION__, (long)mtd->size, to, len);
+  #endif
+
+  #ifdef CONFIG_MTD_PACENAND_VERIFY_WRITE
+  ret = nand_dev_write_anywhere((void *)buf, (uint64_t)to, len, NDR_FLAGS_SYNCSPAREONWRITE | NDR_FLAGS_VERIFY);
+  #else
+  ret = nand_dev_write_anywhere((void *)buf, (uint64_t)to, len, NDR_FLAGS_SYNCSPAREONWRITE);
+  #endif
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s write_nand returned %d\n", __FUNCTION__, ret);
+  #endif
+  
+  pacenand_release_device(mtd);
+
+  if (ret != NDR_SUCCESS)
+  {
+    printk("%s: error writing to NAND, error %d\n", __FUNCTION__, ret);
+    *retlen = 0;
+    ret = -EIO;
+  }
+  else
+  {
+    *retlen = len;
+  }
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  
+  return ret;
+}
+
+
+/**
+* pacenand_erase - [MTD Interface] erase block(s)
+* @param mtd        MTD device structure
+* @param instr      erase instruction
+*
+* Pace driver NAND erase one or more blocks
+*/
+
+static int pacenand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+  int startblock, endblock, i, ret = 0;
+  NDR_ERROR result;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s addr %08lx, len %ld\n", __FUNCTION__, (unsigned long)instr->addr, (unsigned long)instr->len);
+  #endif
+  
+  startblock = instr->addr / mtd->erasesize;
+  endblock = (instr->addr + instr->len) / mtd->erasesize;
+  instr->state = MTD_ERASING;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s startblock %d endblock %d\n", __FUNCTION__, startblock, endblock);
+  #endif
+  
+  pacenand_get_device(mtd, FL_ERASING);
+
+  for (i = startblock; i < endblock; i++)
+  {
+    if (nand_dev_is_block_bad(i) == NDR_BLOCK_IS_GOOD)
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("-->%s calling nand_dev_erase_block with block %d\n", __FUNCTION__, i);
+      #endif
+      
+      result = nand_dev_erase_block(i);
+
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("-->%s nand_dev_erase_block returned %d\n", __FUNCTION__, result);
+      #endif
+      
+      if (result != NDR_SUCCESS)
+      {
+        if (result == NDR_DEVICE_ERASE_ERROR)
+        {
+          #ifdef CONFIG_MTD_PACENAND_DEBUG
+          printk("-->%s error while erasing block %d, should mark block bad\n", __FUNCTION__, i);
+          #endif
+          nand_dev_mark_block_bad(i);
+        }
+        
+        #ifdef CONFIG_MTD_PACENAND_DEBUG
+        printk("-->%s got error %d while erasing block %d\n", __FUNCTION__, result, i);
+        #endif
+        
+        instr->state = MTD_ERASE_FAILED;
+        goto erase_exit;
+      }
+    }
+    else
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("-->%s block %d is already bad\n", __FUNCTION__, i);
+      #endif
+      
+      instr->state = MTD_ERASE_FAILED;
+      goto erase_exit;
+    }
+  }
+  instr->state = MTD_ERASE_DONE;
+
+  erase_exit:
+  pacenand_release_device(mtd);
+
+  ret = (instr->state == MTD_ERASE_DONE) ? 0 : -EIO;
+
+  /* Do call back function */
+  if (!ret)
+  {
+    mtd_erase_callback(instr);
+  }
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  
+  return ret;
+}
+
+
+/**
+* pacenand_read - [MTD Interface] MTD read data
+* @param mtd        MTD device structure
+* @param from       offset to read from
+* @param len        number of bytes to read
+* @param retlen     pointer to variable to store the number of read bytes
+* @param buf        the data buffer to put data in
+*
+* Pace driver NAND read data
+*/
+
+static int pacenand_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, uint8_t *buf)
+{
+  int ret = 0;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s from %0llx len %d\n", __FUNCTION__, from, len);
+  /* When doing debugging, set the buffer to dummy values */
+  memset(buf, 0xA5, len);
+  #endif
+
+  /* Do not allow reads past end of device */
+
+  if (unlikely((from + len) > device_size(mtd)))
+  {
+    return -EINVAL;
+  }
+
+  /* If trying to read zero data, then just return */
+
+  else if (!len)
+  {
+    return *retlen = 0;
+  }
+
+  /* Do the read NAND function */
+  pacenand_get_device(mtd, FL_READING);
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s calling read_nand mtd->size %lx from %llx\n", __FUNCTION__, (long)device_size(mtd), from);
+  #endif
+  
+  ret = nand_dev_read_anywhere(buf, (uint64_t)from, len, /*NDR_FLAGS_CRC */ 0);
+  pacenand_release_device(mtd);
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s read_nand returned %d\n", __FUNCTION__, ret);
+  #endif
+
+  /* Was the read successful? */
+  if (ret != NDR_SUCCESS)
+  {
+    *retlen = 0;
+
+    /* Return the right error code if the error was correctable */
+    if (ret == NDR_CORRECTABLE_ERROR)
+    {
+      ret = -EUCLEAN;
+    }
+
+    /* Return the right error code if the error was uncorrectable */
+    else if (ret == NDR_UNCORRECTABLE_ERROR)
+    {
+      ret = -EBADMSG;
+    }
+
+    /* General failure */
+    else
+    {
+      ret = -EIO;
+    }
+  }
+
+  /* Read was successful */
+  else
+  {
+    *retlen = len;
+  }
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s retlen %d len %d\n", __FUNCTION__, *retlen, len);
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  
+  return ret;
+}
+
+
+/*
+
+ struct mtd_oob_ops - oob operation operands
+ @mode: operation mode
+ 
+ @len:  number of data bytes to write/read
+ 
+ @retlen: number of data bytes written/read
+ 
+ @ooblen: number of oob bytes to write/read
+ @oobretlen:  number of oob bytes written/read
+ @ooboffs:  offset of oob data in the oob area (only relevant when
+  mode = MTD_OPS_PLACE_OOB or MTD_OPS_RAW)
+ @datbuf: data buffer - if NULL only oob data are read/written
+ @oobbuf: oob data buffer
+ 
+ Note, it is allowed to read more than one OOB area at one go, but not write.
+ The interface assumes that the OOB write requests program only one page's
+ OOB area.
+ 
+struct mtd_oob_ops {
+  unsigned int  mode;
+  size_t    len;
+  size_t    retlen;
+  size_t    ooblen;
+  size_t    oobretlen;
+  uint32_t  ooboffs;
+  uint8_t   *datbuf;
+  uint8_t   *oobbuf;
+};
+
+*/
+
+/**
+* pacenand_read_oob - [MTD Interface] MTD read OOB
+* @param mtd        MTD device structure
+* @param from       OOB offset to read from
+* @param ops        OOB ops structure
+*
+* Note, it is allowed to read more than one OOB area at one go
+*/
+
+static int pacenand_read_oob(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+{
+  NAND_DEV_INFO *pacenand = (NAND_DEV_INFO*) mtd->priv;
+  NDR_ERROR     ne;
+  int           realpage;
+  int           pageoffs;
+  int           readlen = ops->ooblen;
+  int           offs = ops->ooboffs;
+  int           oobsize = pacenand->Spare_Area_Free;
+  uint8_t       *buf = ops->oobbuf;
+  int           ret = 0;
+  int           len;
+  uint8_t       bufraw[128];
+  uint8_t       buffix[128];
+  int           i;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s read OOB\n", __FUNCTION__);
+  printk("   from offset %lx\n", from);
+  #endif
+  
+  if (unlikely((from + offs + readlen) > device_size(mtd)))
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   attempt read beyond end of device\n");
+    #endif
+    return -EINVAL;
+  }
+
+  realpage = (int)((unsigned long)from / mtd->writesize);
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("   reading from page %d ooblen %d ooboffs %d mode %d\n", realpage, readlen, offs, ops->mode);
+  #endif
+
+  pacenand_get_device(mtd, FL_READING);
+
+  /* Quick check that the offset is within the selected page, if not then
+     increment realpage until it is (probably not likley to happen but
+     it would be legal)                                                   */
+     
+  pageoffs = offs / oobsize;     
+  if (pageoffs)
+  {    
+    realpage += pageoffs;
+    offs %= oobsize;
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   skipping %d pages (offset not within current page)\n", pageoffs);
+    #endif
+  }
+  
+  /* Main read loop */
+  
+  for (;;)
+  {
+    /* Read the spare area */
+    
+    ne = nand_dev_read_spare(realpage, bufraw);
+    
+    if (ne != NDR_SUCCESS)
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("   error reading from NAND, error %d\n", ne);
+      #endif
+      ret = -EINVAL;
+      break;
+    }
+    
+    /* Rearrange */
+    
+    memset(&buffix, 0xff, oobsize);
+    
+    for (i = 0; i < oobsize; i++)
+    {
+      buffix[i] = bufraw[pacenand->Spare_Area_Bytes[i]];
+    }     
+    
+    /* Copy data back to caller */
+  
+    if ((offs + readlen) > oobsize)
+    {
+      len = oobsize - offs;
+    }
+    else
+    {
+      len = readlen;
+    }
+  
+    memcpy(buf, &buffix[offs], len); 
+    buf += len;
+
+    /* Clear offs, decrement bytes to read, bail if finished */
+    
+    offs = 0;
+    readlen -= len;
+    realpage ++;
+
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   %d OOB bytes left to read \n", readlen);
+    #endif
+    
+    if (readlen <= 0) 
+    {
+      break;
+    }
+  }
+
+  /* Exit */
+  
+  pacenand_release_device(mtd);
+      
+  if (ret == 0)
+  {
+    ops->oobretlen = ops->ooblen;
+  }
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+
+  return ret;
+}
+
+
+/**
+* pacenand_write_oob - [MTD Interface] MTD write OOB
+* @param mtd        MTD device structure
+* @param to         OOB offset to write to
+* @param ops        OOB ops structure
+*
+* Note, it is allowed to read more than one OOB area at one go, but not write.
+* The interface assumes that the OOB write requests program only one page's
+* OOB area.
+*/
+
+static int pacenand_write_oob(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+  NAND_DEV_INFO *pacenand = (NAND_DEV_INFO*) mtd->priv;
+  NDR_ERROR     ne;
+  int           realpage;
+  int           writelen = ops->ooblen;
+  int           offs = ops->ooboffs;
+  int           oobsize = pacenand->Spare_Area_Free;
+  uint8_t       *buf = ops->oobbuf;
+  int           ret = 0;
+  uint8_t       bufraw[128];
+  uint8_t       buffix[128];
+  int           i;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s write OOB\n", __FUNCTION__);
+  printk("   to offset %lx\n", to);
+  #endif
+  
+  if (unlikely((to + offs + writelen) > device_size(mtd)))
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   attempt read beyond end of device\n");
+    #endif
+    return -EINVAL;
+  }
+
+  if (unlikely((offs / oobsize) != 0))
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   offset %d not within current page\n", offs);
+    #endif
+    return -EINVAL;
+  }
+
+  if (unlikely((writelen + offs) > oobsize))
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   write length %d greater than oob size\n", writelen);
+    #endif
+    return -EINVAL;
+  }
+
+  realpage = (int)((unsigned long)to / mtd->writesize);
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("   writing to page %d ooblen %d ooboffs %d mode %d\n", realpage, writelen, offs, ops->mode);
+  #endif
+
+  pacenand_get_device(mtd, FL_WRITING);
+
+  /* Prepare spare area buffer */
+
+  memset(&bufraw, 0xff, oobsize);
+  memcpy(&bufraw[offs], buf, writelen);
+  
+  /* Rearrange */
+  
+  memset(&buffix, 0xff, sizeof(buffix));
+  
+  for (i = 0; i < oobsize; i++)
+  {
+    buffix[pacenand->Spare_Area_Bytes[i]] = bufraw[i];
+  }     
+  
+  /* Write */ 
+
+  ne = nand_dev_write_spare(realpage, buffix);
+    
+  if (ne != NDR_SUCCESS)
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("   error writing to NAND, error %d\n", ne);
+    #endif
+    ret = -EINVAL;
+  }
+
+  /* Exit */
+
+  pacenand_release_device(mtd);
+        
+  if (ret == 0)
+  {
+    ops->oobretlen = ops->ooblen;
+  }
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  
+  return ret;
+}
+
+
+/**
+* pacenand_writev - [MTD Interface] Pace NAND driver write vector function (not implemented)
+* @param mtd        MTD device structure
+* @param vecs       the iovectors to write
+* @param count      number of vectors
+* @param to         offset to write to
+* @param retlen     pointer to variable to store the number of written bytes
+*
+* Pace NAND write with kvec.
+*/
+
+#ifdef CONFIG_MTD_PACENAND_DEBUG
+static int pacenand_writev(struct mtd_info *mtd, const struct kvec *vecs, unsigned long count, loff_t to, size_t *retlen)
+{
+  printk("-->%s count %08lX to %0llx\n", __FUNCTION__, count, to);
+  return 0;
+}
+#endif
+
+
+/**
+* pacenand_sync - [MTD Interface] synchronise flash contents
+* @param mtd    MTD device structure
+*
+* Sync is actually a wait for chip ready function
+*/
+
+#ifdef CONFIG_MTD_PACENAND_DEBUG
+static void pacenand_sync(struct mtd_info *mtd)
+{
+  printk("-->%s\n", __FUNCTION__);
+}
+#endif
+
+
+/**
+* pacenand_unlock - [MTD Interface] unlock block(s)
+* @param mtd    MTD device structure
+* @param ofs    offset relative to MTD start
+* @param len    number of bytes to unlock
+*
+* Unlock one or more blocks
+*/
+
+#ifdef CONFIG_MTD_PACENAND_DEBUG
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+
+static int pacenand_unlock(struct mtd_info *mtd, loff_t llofs, uint64_t len)
+{
+  printk("-->%s llofs %0llx len %lld\n", __FUNCTION__, llofs, len);
+  return 0;
+}
+
+#else
+
+static int pacenand_unlock(struct mtd_info *mtd, loff_t llofs, size_t len)
+{
+  printk("-->%s llofs %0llx len %d\n", __FUNCTION__, llofs, len);
+  return 0;
+}
+
+#endif
+
+#endif
+
+
+/**
+* pacenand_suspend - [MTD Interface] suspend the NAND flash
+* @param mtd    MTD device structure
+*/
+
+#ifdef CONFIG_MTD_PACENAND_DEBUG
+
+static int pacenand_suspend(struct mtd_info *mtd)
+{
+  printk("-->%s\n", __FUNCTION__);
+  return 0;
+}
+
+#endif
+
+
+/**
+* pacenand_resume - [MTD Interface] resume the NAND flash
+* @param mtd    MTD device structure
+*/
+
+#ifdef CONFIG_MTD_PACENAND_DEBUG
+
+static void pacenand_resume(struct mtd_info *mtd)
+{
+  printk("-->%s  \n", __FUNCTION__);
+}
+
+#endif
+
+
+/**
+* pacenand_block_isbad - [MTD Interface] return flag indicating block state (1 = bad, 0 = good)
+* @param mtd    MTD device structure
+* @param ofs     offset relative to MTD start
+*/
+
+static int pacenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
+{
+  uint32_t block;
+  int ret = 0;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s ofs %0llx\n", __FUNCTION__, ofs);
+  #endif
+  
+  block = (uint32_t)ofs / mtd->erasesize;
+  pacenand_get_device(mtd, FL_READING);
+
+  #ifdef CONFIG_MTD_PACENAND_CLEAR_BAD_BLOCK_MARKERS
+
+  /* This code will clear the bad block marker */
+
+  if (nand_dev_is_block_bad(block) != NDR_BLOCK_IS_GOOD)
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("-->%s WARNING: erasing block %d and clearing the bad block flag\n", __FUNCTION__, block);
+    #endif
+    if ((ret = nand_dev_erase_block(block)) != NDR_SUCCESS)
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("-->%s ERROR: unable to erase block %d, error %d\n", __FUNCTION__, block, ret);
+      #endif
+      ret = 1;
+    }
+    else
+    {
+      ret = (nand_dev_is_block_bad(block) == NDR_BLOCK_IS_GOOD) ? 0 : 1;
+    }
+  }
+  
+  #else
+  
+  ret = (nand_dev_is_block_bad(block) == NDR_BLOCK_IS_GOOD) ? 0 : 1;
+  
+  #endif
+  
+  pacenand_release_device(mtd);
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s block %d at offset %0llx is %s\n", __FUNCTION__, block, ofs, ret ? "bad" : "good");
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  
+  return ret;
+}
+
+
+/**
+* pacenand_block_markbad - [MTD Interface] mark the block at the given offset as bad
+* @param mtd    MTD device structure
+* @param ofs    offset relative to MTD start
+*
+* Mark the block as bad
+*/
+
+static int pacenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
+{
+  uint32_t block;
+  int ret = 0;
+
+  block = (uint32_t)ofs / mtd->erasesize;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s ofs %0llx block %d\n", __FUNCTION__, ofs, block);
+  #endif
+
+  if ((ret = nand_dev_mark_block_bad(block)) != 0)
+  {
+    ret = -EIO;
+  }
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s complete, returning %d\n", __FUNCTION__, ret);
+  #endif
+  return ret;
+}
+
+
+/**
+* pacenand_probe - [MTD Interface] Initialise the device
+* @param pdev    MTD platform device structure
+*
+* Initialise the device
+*/
+
+static int __devinit pacenand_probe(struct platform_device *pdev)
+{
+  struct brcmnand_platform_data *pd = pdev->dev.platform_data;
+	struct device_node *dn = pdev->dev.of_node;  
+  int i, err = 0;
+
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	const char *part_probe_types[] = { "cmdlinepart", "ofpart", "RedBoot",NULL };
+	#elif defined(CONFIG_MTD_PARTITIONS)
+	/* for 2.6.37 compatibility only */
+	int nr_parts = 0;
+	struct mtd_partition *parts = NULL;
+	const char *part_probe_types[] = { "cmdlinepart", "RedBoot", NULL };
+	#endif
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s\n", __FUNCTION__);
+  #endif
+  
+  printk(DRIVER_INFO " using Pace NAND controller\n");
+
+  /* If driver already initialised return an error */
+  i = nand_dev_init();
+  if (!((i == 0) || (i == NDR_ALREADY_INITIALISED)))
+  {
+    #ifdef CONFIG_MTD_PACENAND_DEBUG
+    printk("-->%s nand_dev_init() failed to initialise the NAND driver %d\n", __FUNCTION__, i);
+    #endif
+    return -EPERM;
+  }
+  else if (!(info = kzalloc(sizeof(struct pacenand_info), GFP_KERNEL)))
+  {
+    return -ENOMEM;
+  }
+  else if (!(info->pm_info = kzalloc(sizeof(struct pacenand_pm_info), GFP_KERNEL)))
+  {
+    return -ENOMEM;
+  }
+  else
+  {
+    if (nand_dev_get_info(&info->pacenand) != 0)
+    {
+      return -EIO;
+    }
+  }
+  info->pdev = pdev;
+
+  #ifdef SYSTEM_IS_NAND_ONLY
+  
+  info->cs = 0;
+  
+  #else
+  
+  info->cs = 1;
+  
+  #endif
+  
+  dev_set_drvdata(&pdev->dev, info);
+  state = FL_READY;
+  init_waitqueue_head(&wq);
+  spin_lock_init(&chip_lock);
+  pacenand_init_mtd(info);
+
+	#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	
+	if (dn)
+	{
+		struct mtd_part_parser_data ppdata = {.of_node = dn };
+		mtd_device_parse_register(&info->mtd, part_probe_types, &ppdata, NULL, 0);
+	}
+	else
+	{
+		mtd_device_parse_register(&info->mtd, part_probe_types, NULL, pd->parts, pd->nr_parts);
+	}
+	
+	#elif defined(CONFIG_MTD_PARTITIONS)
+  
+  if (mtd_has_cmdlinepart())
+  {
+    /* Parse the MTD partitions, if defined on the command line */
+    nr_parts = parse_mtd_partitions(&info->mtd, part_probes, &parts, 0);
+    if (nr_parts <= 0)
+    {
+      /* If none on cmdline, then look for platform data */
+      nr_parts = pd->nr_parts;
+      parts = pd->parts;
+    }
+    if ((parts) && (nr_parts))
+    {
+      if ((err = add_mtd_partitions(&info->mtd, parts, nr_parts)) != 0)
+      {
+        panic("Pace NAND driver could not add MTD partitions!\n");
+      }
+    }
+  }
+
+  #endif
+  
+  return 0;
+}
+
+
+/**
+* pacenand_remove - [MTD Interface] Deinitialise the device
+* @param pdev    MTD platform device structure
+*
+* Deinitialise the device
+*/
+
+static int __devexit pacenand_remove(struct platform_device *pdev)
+{
+  dev_set_drvdata(&pdev->dev, NULL);
+  if (info->pm_info)
+  {
+    kfree(info->pm_info);
+  }
+  if (info)
+  {
+    kfree(info);
+  }
+
+  return 0;
+}
+
+
+/**
+* pacenand_init_mtd -  [MTD Interface] Deinitialise the device
+* @param pacenand_info - Pace NAND information structure pointer
+*
+* Initialise the MTD structure
+*/
+
+static void pacenand_init_mtd(struct pacenand_info *info)
+{
+  int i;
+
+  /* Build the nand_oob structure */
+
+  memset(&nand_oob, 0, sizeof(nand_oob));
+  nand_oob.oobavail = info->pacenand->Spare_Area_Free;
+  nand_oob.oobfree[0].offset = 0;
+  nand_oob.oobfree[0].length = info->pacenand->Spare_Area_Free;
+  nand_oob.oobfree[1].offset = 0;
+  nand_oob.oobfree[1].length = 0;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s %d bytes free in OOB\n", __FUNCTION__, info->pacenand->Spare_Area_Free);
+  printk("Log to phys translate list is ...\n");
+  for (i = 0; i < info->pacenand->Spare_Area_Free; i++)
+  {
+    printk("Log %2d is phys %2d\n", i, info->pacenand->Spare_Area_Bytes[i]);
+  }
+  #endif
+
+  /* Fill in remaining MTD driver data */
+  
+  info->mtd.type = MTD_NANDFLASH;
+  info->mtd.flags = MTD_CAP_NANDFLASH;
+
+  info->mtd.erase = pacenand_erase;
+  info->mtd.point = NULL;
+  info->mtd.unpoint = NULL;
+  info->mtd.read = pacenand_read;
+  info->mtd.write = pacenand_write;
+  info->mtd.read_oob = pacenand_read_oob;
+  info->mtd.write_oob = pacenand_write_oob;
+
+  /* Not needed? */
+  
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  info->mtd.writev = pacenand_writev;
+  info->mtd.sync = pacenand_sync;
+  #else
+  info->mtd.writev = NULL;
+  info->mtd.sync = NULL;
+  #endif
+  info->mtd.sync = NULL;
+  info->mtd.lock = NULL;
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  info->mtd.unlock = pacenand_unlock;
+  #else
+  info->mtd.unlock = NULL;
+  #endif
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  info->mtd.suspend = pacenand_suspend;
+  info->mtd.resume = pacenand_resume;
+  #else
+  info->mtd.suspend = NULL;
+  info->mtd.resume = NULL;
+  #endif
+  info->mtd.block_isbad = pacenand_block_isbad;
+  info->mtd.block_markbad = pacenand_block_markbad;
+
+  /* Propagate ECC layout to mtd_info */
+  
+  info->mtd.ecclayout = &nand_oob;
+
+  /* NAND page size & block size */
+  
+  info->mtd.writesize = info->pacenand->Virt_Page_Size;
+
+  /* OOB size for MLC NAND varies depend on the chip */
+  
+  info->mtd.oobsize = info->pacenand->Spare_Area_Size;
+
+  info->mtd.oobavail = nand_oob.oobavail;
+
+  info->mtd.erasesize = info->pacenand->Block_Size;
+  #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+  info->mtd.eccsize = info->pacenand->Virt_Page_Size;
+  info->mtd.ecctype = MTD_ECC_NONE;
+  #endif
+  info->mtd.subpage_sft = 0;  /* this is a right shift (divide) */
+  info->mtd.size = info->pacenand->Device_Size;
+  info->mtd.name = dev_name(&info->pdev->dev);
+  info->mtd.dev.parent = &info->pdev->dev;
+  info->mtd.reboot_notifier.notifier_call = NULL;
+
+  /* use the priv slot to store the nand_info structure pointer */
+
+  info->mtd.priv = (NAND_DEV_INFO *)info->pacenand;
+
+  #ifdef CONFIG_MTD_PACENAND_DEBUG
+  printk("-->%s device size %d, block size=%d, oob size=%d, write size=%d spare area size = %d\n", __FUNCTION__, (unsigned int)info->mtd.size, info->mtd.erasesize, info->mtd.oobsize, info->mtd.writesize, info->pacenand->Spare_Area_Size);
+  #endif
+
+  info->mtd.owner = THIS_MODULE;
+}
+
+
+/**
+* Power management save/restore functions
+*
+*/
+
+#define HIF_ENABLED_IRQ(bit) \
+  (!BDEV_RD_F(HIF_INTR2_CPU_MASK_STATUS, bit##_INTR))
+
+#define CMD_FLASH_RESET    0x09
+#define FLASH_RESET_TIMEOUT 200000
+
+static int pacenand_pm_suspend(struct device *dev)
+{
+  if (brcm_pm_deep_sleep())
+  {
+
+    struct pacenand_info *info = dev_get_drvdata(dev);
+
+    if ((info) && (info->pm_info))
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("%s : Save(0x%X:%d)\n", __FUNCTION__, info, info->cs);
+      #endif
+      
+      #ifdef CONFIG_BRCM_HAS_EDU
+      info->pm_info->edu_config = BDEV_RD(BCHP_EDU_CONFIG);
+      #endif
+      info->pm_info->nand_cs_nand_select = BDEV_RD(BCHP_NAND_CS_NAND_SELECT);
+      info->pm_info->nand_cs_nand_xor = BDEV_RD(BCHP_NAND_CS_NAND_XOR);
+      info->pm_info->corr_stat_threshold = BDEV_RD(BCHP_NAND_CORR_STAT_THRESHOLD);
+      info->pm_info->acc_control = BDEV_RD(REG_ACC_CONTROL(info->cs));
+      info->pm_info->config = BDEV_RD(REG_CONFIG(info->cs));
+      info->pm_info->timing_1 = BDEV_RD(REG_TIMING_1(info->cs));
+      info->pm_info->timing_2 = BDEV_RD(REG_TIMING_2(info->cs));
+    }
+  }
+  return 0;
+}
+
+static int pacenand_pm_resume(struct device *dev)
+{
+  if (brcm_pm_deep_sleep())
+  {
+
+    struct pacenand_info *info = dev_get_drvdata(dev);
+    unsigned int delay;
+    volatile unsigned int reg;
+
+    if ((info) && (info->pm_info))
+    {
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      printk("%s : Restore\n", __FUNCTION__);
+      #endif
+
+      #ifdef CONFIG_BRCM_HAS_EDU
+      BDEV_WR_RB(BCHP_EDU_CONFIG, info->pm_info->edu_config);
+      BDEV_WR(BCHP_EDU_ERR_STATUS, 0);
+      BDEV_WR(BCHP_EDU_DONE, 0);
+      BDEV_WR(BCHP_EDU_DONE, 0);
+      BDEV_WR(BCHP_EDU_DONE, 0);
+      BDEV_WR(BCHP_EDU_DONE, 0);
+      #endif
+      
+      BDEV_WR_RB(BCHP_NAND_CS_NAND_SELECT, info->pm_info->nand_cs_nand_select);
+      BDEV_WR_RB(BCHP_NAND_CS_NAND_XOR, info->pm_info->nand_cs_nand_xor);
+      BDEV_WR_RB(BCHP_NAND_CORR_STAT_THRESHOLD, info->pm_info->corr_stat_threshold);
+      BDEV_WR_RB(REG_ACC_CONTROL(info->cs), info->pm_info->acc_control);
+      BDEV_WR_RB(REG_CONFIG(info->cs), info->pm_info->config);
+      BDEV_WR_RB(REG_TIMING_1(info->cs), info->pm_info->timing_1);
+      BDEV_WR_RB(REG_TIMING_2(info->cs), info->pm_info->timing_2);
+      HIF_ACK_IRQ(NAND_CTLRDY);
+      
+      /* Reset the chip, required by some chips after power-up */
+      BDEV_WR_RB(BCHP_NAND_CMD_EXT_ADDRESS, info->cs << 16);
+      BDEV_WR_RB(BCHP_NAND_CMD_ADDRESS, 0);
+      BDEV_WR_RB(BCHP_NAND_CMD_START, CMD_FLASH_RESET << BCHP_NAND_CMD_START_OPCODE_SHIFT);
+      
+      /* Wait up to 20 milliseconds for autodetect to complete.
+         Wait for INTFC_STATUS.CTLR_READY to be cleared, and then to be set, with timeouts. */
+    
+      delay = FLASH_RESET_TIMEOUT;
+      reg = 1;
+    
+      while ((delay--) && (reg))
+      {
+        reg = BDEV_RD(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_CTLR_READY_MASK;
+      }
+    
+      while ((delay--) && (!reg))
+      {
+        reg = BDEV_RD(BCHP_NAND_INTFC_STATUS) & BCHP_NAND_INTFC_STATUS_CTLR_READY_MASK;
+      }
+      #ifdef CONFIG_MTD_PACENAND_DEBUG
+      if (!reg)
+      {
+        printk("%s : !!! FLASH_RESET timeout !!!\n", __FUNCTION__);
+      }
+      else
+      {
+        printk("%s : FLASH_RESET took %d reads !!!\n", __FUNCTION__, FLASH_RESET_TIMEOUT - delay);
+      }
+      #endif
+    }
+  }
+  return 0;
+}
+
+
+static const struct dev_pm_ops pacenand_pm_ops = {
+  .suspend = pacenand_pm_suspend,
+  .resume = pacenand_pm_resume,
+};
+
+
+static struct platform_driver driver = {
+  .driver = {
+      .name = DRIVER_NAME,
+      .owner = THIS_MODULE,
+      .pm = &pacenand_pm_ops,
+    },
+  .probe = pacenand_probe,
+  .remove = __devexit_p(pacenand_remove),
+};
+
+
+static int __init pacenand_plat_init(void)
+{
+  if (!request_mem_region(BREG_PA(NAND), BREG_LEN(NAND), DRIVER_NAME))
+  {
+    printk(KERN_ERR "%s: can't request memory region\n", __func__);
+    return -ENODEV;
+  }
+  platform_driver_register(&driver);
+  return 0;
+}
+
+static void __exit pacenand_plat_exit(void)
+{
+  platform_driver_unregister(&driver);
+}
+
+
+/**
+* pacenand_get_device - [GENERIC] Get chip for selected access
+* @param mtd    MTD device structure
+* @param new_state  the state which is requested
+*
+* Get the device and lock it for exclusive access
+*/
+
+static int pacenand_get_device(struct mtd_info *mtd, int new_state)
+{
+  DECLARE_WAITQUEUE(wait, current);
+
+  /*
+   * Grab the lock and see if the device is available
+   */
+  for (;;)
+  {
+    spin_lock(&chip_lock);
+
+    /* If the chip is available, use it straight away */
+
+    if (state == FL_READY)
+    {
+      state = new_state;
+      spin_unlock(&chip_lock);
+      break;
+    }
+
+    /* If the new state is to suspend the chip... */
+
+    else if (new_state == FL_PM_SUSPENDED)
+    {
+      spin_unlock(&chip_lock);
+      return (state == FL_PM_SUSPENDED) ? 0 : -EAGAIN;
+    }
+
+    /* Chip isn't available, so cycle round on a wait queue until woken up */
+
+    set_current_state(TASK_UNINTERRUPTIBLE);
+    add_wait_queue(&wq, &wait);
+    spin_unlock(&chip_lock);
+    if (!in_interrupt())
+    {
+      schedule();
+    }
+    remove_wait_queue(&wq, &wait);
+  }
+  return 0;
+}
+
+
+/**
+* pacenand_release_device - [GENERIC] release chip
+* @param mtd    MTD device structure
+*
+* Deselect, release chip lock and wake up anyone waiting on the device
+*/
+
+static void pacenand_release_device(struct mtd_info *mtd)
+{
+  /* Release the chip, and wake up any threads that are waiting on it */
+  spin_lock(&chip_lock);
+  state = FL_READY;
+  wake_up(&wq);
+  spin_unlock(&chip_lock);
+}
+
+
+/**
+* Module init/exit and declarations
+*/
+
+module_init(pacenand_plat_init);
+module_exit(pacenand_plat_exit);
+
+MODULE_ALIAS(DRIVER_NAME);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Pace plc");
+MODULE_DESCRIPTION("Pace NAND flash driver");
diff -Naur kernel-3.3-3.0a-ref/drivers/pdi/Kconfig kernel-current/drivers/pdi/Kconfig
--- kernel-3.3-3.0a-ref/drivers/pdi/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/pdi/Kconfig	2013-11-29 10:10:03.167205818 +0100
@@ -0,0 +1,51 @@
+menu "PDI device support"
+     config PDI_DRIVER
+     bool "activate the pdi driver for device management"
+     default y 
+     help
+     activate the pdi driver for device management
+
+if PDI_DRIVER
+menu "pdi driver configuration"
+     config PDI_DRV_DBG
+     bool "Activate pdi_driver logs ?"
+     config REBOOT_ON_PDI_ERROR
+     bool "Activate reboot the box on PDI critical error ?"
+
+menu "pdi driver BUS supports"
+     config PDI_SATA_STORAGE1
+     bool "support sata bus 1 ?"
+     config PDI_SATA_STORAGE2
+     bool "support sata bus 2 ?"
+     config PDI_USB_STORAGE1
+     bool "support usb bus 1 ?"
+     config PDI_USB_STORAGE2
+     bool "support usb bus 2 ?"
+     config PDI_MTD_STORAGE1
+     bool "support mtd bus 1 ?"
+     config PDI_MTD_STORAGE2
+     bool "support mtd bus 2 ?"
+     config PDI_MTD_STORAGE3
+     bool "support mtd bus 3 ?"
+endmenu
+
+config PDI_MNG_SH
+     bool "Activate the security handler capabilities restrictions"
+if PDI_MNG_SH
+menu "pdi driver Security Handlers (SH)"
+     config PDI_SH_AUDIO
+     bool "support SH audio ?"
+endmenu
+endif
+
+config PDI_MNG_MP
+     bool "Activate the mount point restrictions"
+if PDI_MNG_MP
+menu "pdi driver FS supports"
+     config PDI_FS_MTDBLOCK1
+     bool "support mtdblock1 ?"
+endmenu
+endif
+endmenu
+endif
+endmenu
diff -Naur kernel-3.3-3.0a-ref/drivers/pdi/Makefile kernel-current/drivers/pdi/Makefile
--- kernel-3.3-3.0a-ref/drivers/pdi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/pdi/Makefile	2013-11-29 10:10:03.167205818 +0100
@@ -0,0 +1,50 @@
+#
+# Makefile for the GPL Pace PDI driver
+#
+
+ifdef CONFIG_PDI_DRV_DBG	
+EXTRA_CFLAGS += -DPDI_DEBUG
+endif
+
+ifdef CONFIG_PDI_SATA_STORAGE1
+BUS_LIST += sata-stm1
+endif
+ifdef CONFIG_PDI_SATA_STORAGE1
+BUS_LIST += sata-stm2 
+endif
+
+ifdef CONFIG_PDI_USB_STORAGE1
+BUS_LIST += usb-storage1
+endif
+ifdef CONFIG_PDI_USB_STORAGE1
+BUS_LIST += usb-storage2
+endif
+
+ifdef CONFIG_PDI_MTD_STORAGE1
+BUS_LIST += mtd1
+endif
+ifdef CONFIG_PDI_MTD_STORAGE2
+BUS_LIST += mtd2
+endif
+ifdef CONFIG_PDI_MTD_STORAGE3
+BUS_LIST += mtd3
+endif
+
+ifdef CONFIG_PDI_FS_MTDBLOCK1
+FS_LIST += /dev/mtdblock1
+endif
+
+ifdef CONFIG_PDI_SH_AUDIO
+SH_LIST += /pmw/audio/audio
+endif
+ifdef PMW_PDI_MAX_MOUNT_NUMBER
+EXTRA_CFLAGS += -DMAX_FS_NUMBER="$(PMW_PDI_MAX_MOUNT_NUMBER)"
+else
+EXTRA_CFLAGS += -DMAX_FS_NUMBER=10
+endif
+
+EXTRA_CFLAGS += -DBUS_LIST="$(BUS_LIST)"
+EXTRA_CFLAGS += -DFS_LIST="$(FS_LIST)"
+EXTRA_CFLAGS += -DSH_LIST="$(SH_LIST)"
+
+obj-$(CONFIG_PDI_DRIVER)		+= pdi_driver.o
diff -Naur kernel-3.3-3.0a-ref/drivers/pdi/pdi_driver.c kernel-current/drivers/pdi/pdi_driver.c
--- kernel-3.3-3.0a-ref/drivers/pdi/pdi_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/pdi/pdi_driver.c	2013-11-29 10:10:03.171205783 +0100
@@ -0,0 +1,726 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/security.h>
+#include <linux/mtd/mtd.h>
+#include <linux/pdi_driver.h>
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("pdi interface");
+MODULE_AUTHOR("");
+ 
+DEFINE_MUTEX(pdi_mutex);
+
+char *pdi_key = NULL;
+unsigned char *auto_status = NULL;
+
+static wait_queue_head_t pdi_waitq;
+static int PDI_Open = 0;
+static int Major;
+static int pdi_new_dev = 0;
+
+static char *mp_name[MAX_FS_NUMBER];
+static unsigned int mp_c = 0;
+
+static char mountpoint_name[MAX_BUF_SIZE];
+static char devices_name[MAX_BUF_SIZE];
+
+static char  pdi_dev[3 * MAX_DEVICE_NUMBER][MAX_NAME_LEN];
+
+static char *ata_list[MAX_DEVICE_NUMBER];
+static char *usb_list[MAX_DEVICE_NUMBER];
+static char *mtd_list[MAX_DEVICE_NUMBER];
+
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+extern void sh_reset (void) __attribute__ ((noreturn));
+#endif
+
+static char all_devices[256 * MAX_BUF_SIZE];
+static int count;
+
+static unsigned int pdi_poll(struct file *file, struct poll_table_struct *wait);
+
+static int pdi_open(struct inode *inode, struct file *file);
+
+#if defined(HAVE_UNLOCKED_IOCTL)
+static long pdi_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
+		     unsigned long pdi_data);
+#else
+static int pdi_ioctl(struct inode *inode, struct file *filp, unsigned int cmd, 
+		     unsigned long pdi_data);
+#endif
+static int pdi_release(struct inode *inode, struct file *file);
+
+int pdi_update_devices_list (char *name, char *device, int connected);
+
+static struct file_operations pdi_fops = {
+ .owner   = THIS_MODULE,
+ .open    = pdi_open,
+#if defined(HAVE_UNLOCKED_IOCTL)
+ .unlocked_ioctl   = pdi_ioctl,
+#else
+ .ioctl   = pdi_ioctl,
+#endif
+ .poll    = pdi_poll,
+ .release = pdi_release,
+};
+
+static unsigned int pdi_poll(struct file *file, struct poll_table_struct *wait) 
+{
+  unsigned int mask = 0;
+  
+  poll_wait(file, &pdi_waitq, wait);
+  if (pdi_new_dev)
+    mask = POLLPRI;
+  
+  return mask;
+}
+
+static void pdi_gen_mount_point_list(void) 
+{
+  int i;
+  
+  memset(mountpoint_name, 0, MAX_BUF_SIZE * sizeof(char));
+  for (i = 0; i < MAX_FS_NUMBER; i++) 
+    {
+      strncat (mountpoint_name, mp_name[i], strlen (mp_name[i]));
+      strncat (mountpoint_name, "|", 1);
+    }
+}
+
+static void pdi_gen_dev_list(void) 
+{
+  int i;
+  
+  memset(devices_name, 0, MAX_BUF_SIZE * sizeof(char));
+  for (i = 0; i < (3 * MAX_DEVICE_NUMBER); i++) 
+    {
+      strncat (devices_name, pdi_dev[i], strlen (pdi_dev[i]));
+      strncat (devices_name, "|", 1);
+    }
+}
+
+int pdi_autodiag_upd_pl(int connected)
+{
+  if(!auto_status)
+    {
+      auto_status = kmalloc (3 * sizeof(char), GFP_KERNEL);
+      if(auto_status == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+    }
+  if (connected == 0)
+    auto_status[1] = 'n';
+  else
+    auto_status[1] = 'y';
+  auto_status[2] = '\0';
+  return 0;
+}
+EXPORT_SYMBOL_GPL(pdi_autodiag_upd_pl);
+
+int pdi_sd_format_disk_name (char *buf, int *id)
+{
+  unsigned int i = 0; 
+  int type = -1;
+    
+  while ((i < MAX_DEVICE_NUMBER) && (strcmp(buf, usb_list[i]) != 0)) 
+    i++;
+  
+  if (i == MAX_DEVICE_NUMBER) 
+    {
+      i = 0; 
+      while ((i < MAX_DEVICE_NUMBER) && (strcmp(buf, ata_list[i]) != 0)) 
+	i++;
+      
+      if (i == MAX_DEVICE_NUMBER) 
+	{
+	  i = 0;
+	  while ((i < MAX_DEVICE_NUMBER) && (strcmp(buf, mtd_list[i]) != 0)) 
+	    i++;
+	  
+	  if (i == MAX_DEVICE_NUMBER) 
+	    {
+	      return -1;
+	    }
+	  else 
+	    {
+	      type = 2;
+	    }
+	}
+      else
+	{
+	  type = 0;
+	}
+    }
+  else
+    {
+      type = 1;
+    }
+  
+  *id = type * MAX_DEVICE_NUMBER + i - 1;
+  switch (type)
+    {
+    case 2:
+      pdi_dbg("Retrieved index %d for %s on a supported bus type MTD\n", *id, buf);
+      break;
+    case 1:
+      printk("Retrieved index %d for %s on a supported bus type USB\n", *id, buf);
+      break;
+    case 0:
+      pdi_dbg("Retrieved index %d for %s on a supported bus type ATA\n", *id, buf);
+      break;
+    default:
+      printk("Error in index processing %d for %s unsupported bus type => %s request a reboot", 
+	      *id, buf, __FUNCTION__);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+      sh_reset();
+#endif
+      return -1;
+    }
+  
+  return 0;
+}
+EXPORT_SYMBOL_GPL(pdi_sd_format_disk_name);
+
+int pdi_update_mount_point_list (char *dev_name, char * dir_name, int mounted) 
+{
+  unsigned int i = 0;
+  unsigned int not_found;
+  pdi_new_dev = 0;
+  
+#ifdef CONFIG_PDI_MNG_MP
+  char *f = NULL;
+  f=strstr (TOSTRING(FS_LIST), dev_name);
+  if (f == NULL)
+    {	      
+      printk("rejecting %s illegal mount/umount requested => %s should provok a reboot\n", dev_name, DEVICE_NAME);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+      sh_reset();
+#endif
+      return -1;
+    }	    
+#endif  
+  
+  if ( (mp_c == MAX_FS_NUMBER) && (mounted == 1) )
+    {
+      printk("rejecting %s too much mount requested %d => %s should provok a reboot\n", dev_name, mp_c, DEVICE_NAME);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+      sh_reset();
+#endif
+      return -1;
+    }
+  
+  if (mounted == 1) 
+    { 
+      for (i=0; i<MAX_FS_NUMBER; i++)
+      {
+          if (!strncmp(mp_name[i], "empty", 5))
+            break;
+      }
+      pdi_dbg("mounting %s on %s %d\n", dev_name, dir_name, mp_c);
+      strncpy(mp_name[i], dev_name, strlen(dev_name));      
+      strncpy(mp_name[i] + strlen(dev_name), "=", 1);
+      strncpy(mp_name[i] + strlen(dev_name) + 1, dir_name, strlen(dir_name));
+
+      mp_c++;
+    }
+  else 
+    {
+      not_found = 1;
+      while (i < MAX_FS_NUMBER)
+	{
+	  if (strstr(mp_name[i], dev_name) != 0) 
+	    {
+	      not_found = 0;
+	      pdi_dbg("removing %s---%s\n", dev_name, mp_name[i]);
+	      strncpy(mp_name[i], "empty", MAX_NAME_LEN);
+	      mp_c--;
+	    }
+	  i++;
+	}
+      
+      if (not_found) 
+	{
+	  printk("rejecting %s umount because %s never mounted => %s should provok a reboot\n", dev_name, dev_name, DEVICE_NAME);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+	  sh_reset();
+#endif
+	  return -1;
+	}
+    }
+  
+  return 0;
+}
+EXPORT_SYMBOL_GPL(pdi_update_mount_point_list);
+
+int pdi_add_device (char *name, int type, int id) {
+  
+  char *f=NULL;
+
+  f=strstr (TOSTRING(BUS_LIST), name);
+  if (f == NULL)
+    {	      
+      pdi_dbg("rejecting %s unauthorized devices\n", name);
+      return -1;
+    }	      
+  
+  switch (type)
+    {
+    case 0: 
+      if (id < MAX_DEVICE_NUMBER)
+	{
+	  pdi_dbg("adding %s in ATA list at ID %d\n", name, id);
+	  strncpy(ata_list[id], name, MAX_NAME_LEN);
+	  return 0;
+	}      
+      else
+	{
+	  pdi_dbg("rejecting %s no more free slot in ATA list\n", name);
+	  return -1;
+	}
+      break;
+    case 1:
+      if ((id < MAX_DEVICE_NUMBER))
+	{
+	  pdi_dbg("adding %s in USB list at ID %d\n", name, id);
+	  strncpy(usb_list[id], name, MAX_NAME_LEN);
+	  return 0;
+	}
+      else
+	{
+	  pdi_dbg("rejecting %s no more free slot in USB list\n", name);
+	  return -1;
+	}
+      break;
+    case 2:
+      if (id < MAX_DEVICE_NUMBER)
+	{
+	  pdi_dbg("adding %s in MTD list at ID %d\n", name, id);
+	  strncpy(mtd_list[id], name, MAX_NAME_LEN);
+	  return 0;
+	}
+      else
+	{
+	  pdi_dbg("rejecting %s no more free slot in MTD list\n", name);
+	  return -1;
+	}
+      break;
+    default:
+      pdi_dbg("unmanaged device type %d\n", type);
+      return -1;
+    }
+  return 0;
+}
+EXPORT_SYMBOL_GPL(pdi_add_device);
+
+void pdi_get_device_list(void) 
+{
+  int j = 0;
+
+  pdi_dbg("\tATA devices list\n");
+  for (j = 0; j < MAX_DEVICE_NUMBER; j++)
+    {
+      pdi_dbg("\t%s\t%d\n", ata_list[j], j); 
+    }
+  pdi_dbg("\tUSB devices list\n");
+  for (j = 0; j < MAX_DEVICE_NUMBER; j++)
+    {
+      pdi_dbg("\t%s\t%d\n", usb_list[j], j);
+    }
+  pdi_dbg("\tMTD devices list\n");
+  for (j = 0; j < MAX_DEVICE_NUMBER; j++)
+    {
+      pdi_dbg("\t%s\t%d\n", mtd_list[j], j); 
+    }
+}
+
+int pdi_update_devices_list (char *name, char *device, int connected) {
+
+  unsigned int i = 0;
+  //unsigned int j = 0;
+  unsigned int type = 0;
+  //int rv = 0;
+  //int flags = 0;
+  //struct path path;
+
+  while ((i < MAX_DEVICE_NUMBER) && (strcmp(name, usb_list[i]) != 0)) 
+    i++;
+  
+  if (i == MAX_DEVICE_NUMBER) 
+    {
+      i = 0;
+      
+      while ((i < MAX_DEVICE_NUMBER) && (strcmp(name, ata_list[i]) != 0)) 
+	i++;
+      
+      if (i == MAX_DEVICE_NUMBER) 
+	{
+	  i = 0;
+	  while ((i < MAX_DEVICE_NUMBER) && (strcmp(name, mtd_list[i]) != 0)) 
+	    i++;
+	  
+	  if (i == MAX_DEVICE_NUMBER) 
+	    {
+	      pdi_dbg("device %s not found \n", name); 
+	      return -1;
+	    }
+	  else 
+	    {
+	      pdi_dbg("MTD device %s found\n", name);
+	      type = 2;
+	    }
+	}
+      else
+	{
+	  pdi_dbg("ATA device %s found\n", name);
+	  type = 0;
+	}
+    }
+  else
+    {
+      pdi_dbg("USB device %s found\n", name);
+      type = 1;
+    }
+  
+  if ((type * MAX_DEVICE_NUMBER + i - 1)  < 0)
+    {
+      printk("Error in index processing %d for %s unsupported bus type => %s request a reboot", 
+	      (type * MAX_DEVICE_NUMBER + i - 1), name, DEVICE_NAME);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+      sh_reset();
+#endif
+      return -1;
+    }
+  
+  if (connected == 1) 
+    {
+      if (type == 0)
+	{
+	  auto_status[0] = 'y';      
+	}
+      strncpy (pdi_dev[type * MAX_DEVICE_NUMBER + i - 1], device, strlen(device));
+      pdi_dev[type * MAX_DEVICE_NUMBER + i - 1][strlen(device)] = '\0';
+      pdi_dbg("device name %s connected %d\n", pdi_dev[type * MAX_DEVICE_NUMBER + i - 1], strlen(device));
+    }
+  else
+    {
+      if (type == 0)
+	{
+	  auto_status[0] = 'n';      
+	}
+      pdi_dbg("device name %s disconnected\n", pdi_dev[type * MAX_DEVICE_NUMBER + i - 1]);      
+      strncpy (pdi_dev[type * MAX_DEVICE_NUMBER + i - 1], "empty", 5);
+      pdi_dev[type * MAX_DEVICE_NUMBER + i -1][5] = '\0';
+
+    }
+  
+  pdi_new_dev = 1;
+  wake_up_interruptible(&pdi_waitq);
+  return 0;
+}
+
+EXPORT_SYMBOL_GPL(pdi_update_devices_list);
+
+extern void generate_random_uuid(unsigned char uuid_out[16]);
+
+#if defined(HAVE_UNLOCKED_IOCTL)
+static long pdi_ioctl(struct inode *inode, struct file *filp, 
+		     unsigned int cmd, unsigned long pdi_data) 
+#else
+static int pdi_ioctl(struct inode *inode, struct file *filp, 
+		     unsigned int cmd, unsigned long pdi_data) 
+#endif
+{
+  int err=0;
+  unsigned char *pdi_uuid;
+
+  if (_IOC_DIR(cmd) & _IOC_READ)
+    {
+      err = !access_ok(VERIFY_WRITE, (void *)pdi_data, _IOC_SIZE(cmd));
+    }
+  else 
+    if (_IOC_DIR(cmd) & _IOC_WRITE)
+      {
+	err = !access_ok(VERIFY_READ, (void *)pdi_data, _IOC_SIZE(cmd)); 
+      }
+  
+  if (err) 
+    {
+      return -EFAULT; 
+    }
+  
+  switch(cmd)
+    {
+    case PDI_DRIVER_IOR_GET_DEV_LIST:
+      pdi_gen_dev_list();
+      copy_to_user((int *) pdi_data, devices_name, MAX_BUF_SIZE * sizeof(char));
+      pdi_new_dev = 0;
+      break;
+    case PDI_DRIVER_IOR_GET_MOUNTPOINT_LIST:
+      pdi_gen_mount_point_list();
+      copy_to_user((char* ) pdi_data, mountpoint_name, MAX_BUF_SIZE * sizeof(char));
+      break;
+    case PDI_DRIVER_IOW_SET_KEY:
+      if (!pdi_key)
+	{
+	  pdi_key = kmalloc (KEY_SIZE, GFP_KERNEL);
+	  if(pdi_key == NULL)
+	    {
+	      pdi_dbg("not enough memory\n");
+	      return -ENOMEM;
+	    } 
+	}      
+      copy_from_user(pdi_key, (char* )pdi_data, KEY_SIZE);
+      break;
+    case PDI_DRIVER_IOR_GET_UUID:
+      pdi_uuid = kmalloc (UUID_SIZE, GFP_KERNEL);
+      if(pdi_uuid == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+      
+      generate_random_uuid(pdi_uuid);
+      copy_to_user((char* ) pdi_data, pdi_uuid, UUID_SIZE  * sizeof(char));
+      kfree(pdi_uuid);
+      break;
+    case PDI_DRIVER_IOR_GET_AUTODIAG_STATUS:
+      pdi_dbg("autodiag status %s\n", auto_status);
+      copy_to_user((char* ) pdi_data, auto_status, 2 * sizeof(char));
+      break;
+    case PDI_DRIVER_IOR_GET_ALL_DEVICES:
+      copy_to_user((char* ) pdi_data, all_devices, 256 * MAX_BUF_SIZE * sizeof(char));
+      break;   
+    default:
+      return -ENOTTY;
+    }
+  
+  if (err) 
+    {
+      return -EFAULT;
+    }
+  
+  return (long)err;
+}
+EXPORT_SYMBOL_GPL(pdi_key);
+
+static int pdi_open(struct inode *inode, struct file *file)
+{
+  if (PDI_Open > 3)
+    {
+      return -EBUSY;
+    }
+  
+  PDI_Open++;
+  try_module_get(THIS_MODULE);
+
+  return 0;
+}
+
+static int pdi_release(struct inode *inode, struct file *file)
+{
+  PDI_Open--;/* We're now ready for our next caller */
+  
+  module_put(THIS_MODULE);
+
+  return 0;
+}
+
+int pdi_add_all_devices(unsigned int major, const char *name) 
+{
+    char buff[4];
+    
+    count=count + 4 + MAX_BUF_SIZE + 2;
+    
+    if (count > 256 * (4 + MAX_BUF_SIZE + 2))
+      {
+	printk("too much registration requested > %d => %s request a reboot\n", count, DEVICE_NAME);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+      sh_reset();
+#endif
+        return -1;
+      }
+    snprintf (buff, sizeof buff, "%d", major);
+     
+    pdi_dbg("registering %s\n", name);
+
+    strncat(all_devices, buff, 4);    
+    strncat(all_devices, "\t", 1);       
+    strncat(all_devices, name, MAX_BUF_SIZE);        
+    strncat(all_devices, "\n", 1);
+    
+    return 0;
+}
+EXPORT_SYMBOL_GPL(pdi_add_all_devices);
+
+unsigned short pdi_cal_caps (struct linux_binprm *bprm, const struct cred *old)
+{
+  // unsigned int i=0;
+  char *f = NULL;
+  
+  f=strstr (TOSTRING(SH_LIST), bprm->interp);
+  if (f == NULL) 
+    {
+      if (old != NULL)
+	{
+	  if (!cap_isclear(old->cap_inheritable))
+	    {
+	      printk("%s request an illegal capability => %s will kill %s %d\n", bprm->interp, DEVICE_NAME, bprm->interp, current->pid);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+	      sh_reset();
+#endif
+	      return 0;
+	    }	
+	}
+      else
+	{
+	  if (!cap_isclear(bprm->cred->cap_inheritable))
+	    {
+	      printk("%s request an illegal capability => %s will kill %s %d\n", bprm->interp, DEVICE_NAME, bprm->interp, current->pid);
+#ifdef CONFIG_REBOOT_ON_PDI_ERROR
+	      sh_reset();
+#endif
+	      return 0;
+	    }
+	}    
+    }
+  else
+    {
+      if (old != NULL)
+	{
+	  if (!cap_isclear(old->cap_inheritable))
+	    {
+	      pdi_dbg("process %s authorized !!!!!! grant caps \n",  bprm->interp);
+	      return (unsigned short) 1;
+	    }
+	}
+      else
+	{
+	  if (!cap_isclear(bprm->cred->cap_inheritable))
+	    {
+	      pdi_dbg("process %s authorized !!!!!! grant caps \n",  bprm->interp);
+	      return (unsigned short) 1;
+	    }
+	}
+    }
+  return (unsigned short) 0;
+}
+EXPORT_SYMBOL_GPL(pdi_cal_caps);
+
+/* Initialization routine */ 
+static int __init pdi_init(void) 
+{
+  int j = 0; 
+  
+  Major = register_chrdev(144, DEVICE_NAME, &pdi_fops);
+  
+  if (Major < 0) 
+    {
+      pdi_dbg("registering char device failed with %d\n", Major);
+      return Major;
+    }
+  
+  auto_status = kmalloc (3 * sizeof(char), GFP_KERNEL);  
+  if(auto_status == NULL)
+    {
+      pdi_dbg("not enough memory\n");
+      return -ENOMEM;
+    }
+
+  auto_status[0] = 'n';
+  auto_status[1] = 'n';
+  auto_status[2] = '\0';
+  
+  count =0;
+  
+  memset(mountpoint_name, 0, MAX_BUF_SIZE * sizeof (char));
+  memset(devices_name, 0, MAX_BUF_SIZE * sizeof (char));
+  
+  for (j = 0; j < 3 * MAX_DEVICE_NUMBER; j++)
+    {
+      strncpy( pdi_dev[j], "empty", 5);
+    }
+	
+  for (j = 0; j < MAX_DEVICE_NUMBER; j++)
+    {
+      ata_list[j] = kmalloc(MAX_NAME_LEN * sizeof(char), GFP_KERNEL);
+      if(ata_list[j] == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+	    
+      memset(ata_list[j], 0, MAX_NAME_LEN * sizeof(char));      
+      
+      usb_list[j] = kmalloc(MAX_NAME_LEN * sizeof(char), GFP_KERNEL);
+      if(usb_list[j] == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+      
+      memset(usb_list[j], 0, MAX_NAME_LEN * sizeof(char));      
+
+      mtd_list[j] = kmalloc(MAX_NAME_LEN * sizeof(char), GFP_KERNEL);
+      if(mtd_list[j] == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+      
+      memset(mtd_list[j], 0, MAX_NAME_LEN * sizeof(char));      
+    }
+  
+  for (j = 0; j < MAX_FS_NUMBER; j++)
+    {
+      mp_name[j] = kmalloc(2 * MAX_NAME_LEN * sizeof(char), GFP_KERNEL);
+      if(mp_name[j] == NULL)
+	{
+	  pdi_dbg("not enough memory\n");
+	  return -ENOMEM;
+	} 
+      memset(mp_name[j], 0, 2 * MAX_NAME_LEN * sizeof(char));
+      strncpy(mp_name[j], "empty", MAX_NAME_LEN);
+    }
+  init_waitqueue_head(&pdi_waitq);
+
+  pdi_dbg("module loaded\n");
+  return 0;
+}
+
+
+/* Cleanup routine */
+static void __exit pdi_cleanup(void) 
+{
+  int j = 0;
+  
+  unregister_chrdev(Major, DEVICE_NAME);
+ 
+  if (pdi_key)
+    kfree (pdi_key);
+  
+  if (auto_status)
+    kfree (auto_status);
+  
+  for (j = 0; j < MAX_FS_NUMBER; j++)
+    {
+      kfree(mp_name[j]);
+    }
+
+  for (j = 0; j < MAX_DEVICE_NUMBER; j++)
+    {
+      kfree(ata_list[j]);
+      kfree(usb_list[j]);
+      kfree(mtd_list[j]);
+    }
+  
+    pdi_dbg(" module unloaded.\n");
+ }
+
+module_init(pdi_init);
+module_exit(pdi_cleanup);
diff -Naur kernel-3.3-3.0a-ref/drivers/scsi/sd.c kernel-current/drivers/scsi/sd.c
--- kernel-3.3-3.0a-ref/drivers/scsi/sd.c	2013-08-28 01:31:03.000000000 +0200
+++ kernel-current/drivers/scsi/sd.c	2013-11-29 10:10:03.171205783 +0100
@@ -2490,6 +2490,12 @@
 	return 0;
 }
 
+#if defined CONFIG_PDI_DRIVER
+	//PACE PATCH
+extern int pdi_sd_format_disk_name (char *buf, int *id);
+extern int pdi_update_devices_list (char *name, char *device, int connected);
+#endif
+
 /*
  * The asynchronous part of sd_probe
  */
@@ -2545,6 +2551,10 @@
 		  sdp->removable ? "removable " : "");
 	scsi_autopm_put_device(sdp);
 	put_device(&sdkp->dev);
+	
+#if defined CONFIG_PDI_DRIVER
+	pdi_update_devices_list (sdp->host->hostt->pdi_name, gd->disk_name, 1);
+#endif
 }
 
 /**
@@ -2572,6 +2582,10 @@
 	struct gendisk *gd;
 	int index;
 	int error;
+	
+#if defined CONFIG_PDI_DRIVER
+	u32 i;
+#endif
 
 	error = -ENODEV;
 	if (sdp->type != TYPE_DISK && sdp->type != TYPE_MOD && sdp->type != TYPE_RBC)
@@ -2588,7 +2602,25 @@
 	gd = alloc_disk(SD_MINORS);
 	if (!gd)
 		goto out_free;
+#if defined CONFIG_PDI_DRIVER
+	//PACE PATCH
+  
+	pdi_sd_format_disk_name(sdp->host->hostt->pdi_name, &index);
+	if (!ida_pre_get(&sd_index_ida, GFP_KERNEL))
+	  goto out_put;
+	
+	spin_lock(&sd_index_lock);
+	error = ida_get_new_above(&sd_index_ida, index, &i);
+	spin_unlock(&sd_index_lock);
 
+	printk("RETRIEVED ID %lu requested %lu\n", i, index);
+	// security check 
+	if ((u32) index != i)
+	  {
+	    printk("WRONG ID %ul != %ul RETURN =======> REBOOTING\n", index, i);
+	    goto out_put;
+	  }
+#else	
 	do {
 		if (!ida_pre_get(&sd_index_ida, GFP_KERNEL))
 			goto out_put;
@@ -2597,7 +2629,7 @@
 		error = ida_get_new(&sd_index_ida, &index);
 		spin_unlock(&sd_index_lock);
 	} while (error == -EAGAIN);
-
+#endif
 	if (error) {
 		sdev_printk(KERN_WARNING, sdp, "sd_probe: memory exhausted.\n");
 		goto out_put;
@@ -2670,6 +2702,14 @@
 	scsi_autopm_get_device(sdkp->device);
 
 	async_synchronize_full();
+	
+#if defined CONFIG_PDI_DRIVER
+	pdi_update_devices_list (sdkp->device->host->hostt->pdi_name, NULL, 0);		
+	spin_lock(&sd_index_lock);
+	ida_remove(&sd_index_ida, sdkp->index);
+	spin_unlock(&sd_index_lock);
+#endif	
+	
 	blk_queue_prep_rq(sdkp->device->request_queue, scsi_prep_fn);
 	blk_queue_unprep_rq(sdkp->device->request_queue, NULL);
 	device_del(&sdkp->dev);
diff -Naur kernel-3.3-3.0a-ref/drivers/sysinfo/Kconfig kernel-current/drivers/sysinfo/Kconfig
--- kernel-3.3-3.0a-ref/drivers/sysinfo/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/sysinfo/Kconfig	2013-11-29 10:10:03.231205256 +0100
@@ -0,0 +1,7 @@
+#
+# sysinfo subsystem configuration
+# SYSINFO is a system information managment API
+#
+config SYSINFO_SUPPORT
+ bool "Sysinfo driver"
+
diff -Naur kernel-3.3-3.0a-ref/drivers/sysinfo/Makefile kernel-current/drivers/sysinfo/Makefile
--- kernel-3.3-3.0a-ref/drivers/sysinfo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/sysinfo/Makefile	2013-11-29 10:10:03.231205256 +0100
@@ -0,0 +1 @@
+obj-$(CONFIG_SYSINFO_SUPPORT)		+=sysinfo.o
diff -Naur kernel-3.3-3.0a-ref/drivers/sysinfo/sysinfo.c kernel-current/drivers/sysinfo/sysinfo.c
--- kernel-3.3-3.0a-ref/drivers/sysinfo/sysinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/sysinfo/sysinfo.c	2013-11-29 10:10:03.231205256 +0100
@@ -0,0 +1,526 @@
+/*
+ *  sysinfo.c
+ *
+ *  This file contains the implementation of the AON read/writer 
+ *  interface module with the user space.  
+ *
+ *  Created by Samir MOUHOUNE on 10/07/2013.
+ *  Copyright 2013 Pace plc. All rights reserved.
+ *
+ *  The copyright in this material is owned by Pace
+ *  plc ("Pace"). This material is regarded as a
+ *  highly confidential trade secret of Pace. It may not be
+ *  reproduced, used, sold or in any other way exploited or
+ *  transferred to any third party without the prior
+ *  written permission of Pace.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/kernel_stat.h>
+#include <linux/tick.h>
+
+#ifdef CONFIG_BCM7425B0
+#include <linux/brcmstb/brcmstb.h>
+#define BCHP_AVS_RO_REGISTERS_0_PVT_TEMPERATURE_MNTR_STATUS 0x00432b00 /* Indicate PVT monitor sel 000(Temperature Monitoring) measurements data, validity of data and measurement done status */ 
+#endif
+
+#include <linux/sysinfo.h>
+#include "sysinfo_priv.h"
+
+#include <linux/reboot.h>
+#include <asm/reboot.h>
+
+MODULE_AUTHOR ("Pace");
+MODULE_DESCRIPTION ("System Information Management interface");
+MODULE_SUPPORTED_DEVICE ("");
+MODULE_LICENSE ("Pace Proprietary");
+
+
+/*
+ * 
+ *  Module param
+ *
+ */
+static int sysinfo_major = 140;/*value set to 140 just for tests.  Need to be initialized to 0 for dynamic attribution of major number*/
+
+module_param (sysinfo_major,  int, 0644);
+MODULE_PARM_DESC (sysinfo_major,  "Device major number");
+
+
+static struct sysinfo sys_info;
+
+/*static procInfo proc_info;*/
+static int nb_processes;
+
+extern int nr_cpu_ids;
+/*static struct taskInfo task_info;*/ /*get information related to all processes*/
+
+#ifndef arch_irq_stat_cpu
+#define arch_irq_stat_cpu(cpu) 0
+#endif
+#ifndef arch_irq_stat
+#define arch_irq_stat() 0
+#endif
+#ifndef arch_idle_time
+#define arch_idle_time(cpu) 0
+#endif
+
+
+static u64 get_idle_time(int cpu)
+{
+	u64 idle, idle_time = get_cpu_idle_time_us(cpu, NULL);
+
+	if (idle_time == -1ULL) {
+		/* !NO_HZ so we can rely on cpustat.idle */
+		idle = kcpustat_cpu(cpu).cpustat[CPUTIME_IDLE];
+		idle += arch_idle_time(cpu);
+	} else
+		idle = usecs_to_cputime64(idle_time);
+
+	return idle;
+}
+
+static u64 get_iowait_time(int cpu)
+{
+	u64 iowait, iowait_time = get_cpu_iowait_time_us(cpu, NULL);
+
+	if (iowait_time == -1ULL)
+		/* !NO_HZ so we can rely on cpustat.iowait */
+		iowait = kcpustat_cpu(cpu).cpustat[CPUTIME_IOWAIT];
+	else
+		iowait = usecs_to_cputime64(iowait_time);
+
+	return iowait;
+}
+
+
+
+extern void si_meminfo(struct sysinfo *val);
+
+
+/*
+*
+*
+*get_memory_status
+*
+*This method will return the total and the free memory.
+*
+*
+*/
+
+int get_memory_status(struct sysinfo *val, unsigned long arg)
+{
+	int status;
+	struct memInfo mem_info;
+
+   si_meminfo(val);
+
+	mem_info.freeram =val->freeram;
+	mem_info.totalram =val->totalram;
+   	
+   logscr("get_memory_status () - freeram = %lu \n",mem_info.freeram);
+   logscr("get_memory_status () - totalram = %lu \n",mem_info.totalram );
+
+  if(copy_to_user((memInfo*)arg,&mem_info,sizeof(mem_info))) return EFAULT;
+
+	status = 0;	
+	return status; 
+}
+
+
+
+/*
+*
+*
+*show_stat
+*
+*This method will return the list of all online processors and their states 
+*
+*
+*/
+int get_processor(unsigned long arg)
+{
+	int i;
+	unsigned long jif;
+   
+   char* tmp_arch;
+
+	struct procInfo proc_info[nr_cpu_ids];
+
+	struct timespec boottime;
+
+
+	getboottime(&boottime);
+	jif = boottime.tv_sec;
+
+	for_each_online_cpu(i) {
+		proc_info[i].user = proc_info[i].nice = proc_info[i].system = proc_info[i].idle = proc_info[i].iowait =
+		proc_info[i].irq = proc_info[i].softirq = proc_info[i].steal = 0;
+		proc_info[i].guest = proc_info[i].guest_nice =proc_info[i].processes=proc_info[i].nbr_running=proc_info[i].nbr_iowait= 0;
+		/* Copy values here to work around gcc-2.95.3, gcc-2.96 */
+      proc_info[i].cpu=i;
+      logscr("cpu %d\n",proc_info[i].cpu);
+#ifdef CONFIG_CPU_BMIPS
+		tmp_arch="mipsel";/*TODO: check in the kernel if there is a way to get the archetecture instead of the hardcoded value*/
+#else
+     tmp_arch="unknown"
+#endif
+      memcpy(proc_info[i].arch, tmp_arch, strlen(tmp_arch)+1);
+		proc_info[i].user = kcpustat_cpu(i).cpustat[CPUTIME_USER];
+		proc_info[i].nice = kcpustat_cpu(i).cpustat[CPUTIME_NICE];
+		proc_info[i].system = kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM];
+		proc_info[i].idle = get_idle_time(i);
+		proc_info[i].iowait = get_iowait_time(i);
+		proc_info[i].irq = kcpustat_cpu(i).cpustat[CPUTIME_IRQ];
+		proc_info[i].softirq = kcpustat_cpu(i).cpustat[CPUTIME_SOFTIRQ];
+		proc_info[i].steal = kcpustat_cpu(i).cpustat[CPUTIME_STEAL];
+		proc_info[i].guest = kcpustat_cpu(i).cpustat[CPUTIME_GUEST];
+		proc_info[i].guest_nice = kcpustat_cpu(i).cpustat[CPUTIME_GUEST_NICE];
+#ifdef CONFIG_BCM7425B0
+		proc_info[i].temperature = BDEV_RD(BCHP_AVS_RO_REGISTERS_0_PVT_TEMPERATURE_MNTR_STATUS)/1000;
+#else
+		proc_info[i].temperature=0;/*TODO to be adapted to the architecture*/
+#endif
+     	/*proc_info[i].processes=total_forks;
+	  	proc_info[i].nbr_running=nr_running();
+	  	proc_info[i].nbr_iowait=nr_iowait();*/
+	}
+
+
+	if(copy_to_user((procInfo*)arg,&proc_info,sizeof(proc_info))) return EFAULT;
+	return 0;
+}
+
+
+
+char * get_task_state(struct task_struct *task)
+{
+      char* task_state; 
+      switch (task->state)
+      {
+			case TASK_RUNNING:
+				task_state="R";
+         break;
+			case TASK_UNINTERRUPTIBLE:
+				task_state="D";
+         break;
+			case __TASK_STOPPED:
+         case __TASK_TRACED:
+				task_state="T";
+         break;
+			case EXIT_ZOMBIE:
+         case EXIT_DEAD:
+				task_state="Z";
+         break;
+			case TASK_INTERRUPTIBLE:
+				task_state="S";
+         break;
+			default:
+				task_state="unknown";
+         break;
+      }
+	return task_state;
+}
+
+
+unsigned long get_task_vsize(struct mm_struct *mm)
+{
+	struct vm_area_struct *vma;
+	struct rb_node *p;
+	unsigned long vsize = 0;
+
+	down_read(&mm->mmap_sem);
+	for (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {
+		vma = rb_entry(p, struct vm_area_struct, vm_rb);
+		vsize += vma->vm_end - vma->vm_start;
+	}
+	up_read(&mm->mmap_sem);
+	return (vsize/1024);  /*vsize in KB*/
+}
+
+
+
+
+/*
+*
+*
+*
+*get_process_status
+*
+*This method will return the list of all the processes with their information
+*
+*
+*
+*/
+int get_process_status(unsigned long arg)
+{
+   int status = 0;
+	struct task_struct *task;
+   char* tmp_state;
+   char* tmp_comm;
+   int nb_tmp;
+	int i= 0;
+	int j = 0;
+	size_t ctr=0;
+   cputime_t cputime = 0;
+ 
+   unsigned long totalCPUTime = 0;
+	unsigned long tmp_cpuusage=0;
+   unsigned long tmp_idleCpuTime=0; 
+
+	struct taskInfo task_info[nr_processes()]; /*get information related to all processes*/
+	nb_tmp = nr_processes();
+
+	for_each_online_cpu(j) 
+	{
+		tmp_idleCpuTime = tmp_idleCpuTime + get_idle_time(j);
+		tmp_idleCpuTime = tmp_idleCpuTime + get_iowait_time(j);
+		tmp_idleCpuTime = tmp_idleCpuTime + kcpustat_cpu(j).cpustat[CPUTIME_STEAL];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_USER];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_NICE];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_SYSTEM];
+		totalCPUTime = totalCPUTime + get_idle_time(j);
+		totalCPUTime = totalCPUTime + get_iowait_time(j);
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_IRQ];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_SOFTIRQ];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_STEAL];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_GUEST];
+		totalCPUTime = totalCPUTime + kcpustat_cpu(j).cpustat[CPUTIME_GUEST_NICE];
+	}
+
+	tmp_cpuusage=((totalCPUTime-tmp_idleCpuTime)*100)/totalCPUTime;/*CPU usage in %*/
+	totalCPUTime = 0;
+	for_each_process(task)
+   {
+
+      tmp_state= get_task_state(task);
+      memcpy(task_info[i].state, tmp_state, strlen(tmp_state)+1);
+      tmp_comm=task->comm;
+		memcpy(task_info[i].comm, tmp_comm, strlen(tmp_comm)+1);
+      task_info[i].pid=task->pid;
+      task_info[i].prio=task->prio; 
+		if(task->mm)
+		{
+          task_info[i].vsize = get_task_vsize(task->mm);
+		}
+		else
+		{
+          task_info[i].vsize=0;
+		} 
+
+		task_info[i].cpuusage=tmp_cpuusage;/*cpu usage in%*/
+
+		cputime = task->utime+task->stime;
+
+		task_info[i].CPUTime=cputime_to_usecs(cputime);/*CPU TIME is usecs*/
+
+		logscr("[ %s ]  PID: %d  state: %s Priority :%d  vsize:%lu\n",task_info[i].comm , task_info[i].pid,task_info[i].state,task_info[i].prio,task_info[i].vsize);
+		i++;
+   }
+       
+
+	ctr = copy_to_user((taskInfo*)arg,&task_info,sizeof(task_info));
+   if (ctr)return EFAULT;
+   return status; 
+}
+
+
+
+
+int system_reboot(void)
+{
+#ifdef CONFIG_CPU_BMIPS
+	machine_restart("reboot");
+#endif
+	return 0;
+}
+
+
+
+/***********************************************************************************************
+ *
+ *  Char device functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  sysinfo_open
+ *
+ */
+static int sysinfo_open(struct inode *inode, struct file *filp)
+{
+	logscr("An instance of %s has been opened.\n", sysinfo_NAME);
+	return 0;
+}
+
+
+/*
+ * 
+ *  sysinfo_close
+ *
+ */
+static int sysinfo_close(struct inode *inode, struct file *file) 
+{
+	logscr("One instance of %s has been closed.\n", sysinfo_NAME);
+	return 0;
+}
+
+
+/*
+ * 
+ *  sysinfo_ioctl
+ *
+ */
+long sysinfo_ioctl(struct file *filp,unsigned int cmd, unsigned long arg)
+{
+	if (_IOC_TYPE(cmd) != sysinfo_IOC_MAGIC)
+	{
+		logscr("Unrecognized ioctl command prefix.\n");
+		return 1;
+	}
+	if (_IOC_NR(cmd) > MAX_IOCTL_CMD_NMBR)
+	{
+		logscr("ioctl command number out of range.\n");
+		return 1;
+	}
+	switch (cmd)
+	{
+		case GET_MEMORY_STATUS:
+			logscr("ioctl cmd = GET_MEMORY_STATUS.\n");
+         get_memory_status(&sys_info , arg);
+		break;
+
+      case GET_PROCESS_STATUS:
+			logscr("ioctl cmd =  GET_PROCESS_STATUS.\n");
+         get_process_status(arg);
+		break;
+      case GET_PROCESSOR:
+			logscr("ioctl cmd =  GET_PROCESSOR.\n");
+			get_processor(arg);
+		break;
+      case GET_NB_PROC:
+			logscr("ioctl cmd =  GET_NB_PROC.\n");
+			nb_processes = nr_processes();
+			if (put_user(nb_processes, (int *)arg)) return EFAULT;
+		break;
+      case GET_NB_CPU:
+			logscr("ioctl cmd =  GET_NB_PROC.\n");
+			if (put_user(nr_cpu_ids, (int *)arg)) return EFAULT;
+		break;
+      case CPU_REBOOT_CMD:
+			logscr("ioctl cmd =  CPU_REBOOT_CMD.\n");
+			system_reboot();
+		break;
+		default:
+			logscr("ioctl cmd = default.\n");
+		return 1;
+	}
+	return 0;
+}
+
+
+
+
+/*
+ * 
+ *  sysinfo_read
+ *
+ */
+static ssize_t sysinfo_read(struct file *file, char *buff, size_t ctr, loff_t *offp)
+{
+   /*TODO  to be implemented*/
+	return 0;
+}
+
+
+
+/***********************************************************************************************
+ *
+ *  Functions uses to write in the device buffer
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  _sysinfo_write
+ *
+ * 
+ *
+ */
+static ssize_t sysinfo_write(struct file *file, const char *buff, size_t ctr,loff_t *woof)
+{
+/*TODO to be implemnted*/
+	return 0;
+}
+
+
+struct file_operations sysinfo_fops = {
+	owner: THIS_MODULE,
+	open: sysinfo_open,
+	release: sysinfo_close,
+	read: sysinfo_read,
+	write: sysinfo_write,
+	unlocked_ioctl: sysinfo_ioctl,
+};
+
+
+
+/***********************************************************************************************
+ *
+ *  init and exit functions
+ *
+ ***********************************************************************************************/
+
+/*
+ * 
+ *  sysinfo_init
+ *
+ */
+static int __init sysinfo_init(void)
+{
+	int result;
+
+	logscr("enter sysinfo_init()\n");
+	
+	/*
+	 *  Register char sysinfo device 
+	 */
+	result = register_chrdev(sysinfo_major, sysinfo_NAME, &sysinfo_fops);
+	if (result < 0) 
+	{
+		logscr("sysinfo: can't get major %d\n",sysinfo_major);
+		return result;
+	}
+
+	if(sysinfo_major == 0) sysinfo_major = result; /* dynamic */
+
+	logscr("sysinfo device created with %i major number\n",sysinfo_major);
+
+
+	logscr("Registered %s, at major number = %d.\n\n",sysinfo_NAME, sysinfo_major);
+	logscr("To use %s, you must create a device file.\n", sysinfo_NAME);
+	logscr("If this has not already been done, then enter:\n");
+	logscr("mknod /dev/%s c %d 0\n\n", sysinfo_NAME, sysinfo_major);
+	logscr("Also set appropriate permissions for /dev/%s.\n\n", sysinfo_NAME);
+
+	return 0;
+}
+
+
+/*
+ * 
+ *  sysinfo_cleanup
+ *
+ */
+static void __exit sysinfo_cleanup(void)
+{
+	logscr("enter sysinfo_cleanup\n");
+
+	unregister_chrdev(sysinfo_major, sysinfo_NAME);
+}
+
+module_init(sysinfo_init);
+module_exit(sysinfo_cleanup);
diff -Naur kernel-3.3-3.0a-ref/drivers/sysinfo/sysinfo_priv.h kernel-current/drivers/sysinfo/sysinfo_priv.h
--- kernel-3.3-3.0a-ref/drivers/sysinfo/sysinfo_priv.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/drivers/sysinfo/sysinfo_priv.h	2013-11-29 10:10:03.231205256 +0100
@@ -0,0 +1,49 @@
+/*
+ *  sysinfo_priv.h
+ *
+ *  This file contains the implementation of the system information API 
+ *  interface module with the user space.  
+ *
+ *  Created by Samir MOUHOUNE on 10/07/2013.
+ *  Copyright 2013 Pace plc. All rights reserved.
+ *
+ *  The copyright in this material is owned by Pace
+ *  plc ("Pace"). This material is regarded as a
+ *  highly confidential trade secret of Pace. It may not be
+ *  reproduced, used, sold or in any other way exploited or
+ *  transferred to any third party without the prior
+ *  written permission of Pace.
+ *
+ */
+
+#ifndef sysinfo_PRIV_H
+#define sysinfo_PRIV_H
+
+
+
+
+/*#define sysinfo_DEBUG*//*To Enable kernel traces*/
+
+#ifdef sysinfo_DEBUG
+#define logscr(...) \
+		printk("[sysinfo] "__VA_ARGS__);
+#else
+#define logscr(...)
+#endif
+
+
+#define sysinfo_NAME "sysinfo"
+
+
+
+
+static ssize_t sysinfo_write(struct file *file, const char *buff, size_t ctr,loff_t *woof);
+static ssize_t sysinfo_read(struct file *file, char *buff, size_t ctr, loff_t *offp);
+static int sysinfo_init (void );
+static void sysinfo_cleanup ( void );
+
+int get_memory_status(struct sysinfo *val, unsigned long arg);
+int get_process_status(unsigned long arg); /*get status for all processes*/
+int get_processor(unsigned long arg);
+
+#endif /* sysinfo_PRIV_H */
diff -Naur kernel-3.3-3.0a-ref/drivers/usb/core/devio.c kernel-current/drivers/usb/core/devio.c
--- kernel-3.3-3.0a-ref/drivers/usb/core/devio.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/drivers/usb/core/devio.c	2013-11-29 10:10:03.139206063 +0100
@@ -1435,6 +1435,225 @@
 
 	return 0;
 }
+#define CONFIG_PACE_TT_USB_COMMANDS 1
+/* Pace change */
+#if defined(CONFIG_PACE_TT_USB_COMMANDS)
+#define DBGTEST(arg) printk arg
+static int proc_usb_test(struct dev_state *ps, void *arg)
+{
+   struct usb_device *pRootHub = ps->dev;
+   struct usb_device *pDevice;
+   struct usbdevfs_usb_test TestInfo;
+   int port_num;
+   int ret;
+   unsigned int response = 0;
+   char *buf;
+   int index, len;
+   u16 portchange = 0;
+   u16 portstatus = 0;
+   struct usb_port_status *portsts;
+
+   if (!pRootHub)
+   {
+      DBGTEST(("USB_TEST: pRootHub is NULL\n"));
+      return -EINVAL;
+   }
+    DBGTEST(("USB_TEST: pRootHub is valid\n"));
+
+   /* usb_show_device(pRootHub); */
+
+   if (copy_from_user(&TestInfo, (void *)arg, sizeof(TestInfo)))
+      return -EFAULT;
+
+   DBGTEST(("USB_TEST: --> Port %d, action %d, response=%u\n",
+      TestInfo.port_num, TestInfo.action, TestInfo.response));
+
+   port_num = TestInfo.port_num;
+   ret = 0;
+   if (port_num < 0)
+   {
+      pDevice = pRootHub;
+   }
+   else
+   {
+      DBGTEST(("USB_TEST: Hub max children %d",  pRootHub->maxchild));
+      if ((pRootHub->maxchild) && (port_num < USB_MAXCHILDREN))
+      {
+         pDevice = pRootHub->children[port_num];
+      }
+      else
+      {
+         DBGTEST(("USB_TEST: max child failed ---------------"));
+         return -EINVAL;
+      }
+   }
+
+   DBGTEST(("USB_TEST: pDevice %d\n", pDevice));
+
+   switch (TestInfo.action)
+   {
+   case TEST_DEVICE_CONNECTED:
+      response = (pDevice)?1:0;
+      DBGTEST(("USB_TEST: The response is %d ret %d", response, ret));
+      break;
+
+   case TEST_POWER_OFF:
+      /*
+      info("USB_TEST: --> Port %d, POWER OFF, response=%u", TestInfo.port_num, TestInfo.response);
+      info("USB_TEST: Hub [0x%08x] max children %d", pRootHub, pRootHub->maxchild);
+      for (index=0; index < pRootHub->maxchild; index++)
+      {
+         info("USB_TEST: Child %d = [0x%08x]",  index, pRootHub->children[index]);
+      }
+      */
+      ret = usb_control_msg(pRootHub, usb_sndctrlpipe(pRootHub, 0),
+               USB_REQ_CLEAR_FEATURE, USB_RT_PORT, USB_PORT_FEAT_POWER,
+               port_num + 1, NULL, 0, HZ);
+      if (ret < 0) {
+         err("HUB_PORT: --> %s (%d) failed (err = %d)", __FUNCTION__, pDevice->devnum, ret);
+      }
+
+      /* disconnect device if any */
+      if (pRootHub->children[port_num])
+         usb_disconnect(&pRootHub->children[port_num]);
+      break;
+
+   case TEST_POWER_ON:
+      ret = usb_control_msg (pRootHub, usb_sndctrlpipe(pRootHub, 0),
+               USB_REQ_SET_FEATURE, USB_RT_PORT, USB_PORT_FEAT_POWER,
+               port_num + 1, NULL, 0, HZ);
+      if (ret < 0) {
+         err("HUB_PORT: --> %s (%d) failed (err = %d)", __FUNCTION__, pDevice->devnum, ret);
+      }
+      break;
+
+   case TEST_PORT_STATUS:
+      portsts = kmalloc(sizeof(*portsts), GFP_KERNEL);
+      if (portsts) {
+         ret = usb_control_msg(pRootHub, usb_rcvctrlpipe(pRootHub, 0),
+               USB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0,
+               port_num + 1, portsts, sizeof(struct usb_hub_status), HZ);
+         if (ret < 0) {
+            err("HUB_PORT: --> %s (%d) failed (err = %d)", __FUNCTION__, pRootHub->devnum, ret);
+         }
+         else {
+            portstatus = le16_to_cpu(portsts->wPortStatus);
+            portchange = le16_to_cpu(portsts->wPortChange);
+            DBGTEST(("port %d, portstatus 0x%04x, change 0x%04x", port_num, portstatus, portchange));
+            response = portstatus;
+         }
+         kfree(portsts);
+      }
+      break;
+
+   case TEST_SPEED:
+      if (!pDevice)
+      {
+         response = 3;
+         break;
+      }
+      switch (pDevice->speed)
+      {
+      case USB_SPEED_LOW:
+          response = 0; break;
+      case USB_SPEED_FULL:
+          response = 1; break;
+      case USB_SPEED_HIGH:
+          response = 2;break;
+      default:
+         response = 3; break;
+      }
+      break;
+
+   case TEST_VENDOR_ID:
+      if (pDevice)
+      {
+         response = (pDevice->descriptor.idVendor << 16) | pDevice->descriptor.idProduct;
+      }
+      else
+      {
+         response = 0;
+      }
+      break;
+
+  case TEST_DEVICE_MS:
+      if (!pDevice)
+      {
+         response = 0;
+         break;
+      }
+      if((pDevice->config->interface[0]->altsetting->desc.bInterfaceClass == 8)
+       &&(pDevice->config->interface[0]->altsetting->desc.bInterfaceSubClass == 6))
+         response = 1;
+      else
+         response = 0;
+      break;
+
+   case TEST_STRING_MANUF:
+   case TEST_STRING_PROD:
+   case TEST_STRING_SERNUM:
+      if (!pDevice)
+      {
+         response = 0;
+         break;
+      }
+      if (TestInfo.action == TEST_STRING_MANUF)
+         index = pDevice->descriptor.iManufacturer;
+      else if (TestInfo.action == TEST_STRING_PROD)
+         index = pDevice->descriptor.iProduct;
+      else
+         index = pDevice->descriptor.iSerialNumber;
+
+      if (!index)
+      {
+         response = 0;
+         ret = 0;
+      }
+      else if (!(buf = kmalloc(256, GFP_KERNEL)))
+      {
+         /* failed to allocate buffer */
+         ret = -ENOMEM;
+      }
+      else if ((len = usb_string(pDevice, index, buf, 256)) <= 0)
+      {
+         /* failed to get string */
+         kfree(buf);
+      }
+
+      else
+      {
+         DBGTEST(("KERN_INFO %s\n", buf));
+         if (copy_to_user((void *)TestInfo.pBuf, buf, len))
+         {
+            DBGTEST(("USB_TEST: --> Failed to copy to user"));
+            ret = -EFAULT;
+         }
+         else
+         {
+            response = 1;
+         }
+         kfree(buf);
+      }
+      break;
+
+   default:
+      break;
+
+   } /* End of switch() */
+   TestInfo.response = response;
+   if (copy_to_user((void *)arg, &TestInfo, sizeof(TestInfo)))
+   {
+      DBGTEST(("USB_TEST: --> Failed to copy to user"));
+      ret = -EFAULT;
+   }
+   else
+      ret = 0;
+
+   DBGTEST(("USB_TEST: --> The response is %d return %d\n", TestInfo.response, ret));
+
+   return ret;
+}
+#endif /* #ifdef PACE_TT_USB_COMMANDS */
 
 static int processcompl(struct async *as, void __user * __user *arg)
 {
@@ -1907,6 +2126,12 @@
 		ret = proc_setconfig(ps, p);
 		break;
 
+#if defined (CONFIG_PACE_TT_USB_COMMANDS)
+              /* Pace change */
+	case USBDEVFS_TEST:
+	      ret = proc_usb_test(ps, (void *)p);
+	      break;
+#endif /* #ifdef PACE_TT_USB_COMMANDS  */
 	case USBDEVFS_SUBMITURB:
 		snoop(&dev->dev, "%s: SUBMITURB\n", __func__);
 		ret = proc_submiturb(ps, p);
diff -Naur kernel-3.3-3.0a-ref/drivers/usb/storage/usb.c kernel-current/drivers/usb/storage/usb.c
--- kernel-3.3-3.0a-ref/drivers/usb/storage/usb.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/drivers/usb/storage/usb.c	2013-11-29 10:10:03.171205783 +0100
@@ -923,6 +923,10 @@
 }
 EXPORT_SYMBOL_GPL(usb_stor_probe1);
 
+#if defined CONFIG_PDI_DRIVER
+extern pdi_add_device(char *name, int type, int id);
+#endif
+
 /* Second part of general USB mass-storage probing */
 int usb_stor_probe2(struct us_data *us)
 {
@@ -974,6 +978,19 @@
 		dev_dbg(dev, "waiting for device to settle before scanning\n");
 	queue_delayed_work(system_freezable_wq, &us->scan_dwork,
 			delay_use * HZ);
+			
+#if defined CONFIG_PDI_DRIVER
+	struct Scsi_Host *tmp = (struct Scsi_Host *) us_to_host(us);
+	char tname[MAX_LEN];
+
+	// DEVICE STILL THERE CALLING PDI TO REGISTER IT                                                                                                            
+	
+	snprintf(tname, MAX_LEN, "%s%d",tmp->hostt->name, us->pusb_dev->bus->busnum);
+	strcpy(tmp->hostt->pdi_name, tname);
+		
+	printk("DEVICE USB %d %s STILL THERE, CALLING PDI DRIVER TO REGISTER IT\n", us->pusb_dev->bus->busnum, tmp->hostt->pdi_name);
+	pdi_add_device (tmp->hostt->pdi_name, 1, us->pusb_dev->bus->busnum);
+#endif     
 	return 0;
 
 	/* We come here if there are any problems */
diff -Naur kernel-3.3-3.0a-ref/fs/char_dev.c kernel-current/fs/char_dev.c
--- kernel-3.3-3.0a-ref/fs/char_dev.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/char_dev.c	2013-11-29 10:10:03.247205115 +0100
@@ -24,6 +24,10 @@
 
 #include "internal.h"
 
+#ifdef CONFIG_KDEV_DRIVER
+#include <linux/kdev.h>
+#endif
+
 /*
  * capabilities for /dev/mem, /dev/kmem and similar directly mappable character
  * devices
@@ -80,6 +84,47 @@
 
 #endif /* CONFIG_PROC_FS */
 
+
+#ifdef CONFIG_KDEV_DRIVER
+
+int chardev_getList(kdev_ioc_getDevices_t * listOfCharDev)
+{
+  unsigned int index;
+  unsigned int offset = 0;
+  struct char_device_struct * cd;
+  
+  mutex_lock(&chrdevs_lock);
+  index = listOfCharDev->devs_nb;
+  
+  for(offset = 0; offset < CHRDEV_MAJOR_HASH_SIZE; offset++)
+  {
+    for (cd = chrdevs[offset]; cd; cd = cd->next)
+    {
+      listOfCharDev->devs[index].device_type = KDEV_CHAR_DEV;
+      strlcpy(listOfCharDev->devs[index].device_name, cd->name, sizeof(cd->name));
+      listOfCharDev->devs[index].major = cd->major;
+      listOfCharDev->devs[index].min_minor = cd->baseminor;
+      listOfCharDev->devs[index].max_minor = cd->minorct;
+      
+      index++;
+      if(index == (sizeof(listOfCharDev->devs)/sizeof(kdev_dev_t)))
+        return 1;
+    }
+  }
+  
+  listOfCharDev->devs_nb = index;
+  mutex_unlock(&chrdevs_lock);
+  
+  return 0;
+}
+
+#endif /* CONFIG_KDEV_DRIVER */
+
+
+#if defined CONFIG_PDI_DRIVER
+extern void pdi_add_all_devices(unsigned int major, const char *name);
+#endif
+
 /*
  * Register a single major with a specified minor range.
  *
@@ -157,6 +202,10 @@
 	cd->next = *cp;
 	*cp = cd;
 	mutex_unlock(&chrdevs_lock);
+	
+#if defined CONFIG_PDI_DRIVER
+		pdi_add_all_devices(cd->major, cd->name);
+#endif
 	return cd;
 out:
 	mutex_unlock(&chrdevs_lock);
diff -Naur kernel-3.3-3.0a-ref/fs/jffs2/compr.c kernel-current/fs/jffs2/compr.c
--- kernel-3.3-3.0a-ref/fs/jffs2/compr.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/jffs2/compr.c	2013-11-29 10:10:03.199205536 +0100
@@ -12,6 +12,11 @@
  *
  */
 
+#ifdef CONFIG_JFFS2_ENCRYPTION
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 #include "compr.h"
 
 static DEFINE_SPINLOCK(jffs2_compressor_list_lock);
@@ -25,6 +30,65 @@
 /* Statistics for blocks stored without compression */
 static uint32_t none_stat_compr_blocks=0,none_stat_decompr_blocks=0,none_stat_compr_size=0;
 
+#ifdef CONFIG_JFFS2_ENCRYPTION
+static uint8_t aes_key[JFFS2_CRYPTO_KEYSIZE]=
+{   0xbf,0x18,0x6a,0x73,
+    0xec,0x86,0x3f,0x25,
+	0x9b,0xe8,0x03,0x52,
+	0x43,0xd7,0x37,0x8c,
+	0xbf,0x18,0x6a,0x73,
+	0xb3,0x68,0x3a,0x25,
+	0x9b,0xe8,0x33,0x52,
+	0x40,0xd7,0x15,0x3c
+};
+
+/**
+* aes_crypt - encrypt / decrypt data.
+* @str: the data to crypt
+* @len: length of the data
+* @crypto_key: the cryptographic key to use to crypt the data
+*
+* This function applies AES encryption to the data. It is done in counter
+* mode, which means that encryption and decryption are the same operation,
+* i.e., it XORs the same generated bitstream, so it can be used both for
+* encryption / decryption. Returns zero in case of success and a negative
+* error code in case of failure.
+*
+* WARNING: The operation is done in-place, so @str mutates!
+*/
+static int aes_crypt(void *str, int len)
+{
+	struct crypto_blkcipher *tfm;
+	struct blkcipher_desc desc;
+	struct scatterlist sg;
+	uint8_t iv[JFFS2_CRYPTO_KEYSIZE];
+	int err;
+
+	tfm = crypto_alloc_blkcipher(JFFS2_CRYPTO_ALGORITHM, 0, 0);
+	if (IS_ERR(tfm)) {
+		err = PTR_ERR(tfm);
+		printk(KERN_WARNING "JFFS2: failed to load transform for aes, error %d\n", err);
+		return err;
+	}
+
+	err = crypto_blkcipher_setkey(tfm, aes_key, JFFS2_CRYPTO_KEYSIZE);
+	if (err) {
+		printk(KERN_WARNING "JFFS2: cannot set the AES key, flags %#x, error %d\n",
+			  crypto_blkcipher_get_flags(tfm), err);
+		return err;
+	}
+
+	memset(&sg, 0, sizeof(struct scatterlist));
+	sg_set_buf(&sg, str, len);
+	memset(iv, 0, JFFS2_CRYPTO_KEYSIZE);
+	desc.info = iv;
+	desc.tfm = tfm;
+	desc.flags = 0;
+	err = crypto_blkcipher_encrypt(&desc, &sg, &sg, len);
+	crypto_free_blkcipher(tfm);
+	return err;
+}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
 
 /*
  * Return 1 to use this compression
@@ -82,6 +146,12 @@
 		printk(KERN_WARNING "JFFS2: No memory for compressor allocation. Compression failed.\n");
 		return ret;
 	}
+	
+#ifdef CONFIG_JFFS2_ENCRYPTION
+	// Initialise compress buff with no compressed one in order to avoid bad encryption
+	memcpy(output_buf, data_in, *cdatalen);
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 	orig_slen = *datalen;
 	orig_dlen = *cdatalen;
 	spin_lock(&jffs2_compressor_list_lock);
@@ -105,6 +175,13 @@
 		*cdatalen = orig_dlen;
 		err = this->compress(data_in, output_buf, datalen, cdatalen);
 
+#ifdef CONFIG_JFFS2_ENCRYPTION
+		if ( aes_crypt(output_buf, *cdatalen) )
+		{       
+			printk(KERN_WARNING "JFFS2: failed to crypt buffer in [%s:%d]\n", __FUNCTION__, __LINE__);
+		}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 		spin_lock(&jffs2_compressor_list_lock);
 		this->usecount--;
 		if (!err) {
@@ -154,6 +231,15 @@
 	uint32_t orig_slen, orig_dlen;
 	uint32_t best_slen=0, best_dlen=0;
 
+#ifdef CONFIG_JFFS2_ENCRYPTION
+	unsigned char *encrypt_buf = NULL;
+	encrypt_buf = kmalloc(*datalen,GFP_KERNEL);
+	if (!encrypt_buf) {
+		printk(KERN_WARNING "JFFS2: No memory for compressor allocation. Compression failed.\n");
+		return ret;
+	}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 	if (c->mount_opts.override_compr)
 		mode = c->mount_opts.compr;
 	else
@@ -240,9 +326,28 @@
 
 	if (ret == JFFS2_COMPR_NONE) {
 		*cpage_out = data_in;
+		
+#ifdef CONFIG_JFFS2_ENCRYPTION
+		memcpy(encrypt_buf, data_in, *cdatalen);
+
+		if ( aes_crypt(encrypt_buf, *cdatalen) )
+		{
+			printk(KERN_WARNING "JFFS2: failed to crypt buffer in [%s:%d]\n", __FUNCTION__, __LINE__);
+		}
+			
+		*cpage_out = encrypt_buf;
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 		*datalen = *cdatalen;
 		none_stat_compr_blocks++;
 		none_stat_compr_size += *datalen;
+		
+#ifdef CONFIG_JFFS2_ENCRYPTION
+	}
+	else {
+		if (encrypt_buf != NULL)
+		   kfree(encrypt_buf);
+#endif /* CONFIG_JFFS2_ENCRYPTION */
 	}
 	return ret;
 }
@@ -252,7 +357,7 @@
 		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen)
 {
 	struct jffs2_compressor *this;
-	int ret;
+	int ret=0;
 
 	/* Older code had a bug where it would write non-zero 'usercompr'
 	   fields. Deal with it. */
@@ -262,6 +367,12 @@
 	switch (comprtype & 0xff) {
 	case JFFS2_COMPR_NONE:
 		/* This should be special-cased elsewhere, but we might as well deal with it */
+#ifdef CONFIG_JFFS2_ENCRYPTION
+		if ( aes_crypt(cdata_in, cdatalen) )
+		{
+			printk(KERN_WARNING "JFFS2: failed to decrypt buffer in [%s:%d]\n", __FUNCTION__, __LINE__);
+		}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
 		memcpy(data_out, cdata_in, datalen);
 		none_stat_decompr_blocks++;
 		break;
@@ -274,6 +385,12 @@
 			if (comprtype == this->compr) {
 				this->usecount++;
 				spin_unlock(&jffs2_compressor_list_lock);
+#ifdef CONFIG_JFFS2_ENCRYPTION
+				if ( aes_crypt(cdata_in, cdatalen) )
+				{
+					printk(KERN_WARNING "JFFS2: failed to decrypt buffer in [%s:%d]\n", __FUNCTION__, __LINE__);
+				}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
 				ret = this->decompress(cdata_in, data_out, cdatalen, datalen);
 				spin_lock(&jffs2_compressor_list_lock);
 				if (ret) {
diff -Naur kernel-3.3-3.0a-ref/fs/jffs2/compr.h kernel-current/fs/jffs2/compr.h
--- kernel-3.3-3.0a-ref/fs/jffs2/compr.h	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/jffs2/compr.h	2013-11-29 10:10:03.199205536 +0100
@@ -102,4 +102,11 @@
 void jffs2_lzo_exit(void);
 #endif
 
+#ifdef CONFIG_JFFS2_ENCRYPTION
+/* 128 bit key size in bytes for JFFS2 */
+#define JFFS2_CRYPTO_KEYSIZE 32 
+/* AES in counter mode is the encryption algorithm */
+#define JFFS2_CRYPTO_ALGORITHM "ctr(aes)"
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+
 #endif /* __JFFS2_COMPR_H__ */
diff -Naur kernel-3.3-3.0a-ref/fs/jffs2/compr_zlib.c kernel-current/fs/jffs2/compr_zlib.c
--- kernel-3.3-3.0a-ref/fs/jffs2/compr_zlib.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/jffs2/compr_zlib.c	2013-11-29 10:10:03.199205536 +0100
@@ -180,6 +180,13 @@
 	}
 	zlib_inflateEnd(&inf_strm);
 	mutex_unlock(&inflate_mutex);
+
+#ifdef CONFIG_JFFS2_ENCRYPTION
+	if (ret != Z_STREAM_END) {
+	    return ret;
+	}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
+	
 	return 0;
 }
 
diff -Naur kernel-3.3-3.0a-ref/fs/jffs2/Kconfig kernel-current/fs/jffs2/Kconfig
--- kernel-3.3-3.0a-ref/fs/jffs2/Kconfig	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/jffs2/Kconfig	2013-11-29 10:10:03.211205431 +0100
@@ -186,3 +186,10 @@
 	  decompression) at the expense of size.
 
 endchoice
+
+config JFFS2_ENCRYPTION
+	bool "JFFS2 AES encryption"
+	depends on CRYPTO_AES && CRYPTO_CTR
+	help
+	  Activate AES encryption on JFFS2 compression/decompression.
+
diff -Naur kernel-3.3-3.0a-ref/fs/jffs2/read.c kernel-current/fs/jffs2/read.c
--- kernel-3.3-3.0a-ref/fs/jffs2/read.c	2013-08-28 01:31:05.000000000 +0200
+++ kernel-current/fs/jffs2/read.c	2013-11-29 10:10:03.211205431 +0100
@@ -134,6 +134,16 @@
 			goto out_decomprbuf;
 		}
 	}
+#ifdef CONFIG_JFFS2_ENCRYPTION
+	else
+	{
+		ret = jffs2_decompress(c, f, JFFS2_COMPR_NONE, readbuf, decomprbuf, je32_to_cpu(ri->csize), je32_to_cpu(ri->dsize));
+		if (ret) {
+			printk(KERN_WARNING "Error: jffs2_decompress returned %d\n", ret);
+			goto out_decomprbuf;
+		}
+	}
+#endif /* CONFIG_JFFS2_ENCRYPTION */
 
 	if (len < je32_to_cpu(ri->dsize)) {
 		memcpy(buf, decomprbuf+ofs, len);
diff -Naur kernel-3.3-3.0a-ref/fs/namespace.c kernel-current/fs/namespace.c
--- kernel-3.3-3.0a-ref/fs/namespace.c	2013-08-28 01:31:06.000000000 +0200
+++ kernel-current/fs/namespace.c	2013-11-29 10:10:03.171205783 +0100
@@ -41,6 +41,11 @@
 struct kobject *fs_kobj;
 EXPORT_SYMBOL_GPL(fs_kobj);
 
+#if defined CONFIG_PDI_DRIVER
+/* PACE PATCH */
+extern int pdi_update_mount_point_list(char *dev_name, char *dir_name, int mounted);
+#endif
+
 /*
  * vfsmount lock may be taken for read to prevent changes to the
  * vfsmount hash, ie. during mountpoint lookups or walking back
@@ -1092,6 +1097,12 @@
 	struct super_block *sb = mnt->mnt.mnt_sb;
 	int retval;
 	LIST_HEAD(umount_list);
+	
+#if defined CONFIG_PDI_DRIVER
+	//PACE PATCH
+	// ("pdi_update_mount_point_list %s", mnt->mnt_devname);
+	pdi_update_mount_point_list(mnt->mnt_devname, NULL, 0);
+#endif	
 
 	retval = security_sb_umount(&mnt->mnt, flags);
 	if (retval)
@@ -2187,6 +2198,12 @@
 	else
 		retval = do_new_mount(&path, type_page, flags, mnt_flags,
 				      dev_name, data_page);
+				      
+#if defined CONFIG_PDI_DRIVER
+	//PACE PATCH
+	if (retval == 0) 
+	  pdi_update_mount_point_list(dev_name, dir_name, 1);
+#endif
 dput_out:
 	path_put(&path);
 	return retval;
diff -Naur kernel-3.3-3.0a-ref/include/linux/brcmstb/brcmapi.h kernel-current/include/linux/brcmstb/brcmapi.h
--- kernel-3.3-3.0a-ref/include/linux/brcmstb/brcmapi.h	2013-08-28 01:31:06.000000000 +0200
+++ kernel-current/include/linux/brcmstb/brcmapi.h	2013-11-29 10:10:03.155205923 +0100
@@ -47,6 +47,13 @@
 #define BRCM_RX_HOOK_NETACCEL	0
 #define BRCM_RX_HOOK_EROUTER	1
 
+/* RT031011 Pace change */
+#define FLASH_TYPE_NONE		0
+#define FLASH_TYPE_NOR		1
+#define FLASH_TYPE_NAND		2
+#define FLASH_TYPE_SPI		3
+#define FLASH_TYPE_MAX		FLASH_TYPE_SPI
+
 #if defined(CONFIG_MIPS)
 void __init brcm_free_bootmem(unsigned long addr, unsigned long size);
 void brcm_tlb_init(void);
@@ -86,6 +93,12 @@
 	int			docsis_platform;
 };
 
+/* @RCA Pace change : So we can have a partition map for more than one device */
+struct brcm_mtd_partition_map {
+     int    num_parts;
+     struct mtd_partition * partition_map;
+};
+
 int bmem_find_region(unsigned long addr, unsigned long size);
 int bmem_region_info(int idx, unsigned long *addr, unsigned long *size);
 int bmem_get_page(struct mm_struct *mm, struct vm_area_struct *vma,
@@ -103,6 +116,7 @@
 }
 
 int brcm_alloc_macaddr(u8 *buf);
+int brcm_alloc_moca_macaddr(u8 *buf);
 
 extern spinlock_t brcm_magnum_spinlock;
 
diff -Naur kernel-3.3-3.0a-ref/include/linux/brcmstb/brcmstb.h kernel-current/include/linux/brcmstb/brcmstb.h
--- kernel-3.3-3.0a-ref/include/linux/brcmstb/brcmstb.h	2013-08-28 01:31:06.000000000 +0200
+++ kernel-current/include/linux/brcmstb/brcmstb.h	2013-11-29 10:10:03.155205923 +0100
@@ -727,6 +727,7 @@
 extern unsigned long brcm_eth0_no_mdio;
 extern unsigned char brcm_eth0_phyaddr[CFE_STRING_SIZE];
 extern u8 brcm_primary_macaddr[IFHWADDRLEN];
+extern u8 brcm_moca_macaddr[IFHWADDRLEN];
 
 extern unsigned long brcm_moca_i2c_base;
 extern unsigned long brcm_moca_rf_band;
@@ -844,6 +845,12 @@
 int __init board_get_partition_map(struct mtd_partition **p);
 void __init brcm_wraparound_check(void);
 
+/* RT031011 Pace change */
+#define CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+#if defined CONFIG_PACE_MULTI_DEVICE_MTD_SUPPORT
+int __init board_get_partition_map_pace(struct brcm_mtd_partition_map  **p);
+#endif
+
 void ebi_restore_settings(void);
 
 int __init bchip_strap_flash_type(void);
diff -Naur kernel-3.3-3.0a-ref/include/linux/genid_driver.h kernel-current/include/linux/genid_driver.h
--- kernel-3.3-3.0a-ref/include/linux/genid_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/genid_driver.h	2013-11-29 10:10:03.179205711 +0100
@@ -0,0 +1,24 @@
+
+#ifndef GENID_DRIVER_H
+#define GENID_DRIVER_H
+
+#include <linux/ioctl.h>
+
+/***********************************************************************************************
+ *
+ *  Define
+ *
+ ***********************************************************************************************/
+#define DEVICE_NAME "GENID_DRIVER"
+/***********************************************************************************************
+ *
+ *  Ioctl
+ *
+ ***********************************************************************************************/
+#define GENID_DRIVER_IOR_MAGIC 'z'
+
+#define GENID_GETID           _IO(GENID_DRIVER_IOR_MAGIC, 1)
+
+
+#endif /* GENID_DRIVER_H */
+
diff -Naur kernel-3.3-3.0a-ref/include/linux/Kbuild kernel-current/include/linux/Kbuild
--- kernel-3.3-3.0a-ref/include/linux/Kbuild	2013-08-28 01:31:06.000000000 +0200
+++ kernel-current/include/linux/Kbuild	2013-11-29 10:10:03.247205115 +0100
@@ -142,6 +142,7 @@
 header-y += gen_stats.h
 header-y += generic_serial.h
 header-y += genetlink.h
+header-y += genid_driver.h
 header-y += gfs2_ondisk.h
 header-y += gigaset_dev.h
 header-y += hdlc.h
@@ -224,11 +225,13 @@
 header-y += jffs2.h
 header-y += joystick.h
 header-y += kd.h
+header-y += kdev.h
 header-y += kdev_t.h
 header-y += kernel.h
 header-y += kernelcapi.h
 header-y += keyboard.h
 header-y += keyctl.h
+header-y += kstorman.h
 header-y += l2tp.h
 header-y += limits.h
 header-y += llc.h
@@ -290,6 +293,7 @@
 header-y += patchkey.h
 header-y += pci.h
 header-y += pci_regs.h
+header-y += pdi_driver.h
 header-y += perf_event.h
 header-y += personality.h
 header-y += pfkeyv2.h
@@ -403,3 +407,4 @@
 header-y += x25.h
 header-y += xattr.h
 header-y += xfrm.h
+header-y += sysinfo.h
diff -Naur kernel-3.3-3.0a-ref/include/linux/kdev.h kernel-current/include/linux/kdev.h
--- kernel-3.3-3.0a-ref/include/linux/kdev.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/kdev.h	2013-11-29 10:10:03.247205115 +0100
@@ -0,0 +1,61 @@
+/*
+ *  kdev.h
+ *
+ *  This file contains the implementation of the device 
+ *  interface module with the user space.
+ *
+ *  Created by Pace on 05/09/13.
+ *
+ */
+
+#ifndef KDEV_H
+#define KDEV_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/***********************************************************************************************
+ *
+ *  Structures
+ *
+ ***********************************************************************************************/
+#define KDEV_DEVLIST_MAXSIZE 100
+#define KDEV_STR_MAXSIZE 64
+
+/*
+ *  data for devices list
+ */
+typedef enum
+{
+  KDEV_CHAR_DEV = 0,
+  KDEV_BLOCK_DEV
+} e_kdev_type_t;
+
+typedef struct
+{
+  e_kdev_type_t device_type;
+  char device_name[KDEV_STR_MAXSIZE + 1];
+  int major;
+  int min_minor;
+  int max_minor;
+} kdev_dev_t;
+
+typedef struct
+{
+  size_t devs_nb;
+  kdev_dev_t devs[KDEV_DEVLIST_MAXSIZE];
+} kdev_ioc_getDevices_t;
+
+/***********************************************************************************************
+ *
+ *  Ioctl
+ *
+ ***********************************************************************************************/
+#define KDEV_IOC_MAGIC 'y'
+
+#define KDEV_IOC_GET_ALL_DEVICES    _IOR(KDEV_IOC_MAGIC, 1, char *)
+
+#define KDEV_IOC_MAXNR 1
+
+
+#endif /* KDEV_H */
diff -Naur kernel-3.3-3.0a-ref/include/linux/kstorman.h kernel-current/include/linux/kstorman.h
--- kernel-3.3-3.0a-ref/include/linux/kstorman.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/kstorman.h	2013-11-29 10:10:03.215205396 +0100
@@ -0,0 +1,93 @@
+/*
+ *  kstorman.h
+ *
+ *  This file contains the implementation of the storman 
+ *  interface module with the user space.  
+ *
+ *  Created by Pace on 19/07/13.
+ *
+ */
+
+#ifndef KSTORMAN_H
+#define KSTORMAN_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/***********************************************************************************************
+ *
+ *  Structures
+ *
+ ***********************************************************************************************/
+#define KSTORMAN_MOUNTLIST_MAXSIZE  100
+#define KSTORMAN_BLKDEVLIST_MAXSIZE 100
+#define KSTORMAN_MTDLIST_MAXSIZE    64
+#define KSTORMAN_STR_MAXSIZE 50
+
+/*
+ *  data for mount list
+ */
+typedef struct
+{
+	char device[KSTORMAN_STR_MAXSIZE + 1];
+	char dir[KSTORMAN_STR_MAXSIZE + 1];
+	char type[KSTORMAN_STR_MAXSIZE + 1];
+	int flags;
+} kstorman_mount_t;
+
+typedef struct
+{
+	size_t mounts_nb;
+    kstorman_mount_t mounts[KSTORMAN_MOUNTLIST_MAXSIZE];
+} kstorman_ioc_getmounts_t;
+
+
+/*
+ *  data for block list
+ */
+typedef struct
+{
+	char name[KSTORMAN_STR_MAXSIZE + 1];
+	int major;
+	int minor;
+	char type[KSTORMAN_STR_MAXSIZE + 1];
+	char parent_type[KSTORMAN_STR_MAXSIZE + 1];
+} kstorman_blkdev_t;
+
+typedef struct
+{
+	size_t blkdevs_nb;
+    kstorman_blkdev_t blkdevs[KSTORMAN_BLKDEVLIST_MAXSIZE];
+} kstorman_ioc_getblocks_t;
+
+/*
+ *  data for mtd list
+ */
+typedef struct
+{
+	char name[KSTORMAN_STR_MAXSIZE + 1];
+	int index;
+	unsigned char type;
+} kstorman_mtd_t;
+
+typedef struct
+{
+	size_t mtd_nb;
+    kstorman_mtd_t mtd[KSTORMAN_MTDLIST_MAXSIZE];
+} kstorman_ioc_getmtd_t;
+
+/***********************************************************************************************
+ *
+ *  Ioctl
+ *
+ ***********************************************************************************************/
+#define KSTORMAN_IOC_MAGIC 'y'
+
+#define KSTORMAN_IOC_GETMOUNTS      _IOR(KSTORMAN_IOC_MAGIC,		0,  kstorman_ioc_getmounts_t*)
+#define KSTORMAN_IOC_GETBLOCKS      _IOR(KSTORMAN_IOC_MAGIC,		1,  kstorman_ioc_getblocks_t*)
+#define KSTORMAN_IOC_GETMTD         _IOR(KSTORMAN_IOC_MAGIC,		2,  kstorman_ioc_getmtd_t*)
+
+#define KSTORMAN_IOC_MAXNR 2
+
+
+#endif /* KSTORMAN_H */
diff -Naur kernel-3.3-3.0a-ref/include/linux/mqueue.h kernel-current/include/linux/mqueue.h
--- kernel-3.3-3.0a-ref/include/linux/mqueue.h	2013-08-28 01:31:06.000000000 +0200
+++ kernel-current/include/linux/mqueue.h	2013-11-29 10:10:03.255205045 +0100
@@ -20,7 +20,7 @@
 
 #define MQ_PRIO_MAX 	32768
 /* per-uid limit of kernel memory used by mqueue, in bytes */
-#define MQ_BYTES_MAX	819200
+#define MQ_BYTES_MAX	1179648
 
 struct mq_attr {
 	long	mq_flags;	/* message queue flags			*/
diff -Naur kernel-3.3-3.0a-ref/include/linux/mtd/nand_flash_mapping.h kernel-current/include/linux/mtd/nand_flash_mapping.h
--- kernel-3.3-3.0a-ref/include/linux/mtd/nand_flash_mapping.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/mtd/nand_flash_mapping.h	2013-11-29 10:10:03.155205923 +0100
@@ -0,0 +1,59 @@
+/***********************************************************************
+*       Copyright : PACE plc 2013 (c)
+*                   The copyright of this material is owned by Pace plc.
+*                   This material is regarded as a highly confidential
+*                   trade secret of Pace. It may not be produced, used,
+*                   sold or in any other way exploited or transferred to
+*                   any other third party without prior consent of Pace.
+***********************************************************************/
+
+#ifndef NAND_FLASH_MAPPING_H
+#define NAND_FLASH_MAPPING_H
+
+/* NAND size in KBytes */
+#define NAND_FLASH_SIZE                    (256*1024*1024)
+#define NAND_FLASH_BL_START_ADDRESS        (0)
+
+/* Partition Names */
+#define NAND_FLASH_BL_DAPP_NAME             "dapp"
+#define NAND_FLASH_BL_URDNL_NAME            "urdnl"
+#define NAND_FLASH_LINUX_EPG_NAME           "epg"
+#define NAND_FLASH_LINUX_UI_NAME            "ui"
+#define NAND_FLASH_LINUX_VFS_NAME           "vfs"
+#define NAND_FLASH_LINUX_AXIROS_NAME        "axiros"
+#define NAND_FLASH_BL_DCSP_NAME             "dcsp"
+#define NAND_FLASH_BL_SPARE_NAME            "spare"
+#define NAND_FLASH_LINUX_SCHNG_NAME         "seachange"
+
+/* Fixed Partition Sizes */
+#define NAND_FLASH_BL_DAPP_SIZE             (60*1024*1024)  /* 0x3C00000 */
+#define NAND_FLASH_BL_URDNL_SIZE            (13*1024*1024)  /* 0xD00000 */
+#define NAND_FLASH_BL_BSECK_AND_UTSBL_SIZE  (1*1024*1024)
+#define NAND_FLASH_LINUX_EPG_SIZE           (30*1024*1024)  /* 0x1E00000 */
+#define NAND_FLASH_LINUX_UI_SIZE            (35*1024*1024)  /* 0x2300000 */
+#define NAND_FLASH_LINUX_VFS_SIZE           (4*1024*1024)   /* 0x400000 */
+#define NAND_FLASH_LINUX_AXIROS_SIZE        (1*1024*1024)   /* 0x100000 */
+
+/* Derived Partition Sizes */
+#define NAND_FLASH_BL_DCSP_SIZE            (NAND_FLASH_BL_DAPP_SIZE + NAND_FLASH_BL_URDNL_SIZE + NAND_FLASH_BL_BSECK_AND_UTSBL_SIZE)
+#define NAND_FLASH_BL_USED_SIZE            (NAND_FLASH_BL_DAPP_SIZE + NAND_FLASH_BL_URDNL_SIZE + NAND_FLASH_BL_DCSP_SIZE)
+#define NAND_FLASH_BL_SPARE_SIZE           (NAND_FLASH_BL_USED_SIZE/4)    /* 25% of used area */
+#define NAND_FLASH_BL_TOTAL_SIZE           (NAND_FLASH_BL_USED_SIZE + NAND_FLASH_BL_SPARE_SIZE)
+#define NAND_FLASH_LINUX_SCHNG_SIZE        (NAND_FLASH_SIZE - NAND_FLASH_BL_TOTAL_SIZE - NAND_FLASH_LINUX_EPG_SIZE - NAND_FLASH_LINUX_UI_SIZE - NAND_FLASH_LINUX_VFS_SIZE - NAND_FLASH_LINUX_AXIROS_SIZE)
+#define NAND_FLASH_LINUX_SIZE              (NAND_FLASH_LINUX_SCHNG_SIZE + NAND_FLASH_LINUX_EPG_SIZE + NAND_FLASH_LINUX_UI_SIZE + NAND_FLASH_LINUX_VFS_SIZE + NAND_FLASH_LINUX_AXIROS_SIZE)
+
+/* Pace Boot Loader area */
+#define NAND_FLASH_BL_DAPP_ADDRESS         (NAND_FLASH_BL_START_ADDRESS)
+#define NAND_FLASH_BL_DCSP_ADDRESS         (NAND_FLASH_BL_DAPP_ADDRESS + NAND_FLASH_BL_DAPP_SIZE)
+#define NAND_FLASH_BL_URDNL_ADDRESS        (NAND_FLASH_BL_DCSP_ADDRESS + NAND_FLASH_BL_DCSP_SIZE)
+#define NAND_FLASH_BL_SPARE_ADDRESS        (NAND_FLASH_BL_URDNL_ADDRESS + NAND_FLASH_BL_URDNL_SIZE)
+
+/* Linux (application) area */
+#define NAND_FLASH_LINUX_START_ADDRESS     (NAND_FLASH_BL_SPARE_ADDRESS + NAND_FLASH_BL_SPARE_SIZE)
+#define NAND_FLASH_LINUX_SCHNG_ADDRESS     (NAND_FLASH_LINUX_START_ADDRESS)
+#define NAND_FLASH_LINUX_AXIROS_ADDRESS    (NAND_FLASH_LINUX_SCHNG_ADDRESS + NAND_FLASH_LINUX_SCHNG_SIZE)
+#define NAND_FLASH_LINUX_EPG_ADDRESS       (NAND_FLASH_LINUX_AXIROS_ADDRESS + NAND_FLASH_LINUX_AXIROS_SIZE)
+#define NAND_FLASH_LINUX_UI_ADDRESS        (NAND_FLASH_LINUX_EPG_ADDRESS + NAND_FLASH_LINUX_EPG_SIZE)
+#define NAND_FLASH_LINUX_VFS_ADDRESS       (NAND_FLASH_LINUX_UI_ADDRESS + NAND_FLASH_LINUX_UI_SIZE)
+
+#endif
diff -Naur kernel-3.3-3.0a-ref/include/linux/mtd/nor_flash_mapping.h kernel-current/include/linux/mtd/nor_flash_mapping.h
--- kernel-3.3-3.0a-ref/include/linux/mtd/nor_flash_mapping.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/mtd/nor_flash_mapping.h	2013-11-29 10:10:03.155205923 +0100
@@ -0,0 +1,37 @@
+/***********************************************************************
+*       Copyright : PACE plc 2013 (c)
+*                   The copyright of this material is owned by Pace plc.
+*                   This material is regarded as a highly confidential
+*                   trade secret of Pace. It may not be produced, used,
+*                   sold or in any other way exploited or transferred to
+*                   any other third party without prior consent of Pace.
+***********************************************************************/
+
+#ifndef NOR_FLASH_MAPPING_H
+#define NOR_FLASH_MAPPING_H
+
+/* Partition Names */
+#define NOR_FLASH_SDIF_NAME                "sdif"
+#define NOR_FLASH_UTSBL_NAME               "utsbl"
+#define NOR_FLASH_TBX_NAME                 "tbx"
+#define NOR_FLASH_OSY_NAME                 "osy"
+#define NOR_FLASH_FUT_NAME                 "fut"
+#define NOR_FLASH_BSECK_RELOAD_NAME        "bseckReload"
+
+/* Fixed Partition Sizes */
+#define NOR_FLASH_SDIF_SIZE                0x00010000
+#define NOR_FLASH_UTSBL_SIZE               0x000A0000
+#define NOR_FLASH_TBX_SIZE                 0x00010000
+#define NOR_FLASH_OSY_SIZE                 0x00020000
+#define NOR_FLASH_FUT_SIZE                 0x00010000
+#define NOR_FLASH_BSECK_RELOAD_SIZE        0x00020000
+
+/* Addresses (offsets) */
+#define NOR_FLASH_SDIF_ADDRESS             0x000B0000
+#define NOR_FLASH_UTSBL_ADDRESS            0x002E0000
+#define NOR_FLASH_TBX_ADDRESS              0x00380000
+#define NOR_FLASH_OSY_ADDRESS              0x00390000
+#define NOR_FLASH_FUT_ADDRESS              0x003D0000
+#define NOR_FLASH_BSECK_RELOAD_ADDRESS     0x003E0000
+
+#endif
diff -Naur kernel-3.3-3.0a-ref/include/linux/mtd/pacenand.h kernel-current/include/linux/mtd/pacenand.h
--- kernel-3.3-3.0a-ref/include/linux/mtd/pacenand.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/mtd/pacenand.h	2013-11-29 10:10:03.159205887 +0100
@@ -0,0 +1,224 @@
+/****************************************************************************
+ *                                                                          * 
+ * File        : nand_dev_new.h                                             * 
+ *                                                                          * 
+ * Description : Low level read/write functions for NAND flash using the    *
+ *               NEW Broadcom NAND flash controller                         *
+ *                                                                          * 
+ * Author      : Neil Crossley (crossln1)                                   * 
+ *                                                                          * 
+ * Copyright   : Pace Micro Technology 2007 (c)                             *
+ *                                                                          * 
+ *               The copyright in this material is owned by                 * 
+ *               Pace Microtechnology PLC ("Pace"). This                    * 
+ *               material is regarded as a highly confidential              * 
+ *               trade secret of Pace. It may not be reproduced,            * 
+ *               used, sold or in any other way exploited or                * 
+ *               transferred to any third party without the prior           * 
+ *               written permission of Pace.                                * 
+ *                                                                          * 
+ * Notes       : Thanks to Simon Hemming for the previous driver (and also  * 
+ *               figuring out how the hardware works) as well as John Smith *
+ *               for additional help                                        *
+ *                                                                          * 
+ * History     : Initial Version                                            * 
+ *                                                                          * 
+ ****************************************************************************/
+
+/*******************************
+ * Disallow multiple including *
+ ******************************/
+ 
+#ifndef __NAND_DEV_NEW_INCLUDED__
+#define __NAND_DEV_NEW_INCLUDED__
+
+
+/***********
+ * Defines *
+ ***********/
+
+/* ECC Types */
+
+#define NDR_ECC_TYPE_HAMMING  0
+#define NDR_ECC_TYPE_BCH4     1
+#define NDR_ECC_TYPE_BCH8     2
+#define NDR_ECC_TYPE_BCH12    3
+
+/* ECC Type and Spare area layout */
+
+#define NDR_LAYOUT_HAMMING_16B_SPARE 0
+#define NDR_LAYOUT_BCH4_16B_SPARE    1
+#define NDR_LAYOUT_BCH8_27B_SPARE    2
+#define NDR_LAYOUT_BCH8_32B_SPARE    3
+#define NDR_LAYOUT_BCH12_27B_SPARE   4
+#define NDR_LAYOUT_BCH12_32B_SPARE   5
+
+/* Flags for read/write */
+
+#define NDR_FLAGS_VERIFY            1
+#define NDR_FLAGS_CRC               2
+#define NDR_FLAGS_USEDMARKER        4
+#define NDR_FLAGS_LONGREADWRITE     0x100
+#define NDR_FLAGS_SYNCSPAREONWRITE  0x200
+
+
+/*************
+ * DataTypes *
+ *************/
+
+#ifndef __BLI_TYPES_DEFINED__
+#define __BLI_TYPES_DEFINED__
+#define BLI_INT8    int8_t
+#define BLI_UINT8   uint8_t
+#define BLI_INT16   int16_t
+#define BLI_UINT16  uint16_t
+#define BLI_INT32   int32_t
+#define BLI_UINT32  uint32_t
+#define BLI_INT64   int64_t
+#define BLI_UINT64  uint64_t
+#define BLI_VOID    void
+#define BLI_BOOL    uint32_t
+#define TRUE        true
+#define FALSE       false
+#endif
+
+
+/**************
+ * Structures *
+ **************/
+
+/* Device information structure, returned by nand_get_info 
+ 
+   Device_ID is as follows ...
+   
+    Byte 0 = Manufacturer code
+    Byte 1 = Device code
+    Byte 2 = May be used on some devices for extended device info
+    Byte 3 = as above                                              */
+ 
+typedef struct
+{
+  BLI_UINT8   Device_ID[4];               /* See Notes Above                                          */
+  BLI_UINT64  Device_Size;                /* Device size in bytes                                     */
+  BLI_UINT32  Block_Size;                 /* Block size in bytes                                      */
+  BLI_UINT32  Block_Count;                /* Number of blocks on device                               */
+  BLI_UINT32  Page_Size;                  /* Page size in bytes                                       */
+  BLI_UINT32  Page_Count;                 /* Number of pages on device                                */
+  BLI_UINT32  Virt_Page_Size;             /* Virtual page size in bytes                               */
+  BLI_UINT32  Virt_Page_Count;            /* Number of virtual pages on device                        */
+  BLI_UINT32  Pages_Per_Block;            /* Number of pages per block                                */
+  BLI_UINT32  Virt_Pages_Per_Page;        /* Number of virtual pages per page                         */
+  BLI_UINT32  Virt_Pages_Per_Block;       /* Number of virtual pages per block                        */
+  BLI_UINT32  ECC_Spare_Area_Layout;      /* ECC Type + spare area layout                             */
+  BLI_UINT32  ECC_Type;                   /* Type of ECC used                                         */
+  BLI_UINT32  ECC_Bits;                   /* Number of bits ECC can handle                            */
+  BLI_BOOL    ECC_Enabled;                /* ECC Enabled readback                                     */
+  BLI_UINT32  ECC_ErrorBits;              /* Highest number of error bits per page after last read op */
+  BLI_UINT32  Spare_Area_Size;            /* Size of the spare area                                   */
+  BLI_UINT32  Spare_Area_Free;            /* Number of free bytes in spare area                       */
+  BLI_UINT32  Spare_Area_Free_Ext;        /* Number of free bytes in spare area (extended mode)       */
+  BLI_UINT32  Spare_Area_ECC_Bytes;       /* Number of bytes used to store ECC data                   */  
+  BLI_UINT32  Spare_Free_Mask[4];         /* Spare area free bitmask                                  */
+  BLI_UINT8   Spare_Area_Bytes[128];      /* Spare area free bytes                                    */
+  BLI_UINT32  Spare_Free_Mask_Ext[4];     /* Spare area free bitmask (extended mode)                  */
+  BLI_UINT8   Spare_Area_Bytes_Ext[128];  /* Spare area free bytes (extended mode)                    */
+  BLI_UINT8   Spare_Area_ECC_bytes[128];  /* Spare area ECC byte positions                            */
+} NAND_DEV_INFO; 
+
+
+/***************
+ * Return Codes *
+ ***************/
+
+typedef enum _tag_NDR_ERROR
+{
+  /* Success */
+  
+  NDR_SUCCESS                   = 0,
+  
+  /* Return codes from ...
+  
+     nand_dev_read_block
+     nand_dev_read_page
+     nand_dev_copy_block  */
+  
+  NDR_CORRECTABLE_ERROR         = 1,
+  NDR_UNCORRECTABLE_ERROR       = 2,
+  
+  /* Return codes from nand_dev_is_block_bad */
+  
+  NDR_BLOCK_IS_GOOD             = 0,
+  NDR_BLOCK_IS_BAD              = 1,
+  
+  /* Return codes from nand_dev_is_vpage_used */
+  
+  NDR_VPAGE_NOT_USED            = 0,
+  NDR_VPAGE_IS_USED             = 1,
+  NDR_VPAGE_IS_DEACTIVATED      = 2,
+  
+  /* Return codes from ...
+  
+     nand_dev_is_block_erased 
+     nand_dev_is_page_erased   */
+  
+  NDR_NOT_ERASED                = 0,
+  NDR_IS_ERASED                 = 1,
+  
+  /* Negative error code - Always Fatal */
+  
+  NDR_NOT_INITIALISED           = -1,
+  NDR_ALREADY_INITIALISED       = -2, 
+  NDR_UNSUPPORTED_FUNCTION      = -3,
+  NDR_UNSUPPORTED_DEVICE        = -4, 
+  NDR_ILLEGAL_BLOCK_OR_PAGE     = -5,
+  NDR_ERROR_COPY_TO_SAME_BLOCK  = -6,
+  NDR_ILLEGAL_OFFSET            = -7,  
+  NDR_ILLEGAL_LENGTH            = -8,
+  NDR_CANT_CROSS_BOUNDARY       = -9,
+  NDR_DEVICE_NOT_READY          = -10,
+  NDR_DEVICE_PROGRAM_ERROR      = -11,
+  NDR_DEVICE_ECC_ERROR          = -12,
+  NDR_DEVICE_VERIFY_ERROR       = -13,
+  NDR_DEVICE_ERASE_ERROR        = -14,
+  NDR_WRITE_PROTECTED           = -15,
+  NDR_NO_NAND_PRESENT           = -16,
+  NDR_FATAL_ERROR               = -17,
+  NDR_SYS_ERROR                 = -18,
+  NDR_ILLEGAL_PARAMETER         = -19,
+} NDR_ERROR;
+
+
+/**************
+ * Prototypes *
+ **************/
+
+extern NDR_ERROR  nand_dev_init(BLI_VOID);
+extern NDR_ERROR  nand_dev_get_info(NAND_DEV_INFO **info);
+extern NDR_ERROR  nand_dev_enable_ecc(BLI_BOOL enable);
+extern NDR_ERROR  nand_dev_enable_crc(BLI_BOOL enable);
+extern NDR_ERROR  nand_dev_read_block(BLI_UINT32 block, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_read_page(BLI_UINT32 page, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_read_vpage(BLI_UINT32 vpage, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_read_anywhere(BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_write_block(BLI_UINT32 block, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_write_page(BLI_UINT32 page, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_write_vpage(BLI_UINT32 vpage, BLI_VOID *data, BLI_UINT32 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_write_anywhere(BLI_VOID *data, BLI_UINT64 offset, BLI_UINT32 length, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_erase_block(BLI_UINT32 block);
+extern NDR_ERROR  nand_dev_copy_block(BLI_UINT32 destblock, BLI_UINT32 sourceblock, BLI_UINT32 vpignore, BLI_UINT32 flags);
+extern NDR_ERROR  nand_dev_is_vpage_used(BLI_UINT32 vpage);
+extern NDR_ERROR  nand_dev_read_spare(BLI_UINT32 vpage, BLI_VOID* data);
+extern NDR_ERROR  nand_dev_write_spare(BLI_UINT32 vpage, BLI_VOID* data);
+extern NDR_ERROR  nand_dev_is_block_erased(BLI_UINT32 block);
+extern NDR_ERROR  nand_dev_is_page_erased(BLI_UINT32 page);
+extern NDR_ERROR  nand_dev_is_vpage_erased(BLI_UINT32 vpage);
+extern NDR_ERROR  nand_dev_is_block_bad(BLI_UINT32 block);
+extern NDR_ERROR  nand_dev_mark_block_bad(BLI_UINT32 block);
+extern BLI_UINT32 nand_dev_calc_crc32(BLI_VOID* data, BLI_UINT32 crc, BLI_UINT32 count);
+
+
+/**************
+ * Endifs etc *
+ **************/
+
+#endif /*#ifndef __NAND_DEV_NEW_INCLUDED__*/
diff -Naur kernel-3.3-3.0a-ref/include/linux/pdi_driver.h kernel-current/include/linux/pdi_driver.h
--- kernel-3.3-3.0a-ref/include/linux/pdi_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/pdi_driver.h	2013-11-29 10:10:03.171205783 +0100
@@ -0,0 +1,47 @@
+#ifndef PDI_DRIVER_H
+#define PDI_DRIVER_H
+
+#include <linux/ioctl.h>
+
+/***********************************************************************************************
+ *
+ *  Define
+ *
+ ***********************************************************************************************/
+#define MAX_DEVICE_NUMBER 5
+#define MAX_AUTHORIZED_NUMBER 12
+#define MAX_NAME_LEN  64
+#define MAX_BUF_SIZE MAX_FS_NUMBER * MAX_NAME_LEN
+#define KEY_SIZE 128
+#define UUID_SIZE 16
+
+#define DEVICE_NAME "PDI_DRIVER"
+#define SD_INDEX 3
+
+#define STRINGIFY(x) #x
+#define TOSTRING(x) STRINGIFY(x)
+
+#ifdef PDI_DEBUG
+#define pdi_dbg(fmt, arg...) do { \
+    printk(KERN_INFO "< [%s] %s > " fmt , DEVICE_NAME, __FUNCTION__, ## arg); \
+  } while (0)
+#else
+#define pdi_dbg(fmt, arg...)
+#endif
+
+/***********************************************************************************************
+ *
+ *  Ioctl
+ *
+ ***********************************************************************************************/
+#define PDI_DRIVER_IOR_MAGIC 'y'
+
+#define PDI_DRIVER_IOR_GET_DEV_LIST           _IOR(PDI_DRIVER_IOR_MAGIC, 1, char *)
+#define PDI_DRIVER_IOR_GET_MOUNTPOINT_LIST    _IOR(PDI_DRIVER_IOR_MAGIC, 2, char *)
+#define PDI_DRIVER_IOW_SET_KEY                _IOW(PDI_DRIVER_IOR_MAGIC, 3, char *)
+#define PDI_DRIVER_IOR_GET_UUID               _IOW(PDI_DRIVER_IOR_MAGIC, 4, char *)
+#define PDI_DRIVER_IOR_GET_AUTODIAG_STATUS    _IOR(PDI_DRIVER_IOR_MAGIC, 5, char *)
+#define PDI_DRIVER_IOR_GET_ALL_DEVICES        _IOR(PDI_DRIVER_IOR_MAGIC, 6, char *)
+
+#endif /* PDI_DRIVER_H */
+
diff -Naur kernel-3.3-3.0a-ref/include/linux/sysinfo.h kernel-current/include/linux/sysinfo.h
--- kernel-3.3-3.0a-ref/include/linux/sysinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel-current/include/linux/sysinfo.h	2013-11-29 10:10:03.235205220 +0100
@@ -0,0 +1,79 @@
+/*
+ *  sysinfo.h
+ *
+ *  This file contains the implementation of the AON read/writer 
+ *  interface module with the user space.  
+ *
+ *  Created by Samir MOUHOUNE on 25/06/2013.
+ *  Copyright 2013 Pace plc. All rights reserved.
+ *
+ *  The copyright in this material is owned by Pace
+ *  plc ("Pace"). This material is regarded as a
+ *  highly confidential trade secret of Pace. It may not be
+ *  reproduced, used, sold or in any other way exploited or
+ *  transferred to any third party without the prior
+ *  written permission of Pace.
+ *
+ */
+
+#ifndef sysinfo_H
+#define sysinfo_H
+
+#include <linux/ioctl.h>
+
+
+/***********************************************************************************************
+ *
+ *  Ioctl
+ *
+ ***********************************************************************************************/
+#define MAX_IOCTL_CMD_NMBR 6
+#define sysinfo_IOC_MAGIC 'q'
+#define GET_NB_PROC _IOR(sysinfo_IOC_MAGIC, 1, unsigned long)
+#define GET_NB_CPU _IOR(sysinfo_IOC_MAGIC, 2, unsigned long)
+#define GET_MEMORY_STATUS _IOR(sysinfo_IOC_MAGIC, 3, unsigned long)
+#define GET_PROCESS_STATUS _IOR(sysinfo_IOC_MAGIC, 4, unsigned long)
+#define GET_PROCESSOR _IOR(sysinfo_IOC_MAGIC, 5, unsigned long)
+#define CPU_REBOOT_CMD _IOR(sysinfo_IOC_MAGIC, 6, unsigned long)
+
+
+typedef struct procInfo
+{
+   int cpu;
+	unsigned long  user;
+	unsigned long  nice; 
+	unsigned long  system; 
+	unsigned long  idle; 
+	unsigned long  iowait; 
+	unsigned long  irq; 
+	unsigned long  softirq; 
+	unsigned long  steal;
+	unsigned long  guest; 
+	unsigned long  guest_nice;
+	unsigned long  temperature;
+   int processes;
+   int nbr_running;
+   int nbr_iowait;
+   char arch [10];
+}procInfo;
+
+typedef struct taskInfo
+{
+	char state[10];
+	char comm[50];
+	pid_t pid;
+	int prio; 
+	unsigned long vsize;
+	unsigned int CPUTime;
+	unsigned long cpuusage;
+}taskInfo;
+
+
+typedef struct memInfo
+{
+	unsigned long freeram;
+	unsigned long totalram;
+}memInfo;
+
+
+#endif /* sysinfo_H */
diff -Naur kernel-3.3-3.0a-ref/include/linux/usbdevice_fs.h kernel-current/include/linux/usbdevice_fs.h
--- kernel-3.3-3.0a-ref/include/linux/usbdevice_fs.h	2013-08-28 01:31:07.000000000 +0200
+++ kernel-current/include/linux/usbdevice_fs.h	2013-11-29 10:10:03.139206063 +0100
@@ -75,6 +75,30 @@
 	unsigned char slow;
 };
 
+#define CONFIG_PACE_TT_USB_COMMANDS 1
+/* RT210911 Pace change */
+#if defined (CONFIG_PACE_TT_USB_COMMANDS)
+typedef enum {
+   TEST_SPEED = 0,
+   TEST_POWER_OFF,
+   TEST_POWER_ON,
+   TEST_PORT_STATUS,
+   TEST_VENDOR_ID,
+   TEST_DEVICE_MS,
+   TEST_DEVICE_CONNECTED,
+   TEST_STRING_SERNUM,
+   TEST_STRING_PROD,
+   TEST_STRING_MANUF,
+   TEST_LAST
+} usb_test_code;
+
+struct usbdevfs_usb_test {
+   int port_num;
+   usb_test_code action;
+   unsigned int response;
+   char * pBuf;
+};
+#endif
 #define USBDEVFS_URB_SHORT_NOT_OK	0x01
 #define USBDEVFS_URB_ISO_ASAP		0x02
 #define USBDEVFS_URB_BULK_CONTINUATION	0x04
@@ -204,4 +228,7 @@
 #define USBDEVFS_CONNECT           _IO('U', 23)
 #define USBDEVFS_CLAIM_PORT        _IOR('U', 24, unsigned int)
 #define USBDEVFS_RELEASE_PORT      _IOR('U', 25, unsigned int)
+#if defined (CONFIG_PACE_TT_USB_COMMANDS)
+   #define USBDEVFS_TEST              _IOWR('U', 26, struct usbdevfs_usb_test)
+#endif //#ifdef TT_USB_SUPPORT
 #endif /* _LINUX_USBDEVICE_FS_H */
diff -Naur kernel-3.3-3.0a-ref/include/net/inet_connection_sock.h kernel-current/include/net/inet_connection_sock.h
--- kernel-3.3-3.0a-ref/include/net/inet_connection_sock.h	2013-08-28 01:31:07.000000000 +0200
+++ kernel-current/include/net/inet_connection_sock.h	2013-11-29 10:10:03.235205220 +0100
@@ -23,7 +23,8 @@
 #include <net/inet_sock.h>
 #include <net/request_sock.h>
 
-#define INET_CSK_DEBUG 1
+
+//#define INET_CSK_DEBUG 1
 
 /* Cancel timers, when they are not required. */
 #undef INET_CSK_CLEAR_TIMERS
diff -Naur kernel-3.3-3.0a-ref/include/scsi/scsi_host.h kernel-current/include/scsi/scsi_host.h
--- kernel-3.3-3.0a-ref/include/scsi/scsi_host.h	2013-08-28 01:31:07.000000000 +0200
+++ kernel-current/include/scsi/scsi_host.h	2013-11-29 10:10:03.171205783 +0100
@@ -49,6 +49,10 @@
 	SCSI_QDEPTH_RAMP_UP,	/* scsi-ml requested due to threshold event */
 };
 
+#if defined CONFIG_PDI_DRIVER
+#define MAX_LEN 42
+#endif
+
 struct scsi_host_template {
 	struct module *module;
 	const char *name;
@@ -514,6 +518,10 @@
 	 *   scsi_netlink.h
 	 */
 	u64 vendor_id;
+	
+#if defined CONFIG_PDI_DRIVER
+    char pdi_name[MAX_LEN];
+#endif
 };
 
 /*
diff -Naur kernel-3.3-3.0a-ref/security/commoncap.c kernel-current/security/commoncap.c
--- kernel-3.3-3.0a-ref/security/commoncap.c	2013-08-28 01:31:07.000000000 +0200
+++ kernel-current/security/commoncap.c	2013-11-29 10:10:03.175205747 +0100
@@ -30,6 +30,10 @@
 #include <linux/user_namespace.h>
 #include <linux/personality.h>
 
+#if defined CONFIG_PDI_MNG_SH
+extern unsigned short pdi_cal_caps(struct linux_binprm *bprm, const struct cred *old); 
+#endif
+
 /*
  * If a non-root user executes a setuid-root binary in
  * !secure(SECURE_NOROOT) mode, then we raise capabilities.
@@ -270,8 +274,17 @@
  */
 static inline void bprm_clear_caps(struct linux_binprm *bprm)
 {
+#if defined CONFIG_PDI_MNG_SH
+  //  printk("========================>bprm_clear_caps\n");
+  if (!pdi_cal_caps(bprm, NULL))
+    {
+      cap_clear(bprm->cred->cap_permitted);
+      bprm->cap_effective = false;
+    }
+#else
 	cap_clear(bprm->cred->cap_permitted);
 	bprm->cap_effective = false;
+#endif
 }
 
 /**
@@ -532,7 +545,16 @@
 	if (effective)
 		new->cap_effective = new->cap_permitted;
 	else
-		cap_clear(new->cap_effective);
+	{
+#if defined CONFIG_PDI_MNG_SH
+        if(!pdi_cal_caps(bprm, old))
+        {
+            cap_clear(new->cap_effective);
+        }
+#else
+	    cap_clear(new->cap_effective);
+#endif
+	  }	
 	bprm->cap_effective = effective;
 
 	/*
diff -Naur linux/arch/mips/brcmstb/Makefile linux2/arch/mips/brcmstb/Makefile
--- linux/arch/mips/brcmstb/Makefile	2013-08-28 01:30:56.000000000 +0200
+++ linux2/arch/mips/brcmstb/Makefile	2013-12-02 14:35:08.776251510 +0100
@@ -1,3 +1,4 @@
+ccflags-y := -Wno-error=array-bounds
 obj-y			+= prom.o bmips.o memory.o irq.o time.o
 obj-$(CONFIG_BRCM_HAS_STANDBY)	+= standby.o
 obj-$(CONFIG_BRCM_HAS_AON) += s3_standby.o
diff --git a/arch/mips/kernel/mips_ksyms.c b/arch/mips/kernel/mips_ksyms.c
index 57ba13e..3fc1691 100644
--- a/arch/mips/kernel/mips_ksyms.c
+++ b/arch/mips/kernel/mips_ksyms.c
@@ -5,7 +5,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 97, 98, 99, 2000, 01, 03, 04, 05 by Ralf Baechle
+ * Copyright (C) 1996, 97, 98, 99, 2000, 01, 03, 04, 05, 12 by Ralf Baechle
  * Copyright (C) 1999, 2000, 01 Silicon Graphics, Inc.
  */
 #include <linux/interrupt.h>
@@ -35,6 +35,12 @@ EXPORT_SYMBOL(memmove);
 EXPORT_SYMBOL(kernel_thread);
 
 /*
+ * Functions that operate on entire pages.  Mostly used by memory management.
+ */
+EXPORT_SYMBOL(clear_page);
+EXPORT_SYMBOL(copy_page);
+
+/*
  * Userspace access stuff.
  */
 EXPORT_SYMBOL(__copy_user);
diff --git a/arch/mips/mm/Makefile b/arch/mips/mm/Makefile
index 4aa2028..fd6203f 100644
--- a/arch/mips/mm/Makefile
+++ b/arch/mips/mm/Makefile
@@ -3,8 +3,8 @@
 #
 
 obj-y				+= cache.o dma-default.o extable.o fault.o \
-				   gup.o init.o mmap.o page.o tlbex.o \
-				   tlbex-fault.o uasm.o
+				   gup.o init.o mmap.o page.o page-funcs.o \
+				   tlbex.o tlbex-fault.o uasm.o
 
 obj-$(CONFIG_32BIT)		+= ioremap.o pgtable-32.o
 obj-$(CONFIG_64BIT)		+= pgtable-64.o
diff --git a/arch/mips/mm/page-funcs.S b/arch/mips/mm/page-funcs.S
new file mode 100644
index 0000000..48a6b38
--- /dev/null
+++ b/arch/mips/mm/page-funcs.S
@@ -0,0 +1,50 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Micro-assembler generated clear_page/copy_page functions.
+ *
+ * Copyright (C) 2012  MIPS Technologies, Inc.
+ * Copyright (C) 2012  Ralf Baechle <ralf@linux-mips.org>
+ */
+#include <asm/asm.h>
+#include <asm/regdef.h>
+
+#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
+#define cpu_clear_page_function_name	clear_page_cpu
+#define cpu_copy_page_function_name	copy_page_cpu
+#else
+#define cpu_clear_page_function_name	clear_page
+#define cpu_copy_page_function_name	copy_page
+#endif
+
+/*
+ * Maximum sizes:
+ *
+ * R4000 128 bytes S-cache:		0x058 bytes
+ * R4600 v1.7:				0x05c bytes
+ * R4600 v2.0:				0x060 bytes
+ * With prefetching, 16 word strides	0x120 bytes
+ */
+EXPORT(__clear_page_start)
+LEAF(cpu_clear_page_function_name)
+1:	j	1b		/* Dummy, will be replaced. */
+	.space 288
+END(cpu_clear_page_function_name)
+EXPORT(__clear_page_end)
+
+/*
+ * Maximum sizes:
+ *
+ * R4000 128 bytes S-cache:		0x11c bytes
+ * R4600 v1.7:				0x080 bytes
+ * R4600 v2.0:				0x07c bytes
+ * With prefetching, 16 word strides	0x540 bytes
+ */
+EXPORT(__copy_page_start)
+LEAF(cpu_copy_page_function_name)
+1:	j	1b		/* Dummy, will be replaced. */
+	.space 1344
+END(cpu_copy_page_function_name)
+EXPORT(__copy_page_end)
diff --git a/arch/mips/mm/page.c b/arch/mips/mm/page.c
index cc0b626..98f530e 100644
--- a/arch/mips/mm/page.c
+++ b/arch/mips/mm/page.c
@@ -6,6 +6,7 @@
  * Copyright (C) 2003, 04, 05 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2007  Maciej W. Rozycki
  * Copyright (C) 2008  Thiemo Seufer
+ * Copyright (C) 2012  MIPS Technologies, Inc.
  */
 #include <linux/init.h>
 #include <linux/kernel.h>
@@ -71,45 +72,6 @@ static struct uasm_reloc __cpuinitdata relocs[5];
 #define cpu_is_r4600_v1_x()	((read_c0_prid() & 0xfffffff0) == 0x00002010)
 #define cpu_is_r4600_v2_x()	((read_c0_prid() & 0xfffffff0) == 0x00002020)
 
-/*
- * Maximum sizes:
- *
- * R4000 128 bytes S-cache:		0x058 bytes
- * R4600 v1.7:				0x05c bytes
- * R4600 v2.0:				0x060 bytes
- * With prefetching, 16 word strides	0x120 bytes
- */
-
-static u32 clear_page_array[0x120 / 4];
-
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
-void clear_page_cpu(void *page) __attribute__((alias("clear_page_array")));
-#else
-void clear_page(void *page) __attribute__((alias("clear_page_array")));
-#endif
-
-EXPORT_SYMBOL(clear_page);
-
-/*
- * Maximum sizes:
- *
- * R4000 128 bytes S-cache:		0x11c bytes
- * R4600 v1.7:				0x080 bytes
- * R4600 v2.0:				0x07c bytes
- * With prefetching, 16 word strides	0x540 bytes
- */
-static u32 copy_page_array[0x540 / 4];
-
-#ifdef CONFIG_SIBYTE_DMA_PAGEOPS
-void
-copy_page_cpu(void *to, void *from) __attribute__((alias("copy_page_array")));
-#else
-void copy_page(void *to, void *from) __attribute__((alias("copy_page_array")));
-#endif
-
-EXPORT_SYMBOL(copy_page);
-
-
 static int pref_bias_clear_store __cpuinitdata;
 static int pref_bias_copy_load __cpuinitdata;
 static int pref_bias_copy_store __cpuinitdata;
@@ -282,10 +244,15 @@ static inline void __cpuinit build_clear_pref(u32 **buf, int off)
 		}
 }
 
+extern u32 __clear_page_start;
+extern u32 __clear_page_end;
+extern u32 __copy_page_start;
+extern u32 __copy_page_end;
+
 void __cpuinit build_clear_page(void)
 {
 	int off;
-	u32 *buf = (u32 *)&clear_page_array;
+	u32 *buf = &__clear_page_start;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
 	int i;
@@ -356,17 +323,17 @@ void __cpuinit build_clear_page(void)
 	uasm_i_jr(&buf, RA);
 	uasm_i_nop(&buf);
 
-	BUG_ON(buf > clear_page_array + ARRAY_SIZE(clear_page_array));
+	BUG_ON(buf > &__clear_page_end);
 
 	uasm_resolve_relocs(relocs, labels);
 
 	pr_debug("Synthesized clear page handler (%u instructions).\n",
-		 (u32)(buf - clear_page_array));
+		 (u32)(buf - &__clear_page_start));
 
 	pr_debug("\t.set push\n");
 	pr_debug("\t.set noreorder\n");
-	for (i = 0; i < (buf - clear_page_array); i++)
-		pr_debug("\t.word 0x%08x\n", clear_page_array[i]);
+	for (i = 0; i < (buf - &__clear_page_start); i++)
+		pr_debug("\t.word 0x%08x\n", (&__clear_page_start)[i]);
 	pr_debug("\t.set pop\n");
 }
 
@@ -427,7 +394,7 @@ static inline void build_copy_store_pref(u32 **buf, int off)
 void __cpuinit build_copy_page(void)
 {
 	int off;
-	u32 *buf = (u32 *)&copy_page_array;
+	u32 *buf = &__copy_page_start;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
 	int i;
@@ -595,21 +562,23 @@ void __cpuinit build_copy_page(void)
 	uasm_i_jr(&buf, RA);
 	uasm_i_nop(&buf);
 
-	BUG_ON(buf > copy_page_array + ARRAY_SIZE(copy_page_array));
+	BUG_ON(buf > &__copy_page_end);
 
 	uasm_resolve_relocs(relocs, labels);
 
 	pr_debug("Synthesized copy page handler (%u instructions).\n",
-		 (u32)(buf - copy_page_array));
+		 (u32)(buf - &__copy_page_start));
 
 	pr_debug("\t.set push\n");
 	pr_debug("\t.set noreorder\n");
-	for (i = 0; i < (buf - copy_page_array); i++)
-		pr_debug("\t.word 0x%08x\n", copy_page_array[i]);
+	for (i = 0; i < (buf - &__copy_page_start); i++)
+		pr_debug("\t.word 0x%08x\n", (&__copy_page_start)[i]);
 	pr_debug("\t.set pop\n");
 }
 
 #ifdef CONFIG_SIBYTE_DMA_PAGEOPS
+extern void clear_page_cpu(void *page);
+extern void copy_page_cpu(void *to, void *from);
 
 /*
  * Pad descriptors to cacheline, since each is exclusively owned by a
