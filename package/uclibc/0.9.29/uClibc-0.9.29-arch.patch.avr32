diff --git a/Rules.mak b/Rules.mak
index d054bbb..55381cf 100644
--- a/Rules.mak
+++ b/Rules.mak
@@ -313,6 +313,12 @@ ifeq ($(TARGET_ARCH),frv)
 	UCLIBC_LDSO=ld.so.1
 endif
 
+ifeq ($(strip $(TARGET_ARCH)),avr32)
+	CPU_CFLAGS-$(CONFIG_AVR32_AP7)	+= -march=ap
+	CPU_CFLAGS-$(CONFIG_LINKRELAX)	+= -mrelax
+	CPU_LDFLAGS-$(CONFIG_LINKRELAX)	+= --relax
+endif
+
 # Keep the check_gcc from being needlessly executed
 ifndef PIEFLAG
 ifneq ($(UCLIBC_BUILD_PIE),y)
diff --git a/extra/Configs/Config.avr32 b/extra/Configs/Config.avr32
new file mode 100644
index 0000000..8d70e6e
--- /dev/null
+++ b/extra/Configs/Config.avr32
@@ -0,0 +1,31 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	string
+	default "avr32"
+
+config FORCE_OPTIONS_FOR_ARCH
+	bool
+	default y
+	select ARCH_BIG_ENDIAN
+	select FORCE_SHAREABLE_TEXT_SEGMENTS
+
+config ARCH_CFLAGS
+	string
+
+choice
+	prompt "Target CPU Type"
+	default CONFIG_AVR32_AP7
+
+config CONFIG_AVR32_AP7
+	bool "AVR32 AP7"
+	select ARCH_HAS_MMU
+
+endchoice
+
+config LINKRELAX
+	bool "Enable linker optimizations"
+	default y
diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 8eab394..10c9f7b 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -16,6 +16,9 @@ config TARGET_alpha
 config TARGET_arm
 	bool "arm"
 
+config TARGET_avr32
+	bool "avr32"
+
 config TARGET_bfin
 	bool "bfin"
 
@@ -92,6 +95,10 @@ if TARGET_arm
 source "extra/Configs/Config.arm"
 endif
 
+if TARGET_avr32
+source "extra/Configs/Config.avr32"
+endif
+
 if TARGET_bfin
 source "extra/Configs/Config.bfin"
 endif
diff --git a/extra/Configs/defconfigs/avr32 b/extra/Configs/defconfigs/avr32
new file mode 100644
index 0000000..0b890a2
--- /dev/null
+++ b/extra/Configs/defconfigs/avr32
@@ -0,0 +1 @@
+TARGET_avr32=y
diff --git a/include/elf.h b/include/elf.h
index 19805d7..ab90160 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -354,6 +354,8 @@ typedef struct
 /* NIOS magic number - no EABI available.  */
 #define EM_NIOS32	0xFEBB
 
+#define EM_AVR32	0x18ad
+
 /* V850 backend magic number.  Written in the absense of an ABI.  */
 #define EM_CYGNUS_V850 0x9080
 
@@ -2828,6 +2830,55 @@ typedef Elf32_Addr Elf32_Conflict;
 /* Keep this the last entry.  */
 #define R_V850_NUM		25
 
+/* Atmel AVR32 relocations.  */
+#define R_AVR32_NONE		0
+#define R_AVR32_32		1
+#define R_AVR32_16		2
+#define R_AVR32_8		3
+#define R_AVR32_32_PCREL	4
+#define R_AVR32_16_PCREL	5
+#define R_AVR32_8_PCREL		6
+#define R_AVR32_DIFF32		7
+#define R_AVR32_DIFF16		8
+#define R_AVR32_DIFF8		9
+#define R_AVR32_GOT32		10
+#define R_AVR32_GOT16		11
+#define R_AVR32_GOT8		12
+#define R_AVR32_21S		13
+#define R_AVR32_16U		14
+#define R_AVR32_16S		15
+#define R_AVR32_8S		16
+#define R_AVR32_8S_EXT		17
+#define R_AVR32_22H_PCREL	18
+#define R_AVR32_18W_PCREL	19
+#define R_AVR32_16B_PCREL	20
+#define R_AVR32_16N_PCREL	21
+#define R_AVR32_14UW_PCREL	22
+#define R_AVR32_11H_PCREL	23
+#define R_AVR32_10UW_PCREL	24
+#define R_AVR32_9H_PCREL	25
+#define R_AVR32_9UW_PCREL	26
+#define R_AVR32_HI16		27
+#define R_AVR32_LO16		28
+#define R_AVR32_GOTPC		29
+#define R_AVR32_GOTCALL		30
+#define R_AVR32_LDA_GOT		31
+#define R_AVR32_GOT21S		32
+#define R_AVR32_GOT18SW		33
+#define R_AVR32_GOT16S		34
+#define R_AVR32_GOT7UW		35
+#define R_AVR32_32_CPENT	36
+#define R_AVR32_CPCALL		37
+#define R_AVR32_16_CP		38
+#define R_AVR32_9W_CP		39
+#define R_AVR32_RELATIVE	40
+#define R_AVR32_GLOB_DAT	41
+#define R_AVR32_JMP_SLOT	42
+#define R_AVR32_ALIGN		43
+#define R_AVR32_NUM		44
+
+/* AVR32 dynamic tags */
+#define DT_AVR32_GOTSZ		0x70000001 /* Total size of GOT in bytes */
 
 /* Renesas H8/300 Relocations */
 #define R_H8_NONE       0
diff --git a/ldso/include/dl-string.h b/ldso/include/dl-string.h
index 32c5bf8..eb43bd9 100644
--- a/ldso/include/dl-string.h
+++ b/ldso/include/dl-string.h
@@ -285,7 +285,8 @@ static __always_inline char * _dl_simple_ltoahex(char * local, unsigned long i)
 /* On some arches constant strings are referenced through the GOT.
  * This requires that load_addr must already be defined... */
 #if defined(mc68000)  || defined(__arm__) || defined(__thumb__) || \
-    defined(__mips__) || defined(__sh__)  || defined(__powerpc__)
+    defined(__mips__) || defined(__sh__)  || defined(__powerpc__) || \
+	defined(__avr32__)
 # define CONSTANT_STRING_GOT_FIXUP(X) \
 	if ((X) < (const char *) load_addr) (X) += load_addr
 # define NO_EARLY_SEND_STDERR
diff --git a/ldso/include/dl-syscall.h b/ldso/include/dl-syscall.h
index b42416a..4404219 100644
--- a/ldso/include/dl-syscall.h
+++ b/ldso/include/dl-syscall.h
@@ -55,69 +55,69 @@
    dynamic linking at all, so we cannot return any error codes.
    We just punt if there is an error. */
 #define __NR__dl_exit __NR_exit
-static inline _syscall1(void, _dl_exit, int, status);
+static __always_inline _syscall1(void, _dl_exit, int, status);
 
 #define __NR__dl_close __NR_close
-static inline _syscall1(int, _dl_close, int, fd);
+static __always_inline _syscall1(int, _dl_close, int, fd);
 
 #define __NR__dl_open __NR_open
-static inline _syscall3(int, _dl_open, const char *, fn, int, flags,
+static __always_inline _syscall3(int, _dl_open, const char *, fn, int, flags,
                         __kernel_mode_t, mode);
 
 #define __NR__dl_write __NR_write
-static inline _syscall3(unsigned long, _dl_write, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_write, int, fd,
                         const void *, buf, unsigned long, count);
 
 #define __NR__dl_read __NR_read
-static inline _syscall3(unsigned long, _dl_read, int, fd,
+static __always_inline _syscall3(unsigned long, _dl_read, int, fd,
                         const void *, buf, unsigned long, count);
 
 #define __NR__dl_mprotect __NR_mprotect
-static inline _syscall3(int, _dl_mprotect, const void *, addr,
+static __always_inline _syscall3(int, _dl_mprotect, const void *, addr,
                         unsigned long, len, int, prot);
 
 #define __NR__dl_stat __NR_stat
-static inline _syscall2(int, _dl_stat, const char *, file_name,
+static __always_inline _syscall2(int, _dl_stat, const char *, file_name,
                         struct stat *, buf);
 
 #define __NR__dl_fstat __NR_fstat
-static inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
+static __always_inline _syscall2(int, _dl_fstat, int, fd, struct stat *, buf);
 
 #define __NR__dl_munmap __NR_munmap
-static inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
+static __always_inline _syscall2(int, _dl_munmap, void *, start, unsigned long, length);
 
 #ifdef __NR_getxuid
 # define __NR_getuid __NR_getxuid
 #endif
 #define __NR__dl_getuid __NR_getuid
-static inline _syscall0(uid_t, _dl_getuid);
+static __always_inline _syscall0(uid_t, _dl_getuid);
 
 #ifndef __NR_geteuid
 # define __NR_geteuid __NR_getuid
 #endif
 #define __NR__dl_geteuid __NR_geteuid
-static inline _syscall0(uid_t, _dl_geteuid);
+static __always_inline _syscall0(uid_t, _dl_geteuid);
 
 #ifdef __NR_getxgid
 # define __NR_getgid __NR_getxgid
 #endif
 #define __NR__dl_getgid __NR_getgid
-static inline _syscall0(gid_t, _dl_getgid);
+static __always_inline _syscall0(gid_t, _dl_getgid);
 
 #ifndef __NR_getegid
 # define __NR_getegid __NR_getgid
 #endif
 #define __NR__dl_getegid __NR_getegid
-static inline _syscall0(gid_t, _dl_getegid);
+static __always_inline _syscall0(gid_t, _dl_getegid);
 
 #ifdef __NR_getxpid
 # define __NR_getpid __NR_getxpid
 #endif
 #define __NR__dl_getpid __NR_getpid
-static inline _syscall0(gid_t, _dl_getpid);
+static __always_inline _syscall0(gid_t, _dl_getpid);
 
 #define __NR__dl_readlink __NR_readlink
-static inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
+static __always_inline _syscall3(int, _dl_readlink, const char *, path, char *, buf,
                         size_t, bufsiz);
 
 #ifdef __UCLIBC_HAS_SSP__
@@ -146,14 +146,14 @@ static inline _syscall2(int, _dl_gettimeofday, struct timeval *, tv,
 #if defined(__UCLIBC_MMAP_HAS_6_ARGS__) && defined(__NR_mmap)
 
 # define __NR__dl_mmap __NR_mmap
-static inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
+static __always_inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
                         int, prot, int, flags, int, fd, off_t, offset);
 
 /* then try mmap2() */
 #elif defined(__NR_mmap2)
 
 # define __NR___syscall_mmap2       __NR_mmap2
-static inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
+static __always_inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
                         int, prot, int, flags, int, fd, off_t, offset);
 
 /* Some architectures always use 12 as page shift for mmap2() eventhough the
@@ -164,7 +164,7 @@ static inline _syscall6(__ptr_t, __syscall_mmap2, __ptr_t, addr, size_t, len,
 # define MMAP2_PAGE_SHIFT 12
 #endif
 
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
                               int flags, int fd, unsigned long offset)
 {
 	if (offset & ((1 << MMAP2_PAGE_SHIFT) - 1))
@@ -177,8 +177,8 @@ static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
 #elif defined(__NR_mmap)
 
 # define __NR__dl_mmap_real __NR_mmap
-static inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
-static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
+static __always_inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
+static __always_inline void * _dl_mmap(void * addr, unsigned long size, int prot,
                               int flags, int fd, unsigned long offset)
 {
 	unsigned long buffer[6];
diff --git a/ldso/ldso/avr32/dl-debug.h b/ldso/ldso/avr32/dl-debug.h
new file mode 100644
index 0000000..fe35539
--- /dev/null
+++ b/ldso/ldso/avr32/dl-debug.h
@@ -0,0 +1,45 @@
+/*
+ * AVR32 ELF shared libary loader support
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+static const char *_dl_reltypes_tab[] = {
+    "R_AVR32_NONE",
+    "R_AVR32_32", "R_AVR32_16", "R_AVR32_8",
+    "R_AVR32_32_PCREL", "R_AVR32_16_PCREL", "R_AVR32_8_PCREL",
+    "R_AVR32_DIFF32", "R_AVR32_DIFF16", "R_AVR32_DIFF8",
+    "R_AVR32_GOT32", "R_AVR32_GOT16", "R_AVR32_GOT8",
+    "R_AVR32_21S", "R_AVR32_16U", "R_AVR32_16S", "R_AVR32_8S", "R_AVR32_8S_EXT",
+    "R_AVR32_22H_PCREL", "R_AVR32_18W_PCREL", "R_AVR32_16B_PCREL",
+    "R_AVR32_16N_PCREL", "R_AVR32_14UW_PCREL", "R_AVR32_11H_PCREL",
+    "R_AVR32_10UW_PCREL", "R_AVR32_9H_PCREL", "R_AVR32_9UW_PCREL",
+    "R_AVR32_HI16", "R_AVR32_LO16",
+    "R_AVR32_GOTPC", "R_AVR32_GOTCALL", "R_AVR32_LDA_GOT",
+    "R_AVR32_GOT21S", "R_AVR32_GOT18SW", "R_AVR32_GOT16S", "R_AVR32_GOT7UW",
+    "R_AVR32_32_CPENT", "R_AVR32_CPCALL", "R_AVR32_16_CP", "R_AVR32_9W_CP",
+    "R_AVR32_RELATIVE", "R_AVR32_GLOB_DAT", "R_AVR32_JMP_SLOT",
+    "R_AVR32_ALIGN",
+};
diff --git a/ldso/ldso/avr32/dl-startup.h b/ldso/ldso/avr32/dl-startup.h
new file mode 100644
index 0000000..3b9a641
--- /dev/null
+++ b/ldso/ldso/avr32/dl-startup.h
@@ -0,0 +1,112 @@
+/*
+ * Architecture specific code used by dl-startup.c
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+/* This is the library loader's main entry point. Let _dl_boot2 do its
+ * initializations and jump to the application's entry point
+ * afterwards. */
+asm(	"	.text\n"
+	"	.global	_start\n"
+	"	.type	_start,@function\n"
+	"_start:\n"
+	/* All arguments are on the stack initially */
+	"	mov	r12, sp\n"
+	"	rcall	_dl_start\n"
+	/* Returns user entry point in r12. Save it. */
+	"	mov	r0, r12\n"
+	/* We're PIC, so get the Global Offset Table */
+	"	lddpc	r6, .L_GOT\n"
+	".L_RGOT:\n"
+	"	rsub	r6, pc\n"
+	/* Adjust argc and argv according to _dl_skip_args */
+	"	ld.w	r1, r6[_dl_skip_args@got]\n"
+	"	ld.w	r1, r1[0]\n"
+	"	ld.w	r2, sp++\n"
+	"	sub	r2, r1\n"
+	"	add	sp, sp, r1 << 2\n"
+	"	st.w	--sp, r2\n"
+	/* Load the finalizer function */
+	"	ld.w	r12, r6[_dl_fini@got]\n"
+	/* Jump to the user's entry point */
+	"	mov	pc, r0\n\n"
+
+	"	.align	2\n"
+	".L_GOT:"
+	"	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_\n"
+	"	.size	_start, . - _start\n"
+	"	.previous\n");
+
+/* Get a pointer to the argv array.  On many platforms this can be just
+ * the address if the first argument, on other platforms we need to
+ * do something a little more subtle here. */
+#define GET_ARGV(ARGVP, ARGS) ARGVP = ((unsigned long *)ARGS + 1)
+
+
+/* We can't call functions before the GOT has been initialized */
+#define NO_FUNCS_BEFORE_BOOTSTRAP
+
+/*
+ * Relocate the GOT during dynamic loader bootstrap.  This will add
+ * the load address to all entries in the GOT, which is necessary
+ * because the linker doesn't generate R_AVR32_RELATIVE relocs for the
+ * GOT.
+ */
+static __always_inline
+void PERFORM_BOOTSTRAP_GOT(struct elf_resolve *tpnt)
+{
+	Elf32_Addr i, nr_got;
+	register Elf32_Addr *__r6 __asm__("r6");
+	Elf32_Addr *got = __r6;
+
+	nr_got = tpnt->dynamic_info[DT_AVR32_GOTSZ_IDX] / sizeof(*got);
+	for (i = 2; i < nr_got; i++)
+		got[i] += tpnt->loadaddr;
+}
+
+#define PERFORM_BOOTSTRAP_GOT(tpnt) PERFORM_BOOTSTRAP_GOT(tpnt)
+
+/* Handle relocation of the symbols in the dynamic loader. */
+static __always_inline
+void PERFORM_BOOTSTRAP_RELOC(ELF_RELOC *rpnt, unsigned long *reloc_addr,
+			     unsigned long symbol_addr,
+			     unsigned long load_addr, Elf32_Sym *symtab)
+{
+	switch(ELF32_R_TYPE(rpnt->r_info)) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr;
+		break;
+	case R_AVR32_RELATIVE:
+		SEND_STDERR_DEBUG("Applying RELATIVE relocation: ");
+		SEND_ADDRESS_STDERR_DEBUG(load_addr, 0);
+		SEND_STDERR_DEBUG(" + ");
+		SEND_ADDRESS_STDERR_DEBUG(rpnt->r_addend, 1);
+		*reloc_addr = load_addr + rpnt->r_addend;
+		break;
+	default:
+		SEND_STDERR("BOOTSTRAP_RELOC: unhandled reloc_type ");
+		SEND_NUMBER_STDERR(ELF32_R_TYPE(rpnt->r_info), 1);
+		SEND_STDERR("REL, SYMBOL, LOAD: ");
+		SEND_ADDRESS_STDERR(reloc_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(symbol_addr, 0);
+		SEND_STDERR(", ");
+		SEND_ADDRESS_STDERR(load_addr, 1);
+		_dl_exit(1);
+	}
+}
+
+/* Transfer control to the user's application, once the dynamic loader
+ * is done. This routine has to exit the current function, then call
+ * the _dl_elf_main function.
+ *
+ * Since our _dl_boot will simply call whatever is returned by
+ * _dl_boot2, we can just return the address we're supposed to
+ * call.  */
+#define START()	return _dl_elf_main;
diff --git a/ldso/ldso/avr32/dl-syscalls.h b/ldso/ldso/avr32/dl-syscalls.h
new file mode 100644
index 0000000..996bb87
--- /dev/null
+++ b/ldso/ldso/avr32/dl-syscalls.h
@@ -0,0 +1,6 @@
+/* We can't use the real errno in ldso, since it has not yet
+ * been dynamicly linked in yet. */
+#include "sys/syscall.h"
+extern int _dl_errno;
+#undef __set_errno
+#define __set_errno(X) {(_dl_errno) = (X);}
diff --git a/ldso/ldso/avr32/dl-sysdep.h b/ldso/ldso/avr32/dl-sysdep.h
new file mode 100644
index 0000000..1a30172
--- /dev/null
+++ b/ldso/ldso/avr32/dl-sysdep.h
@@ -0,0 +1,105 @@
+/*
+ * Various assembly language/system dependent hacks that are required
+ * so that we can minimize the amount of platform specific code.
+ *
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+/* Define this if the system uses RELOCA. */
+#define ELF_USES_RELOCA
+
+#include <elf.h>
+
+#define ARCH_NUM 1
+#define DT_AVR32_GOTSZ_IDX	(DT_NUM + OS_NUM)
+
+#define ARCH_DYNAMIC_INFO(dpnt, dynamic, debug_addr)			\
+	do {								\
+		if (dpnt->d_tag == DT_AVR32_GOTSZ)			\
+			dynamic[DT_AVR32_GOTSZ_IDX] = dpnt->d_un.d_val;	\
+	} while (0)
+
+/* Initialization sequence for the application/library GOT. */
+#define INIT_GOT(GOT_BASE,MODULE)					\
+	do {								\
+		unsigned long i, nr_got;				\
+									\
+		GOT_BASE[0] = (unsigned long) _dl_linux_resolve;	\
+		GOT_BASE[1] = (unsigned long) MODULE;			\
+									\
+		/* Add load address displacement to all GOT entries */	\
+		nr_got = MODULE->dynamic_info[DT_AVR32_GOTSZ_IDX] / 4;	\
+		for (i = 2; i < nr_got; i++)				\
+			GOT_BASE[i] += (unsigned long)MODULE->loadaddr;	\
+	} while (0)
+
+#define do_rem(result, n, base)	((result) = (n) % (base))
+
+/* Here we define the magic numbers that this dynamic loader should accept */
+#define MAGIC1 EM_AVR32
+#undef MAGIC2
+
+/* Used for error messages */
+#define ELF_TARGET "AVR32"
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got);
+
+/* 4096 bytes alignment */
+#define PAGE_ALIGN 0xfffff000
+#define ADDR_ALIGN 0xfff
+#define OFFS_ALIGN 0x7ffff000
+
+#define elf_machine_type_class(type)				\
+	((type == R_AVR32_JMP_SLOT) * ELF_RTYPE_CLASS_PLT)
+
+/* AVR32 doesn't need any COPY relocs */
+#define DL_NO_COPY_RELOCS
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT.  This must be inlined in a function which
+   uses global data.  */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+	register Elf32_Addr *got asm ("r6");
+	return *got;
+}
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+	extern void __dl_start asm("_dl_start");
+	Elf32_Addr got_addr = (Elf32_Addr) &__dl_start;
+	Elf32_Addr pcrel_addr;
+
+	asm   ("	lddpc	%0, 2f\n"
+	       "1:	add	%0, pc\n"
+	       "	rjmp	3f\n"
+	       "	.align	2\n"
+	       "2:	.long	_dl_start - 1b\n"
+	       "3:\n"
+	       : "=r"(pcrel_addr) : : "cc");
+
+	return pcrel_addr - got_addr;
+}
+
+/*
+ * Perform any RELATIVE relocations specified by DT_RELCOUNT.
+ * Currently, we don't use that tag, but we might in the future as
+ * this would reduce the startup time somewhat (although probably not by much).
+ */
+static inline void
+elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
+		      Elf32_Word relative_count)
+{
+	Elf32_Rela *rpnt = (void *)rel_addr;
+
+	do {
+		Elf32_Addr *reloc_addr;
+		reloc_addr = (void *)(load_off + (rpnt++)->r_offset);
+		*reloc_addr = load_off + rpnt->r_addend;
+	} while (--relative_count);
+}
diff --git a/ldso/ldso/avr32/elfinterp.c b/ldso/ldso/avr32/elfinterp.c
new file mode 100644
index 0000000..196292b
--- /dev/null
+++ b/ldso/ldso/avr32/elfinterp.c
@@ -0,0 +1,191 @@
+/*
+ * AVR32 ELF shared library loader suppport
+ *
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. The name of the above contributors may not be
+ *    used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+unsigned long _dl_linux_resolver(unsigned long got_offset, unsigned long *got)
+{
+	struct elf_resolve *tpnt = (struct elf_resolve *)got[1];
+	Elf32_Sym *sym;
+	unsigned long local_gotno;
+	unsigned long gotsym;
+	unsigned long new_addr;
+	char *strtab, *symname;
+	unsigned long *entry;
+	unsigned long sym_index = got_offset / 4;
+
+#if 0
+	local_gotno = tpnt->dynamic_info[DT_AVR32_LOCAL_GOTNO];
+	gotsym = tpnt->dynamic_info[DT_AVR32_GOTSYM];
+
+	sym = ((Elf32_Sym *)(tpnt->dynamic_info[DT_SYMTAB] + tpnt->loadaddr))
+		+ sym_index;
+	strtab = (char *)(tpnt->dynamic_info[DT_STRTAB] + tpnt->loadaddr);
+	symname = strtab + sym->st_name;
+
+#if 0
+	new_addr = (unsigned long) _dl_find_hash(strtab + sym->st_name,
+						 tpnt->symbol_scope, tpnt,
+						 resolver);
+#endif
+
+	entry = (unsigned long *)(got + local_gotno + sym_index - gotsym);
+	*entry = new_addr;
+#endif
+
+	return new_addr;
+}
+
+static int
+_dl_parse(struct elf_resolve *tpnt, struct dyn_elf *scope,
+	  unsigned long rel_addr, unsigned long rel_size,
+	  int (*reloc_func)(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			    Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab))
+{
+	Elf32_Sym *symtab;
+	Elf32_Rela *rpnt;
+	char *strtab;
+	int i;
+
+	rpnt = (Elf32_Rela *)rel_addr;
+	rel_size /= sizeof(Elf32_Rela);
+	symtab = (Elf32_Sym *)tpnt->dynamic_info[DT_SYMTAB];
+	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+
+	for (i = 0; i < rel_size; i++, rpnt++) {
+		int symtab_index, res;
+
+		symtab_index = ELF32_R_SYM(rpnt->r_info);
+
+		debug_sym(symtab, strtab, symtab_index);
+		debug_reloc(symtab, strtab, rpnt);
+
+		res = reloc_func(tpnt, scope, rpnt, symtab, strtab);
+
+		if (res == 0)
+			continue;
+
+		_dl_dprintf(2, "\n%s: ", _dl_progname);
+
+		if (symtab_index)
+			_dl_dprintf(2, "symbol '%s': ",
+				    strtab + symtab[symtab_index].st_name);
+
+		if (res < 0) {
+			int reloc_type = ELF32_R_TYPE(rpnt->r_info);
+#if defined(__SUPPORT_LD_DEBUG__)
+			_dl_dprintf(2, "can't handle reloc type %s\n",
+				    _dl_reltypes(reloc_type));
+#else
+			_dl_dprintf(2, "can't handle reloc type %x\n",
+				    reloc_type);
+#endif
+			_dl_exit(-res);
+		} else {
+			_dl_dprintf(2, "can't resolve symbol\n");
+			return res;
+		}
+	}
+
+	return 0;
+}
+
+static int _dl_do_reloc(struct elf_resolve *tpnt, struct dyn_elf *scope,
+			Elf32_Rela *rpnt, Elf32_Sym *symtab, char *strtab)
+{
+	int reloc_type;
+	int symtab_index;
+	char *symname;
+	unsigned long *reloc_addr;
+	unsigned long symbol_addr;
+#if defined(__SUPPORT_LD_DEBUG__)
+	unsigned long old_val;
+#endif
+
+	reloc_addr = (unsigned long *)(tpnt->loadaddr + rpnt->r_offset);
+	reloc_type = ELF32_R_TYPE(rpnt->r_info);
+	symtab_index = ELF32_R_SYM(rpnt->r_info);
+	symbol_addr = 0;
+	symname = strtab + symtab[symtab_index].st_name;
+
+	if (symtab_index) {
+		symbol_addr = (unsigned long)
+			_dl_find_hash(strtab + symtab[symtab_index].st_name,
+				      tpnt->symbol_scope, tpnt,
+				      elf_machine_type_class(reloc_type));
+
+		/* Allow undefined references to weak symbols */
+		if (!symbol_addr &&
+		    ELF32_ST_BIND(symtab[symtab_index].st_info) != STB_WEAK) {
+			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n",
+				    _dl_progname, symname);
+			return 0;
+		}
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	old_val = *reloc_addr;
+#endif
+	switch (reloc_type) {
+	case R_AVR32_NONE:
+		break;
+	case R_AVR32_GLOB_DAT:
+	case R_AVR32_JMP_SLOT:
+		*reloc_addr = symbol_addr + rpnt->r_addend;
+		break;
+	case R_AVR32_RELATIVE:
+		*reloc_addr = (unsigned long)tpnt->loadaddr
+			+ rpnt->r_addend;
+		break;
+	default:
+		return -1;
+	}
+
+#if defined(__SUPPORT_LD_DEBUG__)
+	if (_dl_debug_reloc && _dl_debug_detail)
+		_dl_dprintf(_dl_debug_file, "\tpatched: %x ==> %x @ %x\n",
+			    old_val, *reloc_addr);
+#endif
+
+	return 0;
+}
+
+void _dl_parse_lazy_relocation_information(struct dyn_elf *rpnt,
+					   unsigned long rel_addr,
+					   unsigned long rel_size)
+{
+	/* TODO: Might want to support this in order to get faster
+	 * startup times... */
+}
+
+int _dl_parse_relocation_information(struct dyn_elf *rpnt,
+				     unsigned long rel_addr,
+				     unsigned long rel_size)
+{
+	return _dl_parse(rpnt->dyn, rpnt->dyn->symbol_scope, rel_addr, rel_size,
+			 _dl_do_reloc);
+}
diff --git a/ldso/ldso/avr32/resolve.S b/ldso/ldso/avr32/resolve.S
new file mode 100644
index 0000000..e3cb7f4
--- /dev/null
+++ b/ldso/ldso/avr32/resolve.S
@@ -0,0 +1,28 @@
+/*
+ * Linux dynamic resolving code for AVR32. Fixes up the GOT entry as
+ * indicated in register r12 and jumps to the resolved address.
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ *
+ * Copyright (C) 2004-2007 Atmel Corporation
+ */
+
+#define ip r5
+
+	.text
+	.global	_dl_linux_resolve
+	.type	_dl_linux_resolve,@function
+_dl_linux_resolve:
+	/* The PLT code pushed r8 for us. It contains the address of this
+	   function's GOT entry, that is entry 0. ip contains the address
+	   of the GOT entry of the function we wanted to call. */
+	stm	--sp, r9-r12, lr
+	mov	r11, r8
+	sub	r12, ip, r8
+	rcall	_dl_linux_resolver
+	mov	ip, r12
+	popm	r8-r12,lr
+	mov	pc, ip
+	.size	_dl_linux_resolve, . - _dl_linux_resolve
diff --git a/ldso/ldso/dl-startup.c b/ldso/ldso/dl-startup.c
index 5cf1d04..d4294ec 100644
--- a/ldso/ldso/dl-startup.c
+++ b/ldso/ldso/dl-startup.c
@@ -217,7 +217,9 @@ DL_START(unsigned long args)
 	/* some arches (like MIPS) we have to tweak the GOT before relocations */
 	PERFORM_BOOTSTRAP_GOT(tpnt);
 
-#else
+#endif
+
+#if !defined(PERFORM_BOOTSTRAP_GOT) || defined(__avr32__)
 
 	/* OK, now do the relocations.  We do not do a lazy binding here, so
 	   that once we are done, we have considerably more flexibility. */
diff --git a/libc/inet/resolv.c b/libc/inet/resolv.c
index f4e6cac..9cdc3fe 100644
--- a/libc/inet/resolv.c
+++ b/libc/inet/resolv.c
@@ -1643,7 +1643,7 @@ int attribute_hidden __read_etc_hosts_r(FILE * fp, const char * name, int type,
 			*result=result_buf;
 			ret=NETDB_SUCCESS;
 #ifdef __UCLIBC_HAS_IPV6__
-        } else if (type == AF_INET6 && inet_pton(AF_INET6, alias[0], in6) > 0) {
+		} else if (type == AF_INET6 && inet_pton(AF_INET6, alias[0], in6) > 0) {
 			DPRINTF("Found INET6\n");
 			addr_list6[0] = in6;
 			addr_list6[1] = 0;
@@ -1658,8 +1658,8 @@ int attribute_hidden __read_etc_hosts_r(FILE * fp, const char * name, int type,
 		} else {
 			DPRINTF("Error\n");
 			ret=TRY_AGAIN;
-			break; /* bad ip address */
-        }
+			continue; /* bad ip address, keep searching */
+		}
 
 		if (action!=GETHOSTENT) {
 			fclose(fp);
diff --git a/libc/string/avr32/Makefile b/libc/string/avr32/Makefile
new file mode 100644
index 0000000..e19e9d9
--- /dev/null
+++ b/libc/string/avr32/Makefile
@@ -0,0 +1,26 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+top_srcdir	:= ../../../
+top_builddir	:= ../../../
+
+all: objs
+
+include $(top_builddir)Rules.mak
+include ../Makefile.in
+include $(top_srcdir)Makerules
diff --git a/libc/string/avr32/bcopy.S b/libc/string/avr32/bcopy.S
new file mode 100644
index 0000000..87c1e04
--- /dev/null
+++ b/libc/string/avr32/bcopy.S
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <features.h>
+
+#ifdef __UCLIBC_SUSV3_LEGACY__
+
+	.text
+	.global bcopy
+	.type	bcopy, @function
+	.align	1
+bcopy:
+	/* Swap the first two arguments */
+	eor	r11, r12
+	eor	r12, r11
+	eor	r11, r12
+	rjmp	__GI_memmove
+
+	.size	bcopy, . - bcopy
+
+#endif /* __UCLIBC_SUSV3_LEGACY__ */
diff --git a/libc/string/avr32/bzero.S b/libc/string/avr32/bzero.S
new file mode 100644
index 0000000..c999e65
--- /dev/null
+++ b/libc/string/avr32/bzero.S
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#ifdef __UCLIBC_SUSV3_LEGACY__
+
+	.text
+	.global bzero
+	.type	bzero, @function
+	.align	1
+bzero:
+	mov	r10, r11
+	mov	r11, 0
+	rjmp	__memset
+
+	.size	bzero, . - bzero
+
+#endif /* __UCLIBC_SUSV3_LEGACY__ */
diff --git a/libc/string/avr32/memcmp.S b/libc/string/avr32/memcmp.S
new file mode 100644
index 0000000..ae6cc91
--- /dev/null
+++ b/libc/string/avr32/memcmp.S
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <features.h>
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global memcmp
+	.type	memcmp, @function
+	.align	1
+memcmp:
+	sub	len, 4
+	brlt	.Lless_than_4
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	.Lfound_word
+	sub	len, 4
+	brge	1b
+
+.Lless_than_4:
+	sub	len, -4
+	reteq	0
+
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	sub	len, 1
+	brgt	1b
+
+	retal	0
+
+.Lfound_word:
+	mov	len, 4
+
+2:	bfextu	r11, r9, 24, 8
+	bfextu	r12, r8, 24, 8
+	sub	r12, r11
+	retne	r12
+	lsl	r8, 8
+	lsl	r9, 8
+	sub	len, 1
+	brne	2b
+	retal	r12
+
+	.size	memcmp, . - memcmp
+
+libc_hidden_def(memcmp)
+#ifdef __UCLIBC_SUSV3_LEGACY__
+strong_alias(memcmp,bcmp)
+#endif
diff --git a/libc/string/avr32/memcpy.S b/libc/string/avr32/memcpy.S
new file mode 100644
index 0000000..bf091ab
--- /dev/null
+++ b/libc/string/avr32/memcpy.S
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+/* Don't use r12 as dst since we must return it unmodified */
+#define dst r9
+#define src r11
+#define len r10
+
+	.text
+	.global	memcpy
+	.type	memcpy, @function
+memcpy:
+	pref	src[0]
+	mov	dst, r12
+
+	/* If we have less than 32 bytes, don't do anything fancy */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, src++
+	st.b	dst++, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, dst
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	ldm	src, r0-r7
+	sub	src, -32
+	stm	dst, r0-r7
+	sub	dst, -32
+	sub	len, 32
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	ldm	src, r0-r3
+	sub	src, -16
+	sub	len, 16
+	stm	dst, r0-r3
+	sub	dst, -16
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	neg	len
+	add	pc, pc, len << 2
+	.rept	15
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	rsub	r8, r8, 32
+	sub	len, r8
+1:	ld.ub	r0, src++
+	st.b	dst++, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[0]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, src++
+	st.w	dst++, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, src++
+	st.b	dst++, r0
+	.endr
+
+	popm	r0-r7, pc
+	.size	memcpy, . - memcpy
+
+libc_hidden_def(memcpy)
diff --git a/libc/string/avr32/memmove.S b/libc/string/avr32/memmove.S
new file mode 100644
index 0000000..98287c5
--- /dev/null
+++ b/libc/string/avr32/memmove.S
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#define dst r12
+#define src r11
+#define len r10
+
+	.text
+	.global memmove
+	.type	memmove, @function
+memmove:
+	cp.w	src, dst
+	brge	__GI_memcpy
+
+	add	dst, len
+	add	src, len
+	pref	src[-1]
+
+	/*
+	 * The rest is basically the same as in memcpy.S except that
+	 * the direction is reversed.
+	 */
+	cp.w	len, 32
+	brge	.Lmore_than_31
+
+	sub	len, 1
+	retlt	r12
+1:	ld.ub	r8, --src
+	st.b	--dst, r8
+	sub	len, 1
+	brge	1b
+	retal	r12
+
+.Lmore_than_31:
+	pushm	r0-r7, lr
+
+	/* Check alignment */
+	mov	r8, src
+	andl	r8, 31, COH
+	brne	.Lunaligned_src
+	mov	r8, r12
+	andl	r8, 3, COH
+	brne	.Lunaligned_dst
+
+.Laligned_copy:
+	sub	len, 32
+	brlt	.Lless_than_32
+
+1:	/* Copy 32 bytes at a time */
+	sub	src, 32
+	ldm	src, r0-r7
+	sub	dst, 32
+	sub	len, 32
+	stm	dst, r0-r7
+	brge	1b
+
+.Lless_than_32:
+	/* Copy 16 more bytes if possible */
+	sub	len, -16
+	brlt	.Lless_than_16
+	sub	src, 16
+	ldm	src, r0-r3
+	sub	dst, 16
+	sub	len, 16
+	stm	dst, r0-r3
+
+.Lless_than_16:
+	/* Do the remaining as byte copies */
+	sub	len, -16
+	breq	2f
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	len, 1
+	brne	1b
+
+2:	popm	r0-r7, pc
+
+.Lunaligned_src:
+	/* Make src cacheline-aligned. r8 = (src & 31) */
+	sub	len, r8
+1:	ld.ub	r0, --src
+	st.b	--dst, r0
+	sub	r8, 1
+	brne	1b
+
+	/* If dst is word-aligned, we're ready to go */
+	pref	src[-4]
+	mov	r8, 3
+	tst	dst, r8
+	breq	.Laligned_copy
+
+.Lunaligned_dst:
+	/* src is aligned, but dst is not. Expect bad performance */
+	sub	len, 4
+	brlt	2f
+1:	ld.w	r0, --src
+	st.w	--dst, r0
+	sub	len, 4
+	brge	1b
+
+2:	neg	len
+	add	pc, pc, len << 2
+	.rept	3
+	ld.ub	r0, --src
+	st.b	--dst, r0
+	.endr
+
+	popm	r0-r7, pc
+	.size	memmove, . - memmove
+
+libc_hidden_def(memmove)
diff --git a/libc/string/avr32/memset.S b/libc/string/avr32/memset.S
new file mode 100644
index 0000000..33cfaed
--- /dev/null
+++ b/libc/string/avr32/memset.S
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <features.h>
+
+#define s r12
+#define c r11
+#define n r10
+
+	.text
+	.global memset
+	.type	memset, @function
+
+	.global	__memset
+	.hidden	__memset
+	.type	__memset, @function
+
+	.align	1
+memset:
+__memset:
+	cp.w	n, 32
+	mov	r9, s
+	brge	.Llarge_memset
+
+	sub	n, 1
+	retlt	s
+1:	st.b	s++, c
+	sub	n, 1
+	brge	1b
+
+	retal	r9
+
+.Llarge_memset:
+	mov	r8, r11
+	mov	r11, 3
+	bfins	r8, r8, 8, 8
+	bfins	r8, r8, 16, 16
+	tst	s, r11
+	breq	2f
+
+1:	st.b	s++, r8
+	sub	n, 1
+	tst	s, r11
+	brne	1b
+
+2:	mov	r11, r9
+	mov	r9, r8
+	sub	n, 8
+
+3:	st.d	s++, r8
+	sub	n, 8
+	brge	3b
+
+	/* If we are done, n == -8 and we'll skip all st.b insns below */
+	neg	n
+	lsl	n, 1
+	add	pc, n
+	.rept	7
+	st.b	s++, r8
+	.endr
+	retal	r11
+
+	.size	memset, . - memset
+
+libc_hidden_def(memset)
diff --git a/libc/string/avr32/strcmp.S b/libc/string/avr32/strcmp.S
new file mode 100644
index 0000000..f73bd43
--- /dev/null
+++ b/libc/string/avr32/strcmp.S
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <features.h>
+
+#define s1 r12
+#define s2 r11
+#define len r10
+
+	.text
+	.global strcmp
+	.type	strcmp, @function
+	.align	1
+strcmp:
+	mov	r8, 3
+	tst	s1, r8
+	brne	.Lunaligned_s1
+	tst	s2, r8
+	brne	.Lunaligned_s2
+
+1:	ld.w	r8, s1++
+	ld.w	r9, s2++
+	cp.w	r8, r9
+	brne	2f
+	tnbz	r8
+	brne	1b
+	retal	0
+
+2:	bfextu	r12, r8, 24, 8
+	bfextu	r11, r9, 24, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 16, 8
+	bfextu	r11, r9, 16, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 8, 8
+	bfextu	r11, r9, 8, 8
+	sub	r12, r11
+	retne	r12
+	cp.w	r11, 0
+	reteq	0
+	bfextu	r12, r8, 0, 8
+	bfextu	r11, r9, 0, 8
+	sub	r12, r11
+	retal	r12
+
+.Lunaligned_s1:
+3:	tst	s1, r8
+	breq	4f
+	ld.ub	r10, s1++
+	ld.ub	r9, s2++
+	sub	r10, r9
+	retne	r10
+	cp.w	r9, 0
+	brne	3b
+	retal	r10
+
+4:	tst	s2, r8
+	breq	1b
+
+.Lunaligned_s2:
+	/*
+	 * s1 and s2 can't both be aligned, and unaligned word loads
+	 * can trigger spurious exceptions if we cross a page boundary.
+	 * Do it the slow way...
+	 */
+1:	ld.ub	r8, s1++
+	ld.ub	r9, s2++
+	sub	r8, r9
+	retne	r8
+	cp.w	r9, 0
+	brne	1b
+	retal	0
+
+	.size	strcmp, . - strcmp
+
+libc_hidden_def(strcmp)
+#ifndef __UCLIBC_HAS_LOCALE__
+strong_alias(strcmp, strcoll)
+libc_hidden_def(strcoll)
+#endif
diff --git a/libc/string/avr32/strlen.S b/libc/string/avr32/strlen.S
new file mode 100644
index 0000000..5223e53
--- /dev/null
+++ b/libc/string/avr32/strlen.S
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <features.h>
+
+#define str r12
+
+	.text
+	.global strlen
+	.type	strlen, @function
+strlen:
+	mov	r11, r12
+
+	mov	r9, str
+	andl	r9, 3, COH
+	brne	.Lunaligned_str
+
+1:	ld.w	r8, str++
+	tnbz	r8
+	brne	1b
+
+	sub	r12, r11
+	bfextu	r9, r8, 24, 8
+	cp.w	r9, 0
+	subeq	r12, 4
+	reteq	r12
+	bfextu	r9, r8, 16, 8
+	cp.w	r9, 0
+	subeq	r12, 3
+	reteq	r12
+	bfextu	r9, r8, 8, 8
+	cp.w	r9, 0
+	subeq	r12, 2
+	reteq	r12
+	sub	r12, 1
+	retal	r12
+
+.Lunaligned_str:
+	add	pc, pc, r9 << 3
+	sub	r0, r0, 0	/* 4-byte nop */
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	breq	1f
+	ld.ub	r8, str++
+	sub	r8, r8, 0
+	brne	1b
+
+1:	sub	r12, 1
+	sub	r12, r11
+	retal	r12
+
+	.size	strlen, . - strlen
+
+libc_hidden_def(strlen)
diff --git a/libc/sysdeps/linux/avr32/Makefile b/libc/sysdeps/linux/avr32/Makefile
new file mode 100644
index 0000000..338abc0
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/Makefile
@@ -0,0 +1,25 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2003 Erik Andersen <andersen@uclibc.org>
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU Library General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option) any
+# later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more
+# details.
+#
+# You should have received a copy of the GNU Library General Public License
+# along with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+top_srcdir=../../../../
+top_builddir=../../../../
+all: objs
+
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
diff --git a/libc/sysdeps/linux/avr32/Makefile.arch b/libc/sysdeps/linux/avr32/Makefile.arch
new file mode 100644
index 0000000..44fc01e
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/Makefile.arch
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CSRC	:= brk.c clone.c mmap.c sigaction.c
+
+SSRC	:= __longjmp.S setjmp.S bsd-setjmp.S bsd-_setjmp.S	\
+		sigrestorer.S syscall.S vfork.S
+
+include $(top_srcdir)/libc/sysdeps/linux/Makefile.commonarch
diff --git a/libc/sysdeps/linux/avr32/__longjmp.S b/libc/sysdeps/linux/avr32/__longjmp.S
new file mode 100644
index 0000000..6154bb2
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/__longjmp.S
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+	.global	__longjmp
+	.type	__longjmp,"function"
+	.align	1
+__longjmp:
+	ldm	r12++, r0-r8,sp,lr
+	mustr	r8		/* restore status register (lower half) */
+	cp	r11, 0		/* can't return zero */
+	frs
+	moveq	r11, 1
+	retal	r11
+	.size	__longjmp, . - __longjmp
+
+libc_hidden_def(__longjmp)
diff --git a/libc/sysdeps/linux/avr32/bits/atomic.h b/libc/sysdeps/linux/avr32/bits/atomic.h
new file mode 100644
index 0000000..e6be41f
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/atomic.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#ifndef _AVR32_BITS_ATOMIC_H
+#define _AVR32_BITS_ATOMIC_H 1
+
+#include <inttypes.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval)	\
+	(abort(), 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval)	\
+	(abort(), 0)
+
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval)	\
+	({								\
+		__typeof__(*(mem)) __prev;				\
+		__asm__ __volatile__(					\
+			"/* __arch_compare_and_exchange_val_32_acq */\n" \
+			"1:	ssrf	5\n"				\
+			"	ld.w	%[result], %[m]\n"		\
+			"	cp.w	%[result], %[old]\n"		\
+			"	brne	2f\n"				\
+			"	stcond	%[m], %[new]\n"			\
+			"	brne	1b\n"				\
+			"2:"						\
+			: [result] "=&r"(__result), [m] "=m"(*(mem))	\
+			: "m"(*(mem)), [old] "ir"(oldval),		\
+			  [new] "r"(newval)				\
+			: "memory", "cc");				\
+		__prev;							\
+	})
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval)	\
+	(abort(), 0)
+
+#define __arch_exchange_32_acq(mem, newval)				\
+	({								\
+		__typeof__(*(mem)) __oldval;				\
+		__asm__ __volatile__(					\
+			"/*__arch_exchange_32_acq */\n"			\
+			"	xchg	%[old], %[m], %[new]"		\
+			: [old] "=&r"(__oldval)				\
+			: [m] "r"(mem), [new] "r"(newval)		\
+			: "memory");					\
+		__oldval;						\
+	})
+
+#define __arch_atomic_exchange_and_add_32(mem, value)			\
+	({								\
+		__typeof__(*(mem)) __oldval, __tmp;			\
+		__asm__ __volatile__(					\
+			"/* __arch_atomic_exchange_and_add_32 */\n"	\
+			"1:	ssrf	5\n"				\
+			"	ld.w	%[old], %[m]\n"			\
+			"	add	%[tmp], %[old], %[val]\n"	\
+			"	stcond	%[m], %[tmp]\n"			\
+			"	brne	1b"				\
+			: [old] "=&r"(__oldval), [tmp] "=&r"(__tmp),	\
+			  [m] "=m"(*(mem))				\
+			: "m"(*(mem)), [val] "r"(value)			\
+			: "memory", "cc");				\
+		__oldval;						\
+	})
+
+#define __arch_atomic_decrement_if_positive_32(mem)			\
+	({								\
+		__typeof__(*(mem)) __oldval, __tmp;			\
+		__asm__ __volatile__(					\
+			"/* __arch_atomic_decrement_if_positive_32 */\n" \
+			"1:	ssrf	5\n"				\
+			"	ld.w	%[old], %[m]\n"			\
+			"	sub	%[tmp], %[old], 1\n"		\
+			"	brlt	2f\n"				\
+			"	stcond	%[m], %[tmp]\n"			\
+			"	brne	1b"				\
+			"2:"						\
+			: [old] "=&r"(__oldval), [tmp] "=&r"(__tmp),	\
+			  [m] "=m"(*(mem))				\
+			: "m"(*(mem))					\
+			: "memory", "cc");				\
+		__oldval;						\
+	})
+
+#define atomic_exchange_acq(mem, newval)				\
+	({								\
+		if (sizeof(*(mem)) != 4)				\
+			abort();					\
+		__arch_exchange_32_acq(mem, newval);			\
+	})
+
+#define atomic_exchange_and_add(mem, newval)				\
+	({								\
+		if (sizeof(*(mem)) != 4)				\
+			abort();					\
+		__arch_atomic_exchange_and_add_32(mem, newval);		\
+	})
+
+#define atomic_decrement_if_positive(mem)				\
+	({								\
+		if (sizeof(*(mem)) != 4)				\
+			abort();					\
+		__arch_atomic_decrement_if_positive_32(mem);		\
+	})
+
+#endif /* _AVR32_BITS_ATOMIC_H */
diff --git a/libc/sysdeps/linux/avr32/bits/byteswap.h b/libc/sysdeps/linux/avr32/bits/byteswap.h
new file mode 100644
index 0000000..1c030b9
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/byteswap.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2005 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#if !defined _BYTESWAP_H && !defined _NETINET_IN_H
+# error "Never use <bits/byteswap.h> directly; include <byteswap.h> instead."
+#endif
+
+#ifndef _BITS_BYTESWAP_H
+#define _BITS_BYTESWAP_H 1
+
+/* Swap bytes in 16 bit value.  */
+#if defined __GNUC__
+# define __bswap_16(x) (__extension__ __builtin_bswap_16(x))
+#else
+/* This is better than nothing.  */
+static __inline unsigned short int
+__bswap_16 (unsigned short int __bsx)
+{
+	return ((((__bsx) >> 8) & 0xff) | (((__bsx) & 0xff) << 8));
+}
+#endif
+
+/* Swap bytes in 32 bit value.  */
+#if defined __GNUC__
+# define __bswap_32(x) (__extension__ __builtin_bswap_32(x))
+#else
+static __inline unsigned int
+__bswap_32 (unsigned int __bsx)
+{
+  return ((((__bsx) & 0xff000000) >> 24) | (((__bsx) & 0x00ff0000) >>  8) |
+	  (((__bsx) & 0x0000ff00) <<  8) | (((__bsx) & 0x000000ff) << 24));
+}
+#endif
+
+#if defined __GNUC__
+/* Swap bytes in 64 bit value.  */
+# define __bswap_constant_64(x)				\
+	((((x) & 0xff00000000000000ull) >> 56)		\
+	 | (((x) & 0x00ff000000000000ull) >> 40)	\
+	 | (((x) & 0x0000ff0000000000ull) >> 24)	\
+	 | (((x) & 0x000000ff00000000ull) >> 8)		\
+	 | (((x) & 0x00000000ff000000ull) << 8)		\
+	 | (((x) & 0x0000000000ff0000ull) << 24)	\
+	 | (((x) & 0x000000000000ff00ull) << 40)	\
+	 | (((x) & 0x00000000000000ffull) << 56))
+
+# define __bswap_64(x)							\
+	(__extension__							\
+	 ({								\
+		 union {						\
+			 __extension__ unsigned long long int __ll;	\
+			 unsigned int __l[2];				\
+		 } __w, __r;						\
+		 if (__builtin_constant_p(x))				\
+			 __r.__ll = __bswap_constant_64(x);		\
+		 else {							\
+			 __w.__ll = (x);				\
+			 __r.__l[0] = __bswap_32(__w.__l[1]);		\
+			 __r.__l[1] = __bswap_32(__w.__l[0]);		\
+		 }							\
+		 __r.__ll;						\
+	 }))
+#endif
+
+#endif /* _BITS_BYTESWAP_H */
diff --git a/libc/sysdeps/linux/avr32/bits/endian.h b/libc/sysdeps/linux/avr32/bits/endian.h
new file mode 100644
index 0000000..7bb6358
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/endian.h
@@ -0,0 +1,7 @@
+/* AVR32 is big-endian */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
diff --git a/libc/sysdeps/linux/avr32/bits/fcntl.h b/libc/sysdeps/linux/avr32/bits/fcntl.h
new file mode 100644
index 0000000..1abff17
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/fcntl.h
@@ -0,0 +1,165 @@
+#ifndef _FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/*
+ * open/fcntl - O_SYNC is only implemented on blocks devices and on files
+ * located on an ext2 file system
+ */
+#define O_ACCMODE	00000003
+#define O_RDONLY	00000000
+#define O_WRONLY	00000001
+#define O_RDWR		00000002
+#define O_CREAT		00000100	/* not fcntl */
+#define O_EXCL		00000200	/* not fcntl */
+#define O_NOCTTY	00000400	/* not fcntl */
+#define O_TRUNC		00001000	/* not fcntl */
+#define O_APPEND	00002000
+#define O_NONBLOCK	00004000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		00010000
+#define O_ASYNC		00020000
+
+#ifdef __USE_GNU
+# define O_DIRECT	00040000	/* must be a directory */
+# define O_DIRECTORY	00200000	/* direct disk access */
+# define O_NOFOLLOW	00400000	/* don't follow links */
+# define O_NOATIME	01000000	/* don't set atime */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	00100000
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5
+# define F_SETLK	6
+# define F_SETLKW	7
+#else
+# define F_GETLK	F_GETLK64
+# define F_SETLK	F_SETLK64
+# define F_SETLKW	F_SETLKW64
+#endif
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/*  for sockets. */
+# define F_GETOWN	9	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/*  for sockets. */
+# define F_GETSIG	11	/*  for sockets. */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+#endif
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+#ifdef __USE_BSD
+/* operations for bsd flock(), also used by the kernel implementation */
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock */
+# define LOCK_READ	64	/* ... Which allows concurrent
+				       read operations */
+# define LOCK_WRITE	128	/* ... Which allows concurrent
+				       write operations */
+# define LOCK_RW	192	/* ... Which allows concurrent
+				       read & write ops */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock {
+	short		l_type;
+	short		l_whence;
+#ifndef __USE_FILE_OFFSET64
+	__off_t		l_start;
+	__off_t		l_len;
+#else
+	__off64_t	l_start;
+	__off64_t	l_len;
+#endif
+	__pid_t		l_pid;
+};
+
+#ifdef __USE_LARGEFILE64
+struct flock64 {
+	short		l_type;
+	short		l_whence;
+	__off64_t	l_start;
+	__off64_t	l_len;
+	__pid_t		l_pid;
+};
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+ *    BSD systems which did not managed to hide these kernel macros.  */
+#ifdef  __USE_BSD
+# define FAPPEND        O_APPEND
+# define FFSYNC         O_FSYNC
+# define FASYNC         O_ASYNC
+# define FNONBLOCK      O_NONBLOCK
+# define FNDELAY        O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL      0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM      1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL  2 /* Expect sequential page references.  */
+# define POSIX_FADV_WILLNEED    3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED    4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE     5 /* Data will be accessed once.  */
+#endif
diff --git a/libc/sysdeps/linux/avr32/bits/kernel_stat.h b/libc/sysdeps/linux/avr32/bits/kernel_stat.h
new file mode 100644
index 0000000..f97d23b
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/kernel_stat.h
@@ -0,0 +1,67 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+#ifndef _LIBC
+#error bits/kernel_stat.h is for internal uClibc use only!
+#endif
+
+/*
+ * This file provides struct stat, taken from kernel 2.6.4. Verified
+ * to match kernel 2.6.22.
+ */
+
+struct kernel_stat {
+        unsigned long		st_dev;
+        unsigned long		st_ino;
+        unsigned short		st_mode;
+        unsigned short		st_nlink;
+        unsigned short		st_uid;
+        unsigned short		st_gid;
+        unsigned long		st_rdev;
+        unsigned long		st_size;
+        unsigned long		st_blksize;
+        unsigned long		st_blocks;
+        unsigned long		st_atime;
+        unsigned long		st_atime_nsec;
+        unsigned long		st_mtime;
+        unsigned long		st_mtime_nsec;
+        unsigned long		st_ctime;
+        unsigned long		st_ctime_nsec;
+        unsigned long		__unused4;
+        unsigned long		__unused5;
+};
+
+#define STAT_HAVE_NSEC 1
+
+struct kernel_stat64 {
+	unsigned long long	st_dev;
+
+	unsigned long long	st_ino;
+	unsigned int		st_mode;
+	unsigned int		st_nlink;
+
+	unsigned long		st_uid;
+	unsigned long		st_gid;
+
+	unsigned long long	st_rdev;
+
+	long long		st_size;
+	unsigned long		__pad1;
+	unsigned long		st_blksize;
+
+	unsigned long long	st_blocks;
+
+	unsigned long		st_atime;
+	unsigned long		st_atime_nsec;
+
+	unsigned long		st_mtime;
+	unsigned long		st_mtime_nsec;
+
+	unsigned long		st_ctime;
+	unsigned long		st_ctime_nsec;
+
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* _BITS_STAT_STRUCT_H */
diff --git a/libc/sysdeps/linux/avr32/bits/kernel_types.h b/libc/sysdeps/linux/avr32/bits/kernel_types.h
new file mode 100644
index 0000000..f7d8b52
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/kernel_types.h
@@ -0,0 +1,55 @@
+/* Note that we use the exact same include guard #define names
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts
+ * with the posix_types.h kernel header, and will ensure that
+ * our private content, and not the kernel header, will win.
+ *  -Erik
+ */
+#ifndef __ASM_AVR32_POSIX_TYPES_H
+#define __ASM_AVR32_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long		__kernel_dev_t;
+typedef unsigned long		__kernel_ino_t;
+typedef unsigned short		__kernel_mode_t;
+typedef unsigned short		__kernel_nlink_t;
+typedef long			__kernel_off_t;
+typedef int			__kernel_pid_t;
+typedef unsigned short		__kernel_ipc_pid_t;
+typedef unsigned int		__kernel_uid_t;
+typedef unsigned int		__kernel_gid_t;
+typedef unsigned long		__kernel_size_t;
+typedef long			__kernel_ssize_t;
+typedef int			__kernel_ptrdiff_t;
+typedef long			__kernel_time_t;
+typedef long			__kernel_suseconds_t;
+typedef long			__kernel_clock_t;
+typedef int			__kernel_timer_t;
+typedef int			__kernel_clockid_t;
+typedef int			__kernel_daddr_t;
+typedef char *			__kernel_caddr_t;
+typedef unsigned short		__kernel_uid16_t;
+typedef unsigned short		__kernel_gid16_t;
+typedef unsigned int		__kernel_uid32_t;
+typedef unsigned int		__kernel_gid32_t;
+typedef unsigned short		__kernel_old_uid_t;
+typedef unsigned short		__kernel_old_gid_t;
+typedef unsigned short		__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long		__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__USE_ALL)
+	int	val[2];
+#else
+	int	__val[2];
+#endif
+} __kernel_fsid_t;
+
+#endif /* __ASM_AVR32_POSIX_TYPES_H */
diff --git a/libc/sysdeps/linux/avr32/bits/mman.h b/libc/sysdeps/linux/avr32/bits/mman.h
new file mode 100644
index 0000000..5f6e3c3
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/mman.h
@@ -0,0 +1,103 @@
+/* Definitions for POSIX memory map interface.  Linux/AVR32 version.
+   Copyright (C) 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never include this file directly.  Use <sys/mman.h> instead"
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ	0x1		/* Page can be read.  */
+#define PROT_WRITE	0x2		/* Page can be written.  */
+#define PROT_EXEC	0x4		/* Page can be executed.  */
+#define PROT_NONE	0x0		/* Page can not be accessed.  */
+#define PROT_GROWSDOWN	0x01000000	/* Extend change to start of
+					   growsdown vma (mprotect only).  */
+#define PROT_GROWSUP	0x02000000	/* Extend change to start of
+					   growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED	0x01		/* Share changes.  */
+#define MAP_PRIVATE	0x02		/* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE	0x0f		/* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED	0x10		/* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE	0
+# define MAP_ANONYMOUS	0x20		/* Don't use a file.  */
+# define MAP_ANON	MAP_ANONYMOUS
+#endif
+
+/* These are Linux-specific.  */
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x0100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x1000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x2000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x4000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+# define MAP_NONBLOCK	0x10000		/* do not block on IO */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		4		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE	1
+# define MREMAP_FIXED	2
+#endif
+
+/* Advise to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_REMOVE	 9	/* Remove these pages and resources.  */
+# define MADV_DONTFORK	 10	/* Do not inherit across fork.  */
+# define MADV_DOFORK	 11	/* Do inherit across fork.  */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
diff --git a/libc/sysdeps/linux/avr32/bits/setjmp.h b/libc/sysdeps/linux/avr32/bits/setjmp.h
new file mode 100644
index 0000000..78348a3
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/setjmp.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2004-2005 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+/*
+ * The jump buffer contains r0-r7, sr, sp and lr. Other registers are
+ * not saved.
+ */
+typedef int __jmp_buf[11];
+#endif
+
+#define __JMP_BUF_SP	4
+
+/* Test if longjmp to JMPBUF would unwind the frame containing a local
+   variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *)(address) < (void *)(jmpbuf[__JMP_BUF_SP]))
+
+#endif /* _BITS_SETJMP_H */
diff --git a/libc/sysdeps/linux/avr32/bits/stackinfo.h b/libc/sysdeps/linux/avr32/bits/stackinfo.h
new file mode 100644
index 0000000..29b8452
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+/* On AVR32 the stack grows down. */
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --git a/libc/sysdeps/linux/avr32/bits/syscalls.h b/libc/sysdeps/linux/avr32/bits/syscalls.h
new file mode 100644
index 0000000..22ac059
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/syscalls.h
@@ -0,0 +1,143 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+/*
+ * This includes the `__NR_<name>' syscall numbers taken from the
+ * Linux kernel header files. It also defines the traditional
+ * `SYS_<name>' macros for older programs.
+ */
+#include <bits/sysnum.h>
+
+#ifndef __ASSEMBLER__
+
+#include <errno.h>
+
+#define SYS_ify(syscall_name) (__NR_##syscall_name)
+
+#undef _syscall0
+#define _syscall0(type,name)				\
+	type name(void)					\
+	{						\
+		return (type)(INLINE_SYSCALL(name, 0));	\
+	}
+
+#undef _syscall1
+#define _syscall1(type,name,type1,arg1)				\
+	type name(type1 arg1)					\
+	{							\
+		return (type)(INLINE_SYSCALL(name, 1, arg1));	\
+	}
+
+#undef _syscall2
+#define _syscall2(type,name,type1,arg1,type2,arg2)			\
+	type name(type1 arg1, type2 arg2)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 2, arg1, arg2));	\
+	}
+
+#undef _syscall3
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
+	type name(type1 arg1, type2 arg2, type3 arg3)			\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 3, arg1,		\
+					     arg2, arg3));		\
+	}
+
+#undef _syscall4
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4)						\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)	\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 4, arg1, arg2,	\
+					     arg3, arg4));		\
+	}
+
+#undef _syscall5
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5)				\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5)						\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 5, arg1, arg2,	\
+					     arg3, arg4, arg5));	\
+	}
+
+#undef _syscall6
+#define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,		\
+		  type4,arg4,type5,arg5,type6,arg6)			\
+	type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4,	\
+		  type5 arg5, type6 arg6)				\
+	{								\
+		return (type)(INLINE_SYSCALL(name, 6, arg1, arg2, arg3,	\
+					     arg4, arg5, arg6));	\
+	}
+
+#undef unlikely
+#define unlikely(x) __builtin_expect((x), 0)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+	({								\
+		unsigned _sys_result = INTERNAL_SYSCALL(name, , nr, args); \
+		if (unlikely(INTERNAL_SYSCALL_ERROR_P(_sys_result, ))) { \
+			__set_errno(INTERNAL_SYSCALL_ERRNO(_sys_result, )); \
+			_sys_result = (unsigned int) -1;		\
+		}							\
+		(int) _sys_result;					\
+	})
+
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while(0)
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...)			\
+	({								\
+		register int _a1 asm ("r12");				\
+		register int _scno asm("r8") = SYS_ify(name);		\
+		LOAD_ARGS_##nr (args);					\
+		asm volatile ("scall	/* syscall " #name " */"	\
+			      : "=r" (_a1)				\
+			      : "r"(_scno) ASM_ARGS_##nr		\
+			      : "cc", "memory");			\
+		_a1;							\
+	})
+
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err)		\
+	((unsigned int)(val) >= 0xfffff001U)
+
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, errr) (-(val))
+
+#define LOAD_ARGS_0() do { } while(0)
+#define ASM_ARGS_0
+#define LOAD_ARGS_1(a1)					\
+	_a1 = (int) (a1);				\
+	LOAD_ARGS_0()
+#define ASM_ARGS_1	ASM_ARGS_0, "r"(_a1)
+#define LOAD_ARGS_2(a1, a2)				\
+	register int _a2 asm("r11") = (int)(a2);	\
+	LOAD_ARGS_1(a1)
+#define ASM_ARGS_2	ASM_ARGS_1, "r"(_a2)
+#define LOAD_ARGS_3(a1, a2, a3)				\
+	register int _a3 asm("r10") = (int)(a3);	\
+	LOAD_ARGS_2(a1, a2)
+#define ASM_ARGS_3	ASM_ARGS_2, "r"(_a3)
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+	register int _a4 asm("r9") = (int)(a4);		\
+	LOAD_ARGS_3(a1, a2, a3)
+#define ASM_ARGS_4	ASM_ARGS_3, "r"(_a4)
+#define LOAD_ARGS_5(a1, a2, a3, a4, a5)			\
+	register int _a5 asm("r5") = (int)(a5);		\
+	LOAD_ARGS_4(a1, a2, a3, a4)
+#define ASM_ARGS_5	ASM_ARGS_4, "r"(_a5)
+#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)		\
+	register int _a6 asm("r3") = (int)(a6);		\
+	LOAD_ARGS_5(a1, a2, a3, a4, a5)
+#define ASM_ARGS_6	ASM_ARGS_5, "r"(_a6)
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
diff --git a/libc/sysdeps/linux/avr32/bits/uClibc_arch_features.h b/libc/sysdeps/linux/avr32/bits/uClibc_arch_features.h
new file mode 100644
index 0000000..e95e8a5
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/uClibc_arch_features.h
@@ -0,0 +1,45 @@
+/*
+ * Track misc arch-specific features that aren't config options
+ */
+
+#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
+#define _BITS_UCLIBC_ARCH_FEATURES_H
+
+/* instruction used when calling abort() to kill yourself */
+/* trigger illegal instruction exception, same as BUG in Linux */
+#define __UCLIBC_ABORT_INSTRUCTION__ ".short 0x5df0"
+
+/* can your target use syscall6() for mmap ? */
+#define __UCLIBC_MMAP_HAS_6_ARGS__
+
+/* does your target use syscall4() for truncate64 ? (32bit arches only) */
+#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
+
+/* does your target have a broken create_module() ? */
+#undef __UCLIBC_BROKEN_CREATE_MODULE__
+
+/* does your target have to worry about older [gs]etrlimit() ? */
+#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
+
+/* does your target prefix all symbols with an _ ? */
+#define __UCLIBC_NO_UNDERSCORES__
+
+/* does your target have an asm .set ? */
+#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
+
+/* define if target doesn't like .global */
+#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
+
+/* define if target supports .weak */
+#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
+
+/* define if target supports .weakext */
+#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
+
+/* needed probably only for ppc64 */
+#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
+
+/* define if target supports IEEE signed zero floats */
+#define __UCLIBC_HAVE_SIGNED_ZERO__
+
+#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff --git a/libc/sysdeps/linux/avr32/bits/wordsize.h b/libc/sysdeps/linux/avr32/bits/wordsize.h
new file mode 100644
index 0000000..1b5842a
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bits/wordsize.h
@@ -0,0 +1 @@
+#define __WORDSIZE	32
diff --git a/libc/sysdeps/linux/avr32/brk.c b/libc/sysdeps/linux/avr32/brk.c
new file mode 100644
index 0000000..a54b49a
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/brk.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+
+libc_hidden_proto(brk)
+
+void *__curbrk attribute_hidden = 0;
+
+int brk (void *addr)
+{
+	void *newbrk;
+
+	newbrk = (void *)INLINE_SYSCALL(brk, 1, addr);
+
+	__curbrk = newbrk;
+
+	if (newbrk < addr) {
+		__set_errno (ENOMEM);
+		return -1;
+	}
+
+	return 0;
+}
+libc_hidden_def(brk)
diff --git a/libc/sysdeps/linux/avr32/bsd-_setjmp.S b/libc/sysdeps/linux/avr32/bsd-_setjmp.S
new file mode 100644
index 0000000..be66a10
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bsd-_setjmp.S
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 0) */
+	.global	_setjmp
+	.type	_setjmp,"function"
+	.align	1
+_setjmp:
+	mov	r11, 0
+	bral	__GI___sigsetjmp
+	.size	_setjmp, . - _setjmp
diff --git a/libc/sysdeps/linux/avr32/bsd-setjmp.S b/libc/sysdeps/linux/avr32/bsd-setjmp.S
new file mode 100644
index 0000000..4635eeb
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/bsd-setjmp.S
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+	/* This just does a tail-call to __sigsetjmp(env, 1) */
+	.global	setjmp
+	.type	setjmp,"function"
+	.align	1
+setjmp:
+	mov	r11, 1
+	bral	__GI___sigsetjmp
+	.size	setjmp, . - setjmp
diff --git a/libc/sysdeps/linux/avr32/clone.c b/libc/sysdeps/linux/avr32/clone.c
new file mode 100644
index 0000000..e43b0f3
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/clone.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2004 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#include <errno.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+/*
+ * I don't know if we can be absolutely certain that the fn and arg
+ * parameters are preserved when returning as the child. If the
+ * compiler stores them in registers (r0-r7), they should be.
+ */
+int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg)
+{
+	register int (*_fn)(void *arg) = fn;
+	register void *_arg = arg;
+	int err;
+
+	/* Sanity check the arguments */
+	err = -EINVAL;
+	if (!fn)
+		goto syscall_error;
+	if (!child_stack)
+		goto syscall_error;
+
+	err = INLINE_SYSCALL(clone, 2, flags, child_stack);
+	if (err < 0)
+		goto syscall_error;
+	else if (err != 0)
+		return err;
+
+	_exit(_fn(_arg));
+
+syscall_error:
+	__set_errno (-err);
+	return -1;
+}
diff --git a/libc/sysdeps/linux/avr32/crt1.S b/libc/sysdeps/linux/avr32/crt1.S
new file mode 100644
index 0000000..ca1fa7a
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/crt1.S
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ *
+ * When we enter _start, the stack looks like this:
+ *	argc		argument counter
+ *	argv[0]		pointer to program name
+ *	argv[1..argc-1]	pointers to program args
+ *	NULL
+ *	env[0..N]	pointers to environment variables
+ *	NULL
+ *
+ * r12 contains a function pointer to be registered with `atexit'.
+ * This is how the dynamic linker arranges to have DT_FINI functions
+ * called for shared libraries that have been loaded before this
+ * code runs.
+ *
+ * We're going to call the following function:
+ * __uClibc_main(int (*main)(int, char **, char **), int argc,
+ *		 char **argv, void (*app_init)(void), void (*app_fini)(void),
+ *		 void (*rtld_fini)(void), void *stack_end)
+ *
+ * So we need to set up things as follows:
+ *	r12 = address of main
+ *	r11 = argc
+ *	r10 = &argv[0]
+ *	r9  = address of _init
+ *	r8  = address of _fini
+ *	sp[0] = whatever we got passed in r12
+ */
+
+#include <features.h>
+
+	.text
+	.global _start
+	.type	_start, @function
+_start:
+	/* Clear the frame pointer and link register since this is the outermost frame.  */
+	mov	r7, 0
+	mov	lr, 0
+
+	ld.w	r11, sp++		/* argc		*/
+	mov	r10, sp			/* &argv[0]	*/
+
+	st.w	--sp, r10		/* stack_end */
+	st.w	--sp, r12		/* rtld_fini */
+
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+.L_RGOT:
+	rsub	r6, pc
+	lda.w	r9, _init
+	lda.w	r8, _fini
+	lda.w	r12, main
+
+	/* Ok, now run uClibc's main() -- should not return */
+	call	__uClibc_main
+
+	.align	2
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+	lddpc	r9, __init_addr		/* app_init */
+	lddpc	r8, __fini_addr		/* app_fini */
+	lddpc	r12, __main_addr	/* main */
+
+	/* Ok, now run uClibc's main() -- should not return */
+	lddpc	pc, ___uClibc_main_addr
+
+	.align	2
+__init_addr:
+	.long	_init
+__fini_addr:
+	.long	_fini
+__main_addr:
+	.long	main
+___uClibc_main_addr:
+	.long	__uClibc_main
+#endif
+	.size	_start, . - _start
+
+	/*
+	 * The LSB says we need this.
+	 */
+	.section ".note.ABI-tag", "a"
+	.align	4
+	.long	2f - 1f		/* namesz */
+	.long	4f - 3f		/* descsz */
+	.long	1		/* type   */
+1:	.asciz	"GNU"		/* name */
+2:	.align	4
+3:	.long	0		/* Linux executable */
+	.long	2,6,0		/* Earliest compatible kernel */
+4:	.align	4
diff --git a/libc/sysdeps/linux/avr32/crti.S b/libc/sysdeps/linux/avr32/crti.S
new file mode 100644
index 0000000..660f47c
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/crti.S
@@ -0,0 +1,26 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+_init:
+	stm	--sp, r6, lr
+	lddpc	r6, 2f
+1:	rsub	r6, pc
+	rjmp	3f
+	.align	2
+2:	.long	1b - _GLOBAL_OFFSET_TABLE_
+3:
+
+	.section .fini
+	.align	2
+	.global	_fini
+	.type	_fini, @function
+_fini:
+	stm	--sp, r6, lr
+	lddpc	r6, 2f
+1:	rsub	r6, pc
+	rjmp	3f
+	.align	2
+2:	.long	1b - _GLOBAL_OFFSET_TABLE_
+3:
diff --git a/libc/sysdeps/linux/avr32/crtn.S b/libc/sysdeps/linux/avr32/crtn.S
new file mode 100644
index 0000000..f7d1040
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/crtn.S
@@ -0,0 +1,14 @@
+
+	.section .init
+	.align	2
+	.global	_init
+	.type	_init, @function
+	ldm	sp++, r6, pc
+	.size	_init, . - _init
+
+	.section .fini
+	.align	2
+	.global _fini
+	.type	_fini, @function
+	ldm	sp++, r6, pc
+	.size	_fini, . - _fini
diff --git a/libc/sysdeps/linux/avr32/mmap.c b/libc/sysdeps/linux/avr32/mmap.c
new file mode 100644
index 0000000..2ee025a
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/mmap.c
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <sys/syscall.h>
+
+libc_hidden_proto(mmap)
+
+static _syscall6(__ptr_t, mmap2, __ptr_t, addr, size_t, len, int, prot,
+		 int, flags, int, fd, __off_t, pgoff);
+
+__ptr_t mmap(__ptr_t addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+	unsigned long page_size = sysconf(_SC_PAGESIZE);
+	unsigned long pgoff;
+
+	if (offset & (page_size - 1)) {
+		__set_errno(EINVAL);
+		return MAP_FAILED;
+	}
+
+	pgoff = (unsigned long)offset >> (31 - __builtin_clz(page_size));
+
+	return mmap2(addr, len, prot, flags, fd, pgoff);
+}
+libc_hidden_def(mmap)
diff --git a/libc/sysdeps/linux/avr32/setjmp.S b/libc/sysdeps/linux/avr32/setjmp.S
new file mode 100644
index 0000000..7d0354b
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/setjmp.S
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+	.text
+
+	.global	__sigsetjmp
+	.type	__sigsetjmp,"function"
+
+	.align	1
+__sigsetjmp:
+	mustr	r8
+	stm	r12, r0,r1,r2,r3,r4,r5,r6,r7,r8,sp,lr
+
+	/*
+	 * Make a tail call to __sigjmp_save; it takes the same args
+	 * and is hidden so we don't need to mess around with the GOT.
+	 */
+	rjmp	__sigjmp_save
+	.size	__sigsetjmp, . - __sigsetjmp
+
+libc_hidden_def(__sigsetjmp)
diff --git a/libc/sysdeps/linux/avr32/sigaction.c b/libc/sysdeps/linux/avr32/sigaction.c
new file mode 100644
index 0000000..a97ff3d
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sigaction.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/kernel_sigaction.h>
+
+#define SA_RESTORER	0x04000000
+extern void __default_rt_sa_restorer(void);
+
+libc_hidden_proto(memcpy)
+
+/*
+ * If act is not NULL, change the action for sig to *act.
+ * If oact is not NULL, put the old action for sig in *oact.
+ */
+int __libc_sigaction(int signum, const struct sigaction *act,
+		     struct sigaction *oldact)
+{
+	struct kernel_sigaction kact, koact;
+	int result;
+
+	if (act) {
+		kact.k_sa_handler = act->sa_handler;
+		memcpy(&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
+		kact.sa_flags = act->sa_flags;
+		if (kact.sa_flags & (SA_RESTORER | SA_ONSTACK))
+			kact.sa_restorer = act->sa_restorer;
+		else
+			kact.sa_restorer = __default_rt_sa_restorer;
+		kact.sa_flags |= SA_RESTORER;
+	}
+
+	result = __syscall_rt_sigaction(signum, act ? __ptrvalue(&kact) : NULL,
+					oldact ? __ptrvalue(&koact) : NULL,
+					_NSIG / 8);
+
+	if (oldact && result >= 0) {
+		oldact->sa_handler = koact.k_sa_handler;
+		memcpy(&oldact->sa_mask, &koact.sa_mask,
+		       sizeof(oldact->sa_mask));
+		oldact->sa_flags = koact.sa_flags;
+		oldact->sa_restorer = koact.sa_restorer;
+	}
+
+	return result;
+}
+
+#ifndef LIBC_SIGACTION
+libc_hidden_proto(sigaction)
+weak_alias(__libc_sigaction, sigaction)
+libc_hidden_weak(sigaction)
+#endif
diff --git a/libc/sysdeps/linux/avr32/sigrestorer.S b/libc/sysdeps/linux/avr32/sigrestorer.S
new file mode 100644
index 0000000..df6a1ba
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sigrestorer.S
@@ -0,0 +1,15 @@
+/*
+ * Copyright (C) 2004 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#include <sys/syscall.h>
+
+	.global	__default_rt_sa_restorer
+	.type	__default_rt_sa_restorer,"function"
+	.align	1
+__default_rt_sa_restorer:
+	mov	r8, __NR_rt_sigreturn
+	scall
diff --git a/libc/sysdeps/linux/avr32/sys/elf.h b/libc/sysdeps/linux/avr32/sys/elf.h
new file mode 100644
index 0000000..faa7310
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sys/elf.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ELF_H
+#define _SYS_ELF_H	1
+
+#warning "This header is obsolete; use <sys/procfs.h> instead."
+
+#include <sys/procfs.h>
+
+#endif	/* sys/elf.h */
diff --git a/libc/sysdeps/linux/avr32/sys/procfs.h b/libc/sysdeps/linux/avr32/sys/procfs.h
new file mode 100644
index 0000000..3b37363
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sys/procfs.h
@@ -0,0 +1,123 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   user_regs' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+#define ELF_NGREG (sizeof (struct user_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* Register set for the floating-point registers.  */
+typedef struct user_fpregs elf_fpregset_t;
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/avr32/sys/ucontext.h b/libc/sysdeps/linux/avr32/sys/ucontext.h
new file mode 100644
index 0000000..82c7fe2
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sys/ucontext.h
@@ -0,0 +1,90 @@
+/* Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Linux/AVR32 ABI compliant context switching support.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+#include <sys/procfs.h>
+#include <bits/sigcontext.h>
+
+typedef int greg_t;
+
+/* Number of general registers.  */
+#define NGREG	16
+
+/* Container for all general registers.  */
+typedef elf_gregset_t gregset_t;
+
+/* Number of each register is the `gregset_t' array.  */
+enum
+{
+  R0 = 0,
+#define R0	R0
+  R1 = 1,
+#define R1	R1
+  R2 = 2,
+#define R2	R2
+  R3 = 3,
+#define R3	R3
+  R4 = 4,
+#define R4	R4
+  R5 = 5,
+#define R5	R5
+  R6 = 6,
+#define R6	R6
+  R7 = 7,
+#define R7	R7
+  R8 = 8,
+#define R8	R8
+  R9 = 9,
+#define R9	R9
+  R10 = 10,
+#define R10	R10
+  R11 = 11,
+#define R11	R11
+  R12 = 12,
+#define R12	R12
+  R13 = 13,
+#define R13	R13
+  R14 = 14,
+#define R14	R14
+  R15 = 15
+#define R15	R15
+};
+
+/* Structure to describe FPU registers.  */
+typedef elf_fpregset_t	fpregset_t;
+
+/* Context to describe whole processor state.  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+{
+	unsigned long	uc_flags;
+	struct ucontext	*uc_link;
+	stack_t		uc_stack;
+	mcontext_t	uc_mcontext;
+	sigset_t	uc_sigmask;   /* mask last for extensibility */
+} ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/avr32/sys/user.h b/libc/sysdeps/linux/avr32/sys/user.h
new file mode 100644
index 0000000..c0b3d38
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/sys/user.h
@@ -0,0 +1,46 @@
+#ifndef _SYS_USER_H
+#define _SYS_USER_H
+
+struct user_fpregs
+{
+
+};
+
+struct user_regs
+{
+	unsigned long sr;
+	unsigned long pc;
+	unsigned long lr;
+	unsigned long sp;
+	unsigned long r12;
+	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long r7;
+	unsigned long r6;
+	unsigned long r5;
+	unsigned long r4;
+	unsigned long r3;
+	unsigned long r2;
+	unsigned long r1;
+	unsigned long r0;
+	unsigned long r12_orig;
+};
+
+struct user
+{
+	struct user_regs	regs;		/* general registers */
+	size_t			u_tsize;	/* text size (pages) */
+	size_t			u_dsize;	/* data size (pages) */
+	size_t			u_ssize;	/* stack size (pages) */
+	unsigned long		start_code;	/* text starting address */
+	unsigned long		start_data;	/* data starting address */
+	unsigned long		start_stack;	/* stack starting address */
+	long int		signal;		/* signal causing core dump */
+	struct user_regs *	u_ar0;		/* help gdb find registers */
+	unsigned long		magic;		/* identifies a core file */
+	char			u_comm[32];	/* user command name */
+};
+
+#endif /* _SYS_USER_H */
diff --git a/libc/sysdeps/linux/avr32/syscall.S b/libc/sysdeps/linux/avr32/syscall.S
new file mode 100644
index 0000000..55c1b1f
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/syscall.S
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2004-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#include <features.h>
+
+	.text
+
+	/*
+	 * long int syscall(long int sysno, ...)
+	 */
+	.global	syscall
+	.type	syscall, @function
+	.align	2
+syscall:
+	stm	--sp, r3,r5,r6,lr
+	sub	lr, sp, -16
+	mov	r8, r12
+	ldm	lr, r3,r5,r9-r12
+	scall
+	cp.w	r12, -4095
+	brlo	.Ldone
+
+#ifdef __PIC__
+	lddpc	r6, .Lgot
+.Lgotcalc:
+	rsub	r6, pc
+# ifdef __UCLIBC_HAS_THREADS__
+	rsub	r3, r12, 0
+	mcall	r6[__errno_location@got]
+	st.w	r12[0], r3
+# else
+	ld.w	r3, r6[errno@got]
+	neg	r12
+	st.w	r3[0], r12
+# endif
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+	rsub	r3, r12, 0
+	mcall	.Lerrno_location
+	st.w	r12[0], r3
+# else
+	lddpc	r3, .Lerrno
+	neg	r12
+	st.w	r3[0], r12
+# endif
+#endif
+	mov	r12, -1
+
+.Ldone:
+	ldm	sp++, r3,r5,r6,pc
+
+	.align	2
+#ifdef __PIC__
+.Lgot:
+	.long	.Lgotcalc - _GLOBAL_OFFSET_TABLE_
+#else
+# ifdef __UCLIBC_HAS_THREADS__
+.Lerrno_location:
+	.long	__errno_location
+# else
+.Lerrno:
+	.long	errno
+# endif
+#endif
+
+
+	.size	syscall, . - syscall
diff --git a/libc/sysdeps/linux/avr32/vfork.S b/libc/sysdeps/linux/avr32/vfork.S
new file mode 100644
index 0000000..03ca99f
--- /dev/null
+++ b/libc/sysdeps/linux/avr32/vfork.S
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2005 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+
+/*
+ * Clone the process without copying the address space.  The
+ * calling process is suspended until the child either exits
+ * or calls execve.
+ *
+ * This all means that we cannot rely on the stack to store
+ * away registers, since they will be overwritten by the child
+ * as soon as it makes another function call (e.g. execve()).
+ * Fortunately, the Linux kernel preserves LR across system calls.
+ */
+
+#include <features.h>
+#include <sys/syscall.h>
+
+	.global	__vfork
+	.type	__vfork,@function
+	.align	1
+__vfork:
+	mov	r8, __NR_vfork
+	scall
+	cp.w	r12, -4096
+	retls	r12
+
+	/* vfork failed, so we may use the stack freely */
+	pushm	r4-r7,lr
+#ifdef __PIC__
+	lddpc	r6, .L_GOT
+	rsub	r4, r12, 0
+.L_RGOT:
+	rsub	r6, pc
+	mcall	r6[__errno_location@got]
+#else
+	rsub	r4, r12, 0
+	mcall	.L__errno_location
+#endif
+	st.w	r12[0], r4
+	popm	r4-r7,pc,r12=-1
+
+	.align	2
+#ifdef __PIC__
+.L_GOT:
+	.long	.L_RGOT - _GLOBAL_OFFSET_TABLE_
+#else
+.L__errno_location:
+	.long	__errno_location
+#endif
+	.size	__vfork, . - __vfork
+
+weak_alias(__vfork,vfork)
+libc_hidden_weak(vfork)
diff --git a/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h b/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h
new file mode 100644
index 0000000..eccf329
--- /dev/null
+++ b/libpthread/linuxthreads.old/sysdeps/avr32/pt-machine.h
@@ -0,0 +1,73 @@
+/* Machine-dependent pthreads configuration and inline functions.
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+static inline int
+_test_and_set (int *p, int v)
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline test and set */\n"
+		"	xchg	%[old], %[mem], %[new]"
+		: [old] "=&r"(result)
+		: [mem] "r"(p), [new] "r"(v)
+		: "memory");
+
+	return result;
+}
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+	return _test_and_set(spinlock, 1);
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("sp");
+
+/* Compare-and-swap for semaphores. */
+
+#define HAS_COMPARE_AND_SWAP
+PT_EI int
+__compare_and_swap(long int *p, long int oldval, long int newval)
+{
+	long int result;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%[result], %[mem]\n"
+		"	eor	%[result], %[old]\n"
+		"	brne	2f\n"
+		"	stcond	%[mem], %[new]\n"
+		"	brne	1b\n"
+		"2:"
+		: [result] "=&r"(result), [mem] "=m"(*p)
+		: "m"(*p), [new] "r"(newval), [old] "r"(oldval)
+		: "cc", "memory");
+
+	return result == 0;
+}
+
+#endif /* pt-machine.h */
diff --git a/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h b/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h
new file mode 100644
index 0000000..fe12bf8
--- /dev/null
+++ b/libpthread/linuxthreads/sysdeps/avr32/pt-machine.h
@@ -0,0 +1,73 @@
+/* Machine-dependent pthreads configuration and inline functions.
+ *
+ * Copyright (C) 2005-2007 Atmel Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser General
+ * Public License.  See the file "COPYING.LIB" in the main directory of this
+ * archive for more details.
+ */
+#ifndef _PT_MACHINE_H
+#define _PT_MACHINE_H   1
+
+#include <features.h>
+
+static inline int
+_test_and_set (int *p, int v) __THROW
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline test and set */\n"
+		"	xchg	%[old], %[mem], %[new]"
+		: [old] "=&r"(result)
+		: [mem] "r"(p), [new] "r"(v)
+		: "memory");
+
+	return result;
+}
+
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
+extern long int testandset (int *spinlock);
+extern int __compare_and_swap (long int *p, long int oldval, long int newval);
+
+/* Spinlock implementation; required.  */
+PT_EI long int
+testandset (int *spinlock)
+{
+	return _test_and_set(spinlock, 1);
+}
+
+
+/* Get some notion of the current stack.  Need not be exactly the top
+   of the stack, just something somewhere in the current frame.  */
+#define CURRENT_STACK_FRAME  stack_pointer
+register char * stack_pointer __asm__ ("sp");
+
+/* Compare-and-swap for semaphores. */
+
+#define HAS_COMPARE_AND_SWAP
+PT_EI int
+__compare_and_swap(long int *p, long int oldval, long int newval)
+{
+	int result;
+
+	__asm__ __volatile__(
+		"/* Inline compare and swap */\n"
+		"1:	ssrf	5\n"
+		"	ld.w	%[result], %[mem]\n"
+		"	eor	%[result], %[old]\n"
+		"	brne	2f\n"
+		"	stcond	%[mem], %[new]\n"
+		"	brne	1b\n"
+		"2:"
+		: [result] "=&r"(result), [mem] "=m"(*p)
+		: "m"(*p), [new] "r"(newval), [old] "r"(oldval)
+		: "cc", "memory");
+
+	return result == 0;
+}
+
+#endif /* pt-machine.h */
diff --git a/utils/ldd.c b/utils/ldd.c
index 75ad628..e34acd9 100644
--- a/utils/ldd.c
+++ b/utils/ldd.c
@@ -44,6 +44,11 @@
 #define ELFCLASSM	ELFCLASS32
 #endif
 
+#if defined(__avr32__)
+#define MATCH_MACHINE(x) (x == EM_AVR32)
+#define ELFCLASSM	ELFCLASS32
+#endif
+
 #if defined(__s390__)
 #define MATCH_MACHINE(x) (x == EM_S390)
 #define ELFCLASSM	ELFCLASS32
