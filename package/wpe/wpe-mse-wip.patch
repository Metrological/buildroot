From cb1c425663c3498f60113d37463c21cbe6fabd67 Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Tue, 6 Jan 2015 11:43:38 +0100
Subject: [PATCH 1/8] GStreamer: WiP patch for bug #140116

Needs to be reverted before landed upstream patch is merged to this
repository.
---
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp      |  2 +-
 .../gstreamer/MediaPlayerPrivateGStreamer.h        |  6 +---
 .../graphics/gstreamer/MediaSourceGStreamer.cpp    | 26 +++++++++++++--
 .../graphics/gstreamer/MediaSourceGStreamer.h      | 16 +++++++--
 .../gstreamer/SourceBufferPrivateGStreamer.cpp     | 27 ++++++++++-----
 .../gstreamer/SourceBufferPrivateGStreamer.h       | 38 ++++++++++++----------
 6 files changed, 78 insertions(+), 37 deletions(-)

diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 5217998..7449fb4 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -61,7 +61,7 @@
 #include <gst/audio/streamvolume.h>
 
 #if ENABLE(MEDIA_SOURCE)
-#include "MediaSource.h"
+#include "MediaSourceGStreamer.h"
 #include "WebKitMediaSourceGStreamer.h"
 #endif
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index ea9faf8..4d529eb 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -39,10 +39,6 @@
 #include <wtf/text/AtomicStringHash.h>
 #endif
 
-#if ENABLE(MEDIA_SOURCE)
-#include "MediaSourceGStreamer.h"
-#endif
-
 #if ENABLE(ENCRYPTED_MEDIA_V2)
 #include <wtf/threads/BinarySemaphore.h>
 #endif
@@ -69,6 +65,7 @@ class MediaPlayerPrivateGStreamer : public MediaPlayerPrivateGStreamerBase {
     ~MediaPlayerPrivateGStreamer();
     static void registerMediaEngine(MediaEngineRegistrar);
     void handleSyncMessage(GstMessage*);
+    static MediaPlayer::SupportsType supportsType(const MediaEngineSupportParameters&);
     gboolean handleMessage(GstMessage*);
     void handlePluginInstallerResult(GstInstallPluginsReturn);
 
@@ -150,7 +147,6 @@ class MediaPlayerPrivateGStreamer : public MediaPlayerPrivateGStreamerBase {
     static PassOwnPtr<MediaPlayerPrivateInterface> create(MediaPlayer*);
 
     static void getSupportedTypes(HashSet<String>&);
-    static MediaPlayer::SupportsType supportsType(const MediaEngineSupportParameters&);
 
     static bool isAvailable();
 #if ENABLE(ENCRYPTED_MEDIA_V2)
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
index 8d33a20..4b3c44d 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
@@ -35,6 +35,8 @@
 
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
+#include "ContentType.h"
+#include "MediaPlayerPrivateGStreamer.h"
 #include "NotImplemented.h"
 #include "SourceBufferPrivateGStreamer.h"
 #include "WebKitMediaSourceGStreamer.h"
@@ -59,14 +61,32 @@ MediaSourceGStreamer::MediaSourceGStreamer(MediaSourcePrivateClient* mediaSource
 
 MediaSourceGStreamer::~MediaSourceGStreamer()
 {
+    for (auto& sourceBuffer : m_sourceBuffers)
+        sourceBuffer->clearMediaSource();
 }
 
 MediaSourceGStreamer::AddStatus MediaSourceGStreamer::addSourceBuffer(const ContentType& contentType, RefPtr<SourceBufferPrivate>& sourceBufferPrivate)
 {
-    RefPtr<SourceBufferPrivateGStreamer> sourceBufferPrivateGStreamer = new SourceBufferPrivateGStreamer(m_client.get(), contentType);
+    MediaEngineSupportParameters parameters;
+    parameters.isMediaSource = true;
+    parameters.type = contentType.type();
+    parameters.codecs = contentType.parameter(ASCIILiteral("codecs"));
+    if (MediaPlayerPrivateGStreamer::supportsType(parameters) == MediaPlayer::IsNotSupported)
+        return NotSupported;
+
+    RefPtr<SourceBufferPrivateGStreamer> buffer = SourceBufferPrivateGStreamer::create(this);
+    m_sourceBuffers.add(buffer.get());
+    sourceBufferPrivate = buffer;
+    return m_client->addSourceBuffer(buffer, contentType);
+}
+
+void MediaSourceGStreamer::removeSourceBuffer(SourceBufferPrivate* buffer)
+{
+    auto* sourceBufferPrivateGStreamer = reinterpret_cast<SourceBufferPrivateGStreamer*>(buffer);
+    ASSERT(m_sourceBuffers.contains(sourceBufferPrivateGStreamer));
 
-    sourceBufferPrivate = adoptRef(sourceBufferPrivateGStreamer.get());
-    return m_client->addSourceBuffer(sourceBufferPrivateGStreamer, contentType);
+    sourceBufferPrivateGStreamer->clearMediaSource();
+    m_sourceBuffers.remove(sourceBufferPrivateGStreamer);
 }
 
 void MediaSourceGStreamer::durationChanged()
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
index f30b29f..a218881 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
@@ -34,18 +34,29 @@
 #define MediaSourceGStreamer_h
 
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
-#include "MediaSource.h"
-#include "WebKitMediaSourceGStreamer.h"
+#include "MediaSourcePrivate.h"
+
+#include <wtf/Forward.h>
+#include <wtf/HashSet.h>
+
+typedef struct _WebKitMediaSrc WebKitMediaSrc;
 
 namespace WebCore {
 
+class SourceBufferPrivateGStreamer;
+class MediaSourceClientGStreamer;
+
 // FIXME: Should this be called MediaSourcePrivateGStreamer?
 class MediaSourceGStreamer final : public MediaSourcePrivate {
 public:
     static void open(MediaSourcePrivateClient*, WebKitMediaSrc*);
     virtual ~MediaSourceGStreamer();
 
+    MediaSourceClientGStreamer& client() const { return *m_client; }
+
     virtual AddStatus addSourceBuffer(const ContentType&, RefPtr<SourceBufferPrivate>&);
+    void removeSourceBuffer(SourceBufferPrivate*);
+
     virtual void durationChanged();
     virtual void markEndOfStream(EndOfStreamStatus);
     virtual void unmarkEndOfStream();
@@ -59,6 +70,7 @@ class MediaSourceGStreamer final : public MediaSourcePrivate {
 private:
     MediaSourceGStreamer(MediaSourcePrivateClient*, WebKitMediaSrc*);
 
+    HashSet<SourceBufferPrivateGStreamer*> m_sourceBuffers;
     RefPtr<MediaSourceClientGStreamer> m_client;
     MediaSourcePrivateClient* m_mediaSource;
     MediaPlayer::ReadyState m_readyState;
diff --git a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
index bb50840..022e337 100644
--- a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
@@ -35,14 +35,19 @@
 
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
-#include "ContentType.h"
+#include "MediaSourceGStreamer.h"
 #include "NotImplemented.h"
+#include "WebKitMediaSourceGStreamer.h"
 
 namespace WebCore {
 
-SourceBufferPrivateGStreamer::SourceBufferPrivateGStreamer(PassRefPtr<MediaSourceClientGStreamer> client, const ContentType& contentType)
-    : m_type(contentType)
-    , m_client(client)
+PassRefPtr<SourceBufferPrivateGStreamer> SourceBufferPrivateGStreamer::create(MediaSourceGStreamer* mediaSource)
+{
+    return adoptRef(new SourceBufferPrivateGStreamer(mediaSource));
+}
+
+SourceBufferPrivateGStreamer::SourceBufferPrivateGStreamer(MediaSourceGStreamer* mediaSource)
+    : m_mediaSource(mediaSource)
     , m_readyState(MediaPlayer::HaveNothing)
 {
 }
@@ -58,11 +63,13 @@ void SourceBufferPrivateGStreamer::setClient(SourceBufferPrivateClient* client)
 
 void SourceBufferPrivateGStreamer::append(const unsigned char* data, unsigned length)
 {
-    ASSERT(m_client);
+    ASSERT(m_mediaSource);
     ASSERT(m_sourceBufferPrivateClient);
 
-    SourceBufferPrivateClient::AppendResult result = m_client->append(this, data, length);
-    m_sourceBufferPrivateClient->sourceBufferPrivateAppendComplete(this, result);
+    SourceBufferPrivateClient::AppendResult result = m_mediaSource->client().append(this, data, length);
+
+    if (m_sourceBufferPrivateClient)
+        m_sourceBufferPrivateClient->sourceBufferPrivateAppendComplete(this, result);
 }
 
 void SourceBufferPrivateGStreamer::abort()
@@ -72,7 +79,11 @@ void SourceBufferPrivateGStreamer::abort()
 
 void SourceBufferPrivateGStreamer::removedFromMediaSource()
 {
-    m_client->removedFromMediaSource(this);
+    if (!m_mediaSource)
+        return;
+
+    m_mediaSource->removeSourceBuffer(this);
+    m_mediaSource->client().removedFromMediaSource(this);
 }
 
 MediaPlayer::ReadyState SourceBufferPrivateGStreamer::readyState() const
diff --git a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
index 960f876..8f9e958 100644
--- a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
@@ -35,36 +35,38 @@
 
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
-#include "ContentType.h"
 #include "SourceBufferPrivate.h"
-#include "WebKitMediaSourceGStreamer.h"
 
 namespace WebCore {
 
+class MediaSourceGStreamer;
+
 class SourceBufferPrivateGStreamer final : public SourceBufferPrivate {
 public:
-    SourceBufferPrivateGStreamer(PassRefPtr<MediaSourceClientGStreamer>, const ContentType&);
+    static PassRefPtr<SourceBufferPrivateGStreamer> create(MediaSourceGStreamer*);
     virtual ~SourceBufferPrivateGStreamer();
 
-    virtual void setClient(SourceBufferPrivateClient*);
-
-    virtual void append(const unsigned char* data, unsigned length);
-    virtual void abort();
-    virtual void removedFromMediaSource();
+    void clearMediaSource() { m_mediaSource = nullptr; }
 
-    virtual MediaPlayer::ReadyState readyState() const;
-    virtual void setReadyState(MediaPlayer::ReadyState);
+    virtual void setClient(SourceBufferPrivateClient*) override;
+    virtual void append(const unsigned char* data, unsigned length) override;
+    virtual void abort() override;
+    virtual void removedFromMediaSource() override;
+    virtual MediaPlayer::ReadyState readyState() const override;
+    virtual void setReadyState(MediaPlayer::ReadyState) override;
 
-    virtual void flushAndEnqueueNonDisplayingSamples(Vector<RefPtr<MediaSample>>, AtomicString);
-    virtual void enqueueSample(PassRefPtr<MediaSample>, AtomicString);
-    virtual bool isReadyForMoreSamples(AtomicString);
-    virtual void setActive(bool);
-    virtual void stopAskingForMoreSamples(AtomicString);
-    virtual void notifyClientWhenReadyForMoreSamples(AtomicString);
+    virtual void flushAndEnqueueNonDisplayingSamples(Vector<RefPtr<MediaSample>>, AtomicString) override;
+    virtual void enqueueSample(PassRefPtr<MediaSample>, AtomicString) override;
+    virtual bool isReadyForMoreSamples(AtomicString) override;
+    virtual void setActive(bool) override;
+    virtual void stopAskingForMoreSamples(AtomicString) override;
+    virtual void notifyClientWhenReadyForMoreSamples(AtomicString) override;
 
 private:
-    ContentType m_type;
-    RefPtr<MediaSourceClientGStreamer> m_client;
+    SourceBufferPrivateGStreamer(MediaSourceGStreamer*);
+    friend class MediaSourceClientGStreamer;
+
+    MediaSourceGStreamer* m_mediaSource;
     SourceBufferPrivateClient* m_sourceBufferPrivateClient;
     MediaPlayer::ReadyState m_readyState;
 };

From 481545f8616f48ce23e110f869016ff402c71af9 Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Wed, 7 Jan 2015 12:50:04 +0100
Subject: [PATCH 2/8] [GStreamer][MSE] Disable WebM/vpx

Temporary workaround for Youtube TV. Make sure we don't request VP9
videos because that decoder is not yet enabled for the RPi in
buildroot.
---
 .../platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp       | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 7449fb4..aa4cc2f 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -1968,6 +1968,10 @@ MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::extendedSupportsType(cons
 
 MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::supportsType(const MediaEngineSupportParameters& parameters)
 {
+    // Disable VPX on MSE for now, mp4/avc1 seems way more reliable currently.
+    if (parameters.isMediaSource && (parameters.type == "video/webm"))
+        return MediaPlayer::IsNotSupported;
+
     if (parameters.type.isNull() || parameters.type.isEmpty())
         return MediaPlayer::IsNotSupported;
 

From b03805ace764ffe3dcf1e28cf58d0592b3e0cbf4 Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Tue, 6 Jan 2015 11:47:39 +0100
Subject: [PATCH 3/8] [GStreamer][MSE] WiP patch for bug #140117

---
 .../platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp   | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
index 61cfeb8..77c7740 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
@@ -349,8 +349,15 @@ MediaSourcePrivate::AddStatus MediaSourceClientGStreamer::addSourceBuffer(PassRe
 
 void MediaSourceClientGStreamer::durationChanged(const MediaTime& duration)
 {
+    if (!duration.isValid() || duration.isPositiveInfinite() || duration.isNegativeInfinite())
+        return;
+
     WebKitMediaSrcPrivate* priv = m_src->priv;
-    GstClockTime gstDuration = gst_util_uint64_scale(duration.timeValue(), GST_SECOND, duration.timeScale());
+    GstClockTime gstDuration;
+    if (duration.hasDoubleValue())
+        gstDuration = duration.toFloat() * GST_SECOND;
+    else
+        gstDuration = gst_util_uint64_scale(duration.timeValue(), GST_SECOND, duration.timeScale());
 
     GST_DEBUG_OBJECT(m_src.get(), "Received duration: %" GST_TIME_FORMAT, GST_TIME_ARGS(gstDuration));
 

From 240909c5abafec09a609af47139e3601b637eddb Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Tue, 6 Jan 2015 18:53:11 +0100
Subject: [PATCH 4/8] [GStreamer][MSE] keep track of active SourceBuffers

---
 .../platform/graphics/gstreamer/MediaSourceGStreamer.cpp       | 10 ++++++++++
 .../WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h |  3 +++
 .../graphics/gstreamer/SourceBufferPrivateGStreamer.cpp        |  5 +++--
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
index 4b3c44d..10aa234 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
@@ -87,6 +87,7 @@ void MediaSourceGStreamer::removeSourceBuffer(SourceBufferPrivate* buffer)
 
     sourceBufferPrivateGStreamer->clearMediaSource();
     m_sourceBuffers.remove(sourceBufferPrivateGStreamer);
+    m_activeSourceBuffers.remove(sourceBufferPrivateGStreamer);
 }
 
 void MediaSourceGStreamer::durationChanged()
@@ -124,5 +125,14 @@ void MediaSourceGStreamer::seekCompleted()
     notImplemented();
 }
 
+void MediaSourceGStreamer::sourceBufferPrivateDidChangeActiveState(SourceBufferPrivateGStreamer* buffer, bool isActive)
+{
+    if (isActive && !m_activeSourceBuffers.contains(buffer))
+        m_activeSourceBuffers.add(buffer);
+
+    if (!isActive)
+        m_activeSourceBuffers.remove(buffer);
+}
+
 }
 #endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
index a218881..37dde3f 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.h
@@ -67,10 +67,13 @@ class MediaSourceGStreamer final : public MediaSourcePrivate {
     virtual void waitForSeekCompleted();
     virtual void seekCompleted();
 
+    void sourceBufferPrivateDidChangeActiveState(SourceBufferPrivateGStreamer*, bool isActive);
+
 private:
     MediaSourceGStreamer(MediaSourcePrivateClient*, WebKitMediaSrc*);
 
     HashSet<SourceBufferPrivateGStreamer*> m_sourceBuffers;
+    HashSet<SourceBufferPrivateGStreamer*> m_activeSourceBuffers;
     RefPtr<MediaSourceClientGStreamer> m_client;
     MediaSourcePrivateClient* m_mediaSource;
     MediaPlayer::ReadyState m_readyState;
diff --git a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
index 022e337..154acbc 100644
--- a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
@@ -114,9 +114,10 @@ bool SourceBufferPrivateGStreamer::isReadyForMoreSamples(AtomicString)
     return false;
 }
 
-void SourceBufferPrivateGStreamer::setActive(bool)
+void SourceBufferPrivateGStreamer::setActive(bool isActive)
 {
-    notImplemented();
+    if (m_mediaSource)
+        m_mediaSource->sourceBufferPrivateDidChangeActiveState(this, isActive);
 }
 
 void SourceBufferPrivateGStreamer::stopAskingForMoreSamples(AtomicString)

From 9525cf72cd21af784a433624e4e97e8979151b8a Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Tue, 6 Jan 2015 17:45:19 +0100
Subject: [PATCH 5/8] [GStreamer][MSE] WiP patch for bug #140078
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Initial author: Sebastian Dr√∂ge <sebastian@centricular.com>
---
 .../gstreamer/AudioTrackPrivateGStreamer.cpp       |   2 +
 .../gstreamer/AudioTrackPrivateGStreamer.h         |   3 +-
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp      |  19 +
 .../graphics/gstreamer/MediaSourceGStreamer.cpp    |   7 +-
 .../gstreamer/SourceBufferPrivateGStreamer.cpp     |  24 +-
 .../gstreamer/SourceBufferPrivateGStreamer.h       |   4 +
 .../gstreamer/VideoTrackPrivateGStreamer.cpp       |   2 +
 .../gstreamer/VideoTrackPrivateGStreamer.h         |   4 +-
 .../gstreamer/WebKitMediaSourceGStreamer.cpp       | 631 +++++++++++++++++++--
 .../gstreamer/WebKitMediaSourceGStreamer.h         |  15 +-
 10 files changed, 657 insertions(+), 54 deletions(-)

diff --git a/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.cpp
index 2f0debc..4a9c6fd 100644
--- a/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.cpp
@@ -37,6 +37,8 @@ AudioTrackPrivateGStreamer::AudioTrackPrivateGStreamer(GRefPtr<GstElement> playb
     : TrackPrivateBaseGStreamer(this, index, pad)
     , m_playbin(playbin)
 {
+    // FIXME: Get a real ID here
+    m_id = "A" + String::number(index);
     notifyTrackOfActiveChanged();
 }
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.h
index 1775b20..8af74ef 100644
--- a/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/AudioTrackPrivateGStreamer.h
@@ -47,13 +47,14 @@ class AudioTrackPrivateGStreamer final : public AudioTrackPrivate, public TrackP
     virtual void setActive(bool enabled) override { setEnabled(enabled); }
 
     virtual int trackIndex() const override { return m_index; }
-
+    virtual AtomicString id() const override { return m_id; }
     virtual AtomicString label() const override { return m_label; }
     virtual AtomicString language() const override { return m_language; }
 
 private:
     AudioTrackPrivateGStreamer(GRefPtr<GstElement> playbin, gint index, GRefPtr<GstPad>);
 
+    AtomicString m_id;
     GRefPtr<GstElement> m_playbin;
 };
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index aa4cc2f..7d8ec6a 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -736,6 +736,15 @@ void MediaPlayerPrivateGStreamer::notifyPlayerOfVideo()
 
         RefPtr<VideoTrackPrivateGStreamer> track = VideoTrackPrivateGStreamer::create(m_playBin, i, pad);
         m_videoTracks.append(track);
+#if ENABLE(MEDIA_SOURCE)
+        if (isMediaSource()) {
+            // TODO: This will leak if the event gets freed without arriving in
+            // the source, e.g. when we go flushing here
+            RefPtr<VideoTrackPrivateGStreamer>* trackCopy = new RefPtr<VideoTrackPrivateGStreamer>(track);
+            GstStructure* videoEventStructure = gst_structure_new("webKitVideoTrack", "track", G_TYPE_POINTER, trackCopy, nullptr);
+            gst_pad_push_event(pad.get(), gst_event_new_custom(GST_EVENT_CUSTOM_UPSTREAM, videoEventStructure));
+        }
+#endif
         m_player->addVideoTrack(track.release());
     }
 
@@ -784,6 +793,15 @@ void MediaPlayerPrivateGStreamer::notifyPlayerOfAudio()
 
         RefPtr<AudioTrackPrivateGStreamer> track = AudioTrackPrivateGStreamer::create(m_playBin, i, pad);
         m_audioTracks.insert(i, track);
+ #if ENABLE(MEDIA_SOURCE)
+         if (isMediaSource()) {
+             // TODO: This will leak if the event gets freed without arriving in
+             // the source, e.g. when we go flushing here
+             RefPtr<AudioTrackPrivateGStreamer>* trackCopy = new RefPtr<AudioTrackPrivateGStreamer>(track);
+             GstStructure* audioEventStructure = gst_structure_new("webKitAudioTrack", "track", G_TYPE_POINTER, trackCopy, nullptr);
+             gst_pad_push_event(pad.get(), gst_event_new_custom(GST_EVENT_CUSTOM_UPSTREAM, audioEventStructure));
+         }
+ #endif
         m_player->addAudioTrack(track.release());
     }
 
@@ -824,6 +842,7 @@ void MediaPlayerPrivateGStreamer::notifyPlayerOfText()
 
         RefPtr<InbandTextTrackPrivateGStreamer> track = InbandTextTrackPrivateGStreamer::create(i, pad);
         m_textTracks.insert(i, track);
+        // TODO: Text tracks for the media source
         m_player->addTextTrack(track.release());
     }
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
index 10aa234..f51891a 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaSourceGStreamer.cpp
@@ -48,15 +48,16 @@ namespace WebCore {
 void MediaSourceGStreamer::open(MediaSourcePrivateClient* mediaSource, WebKitMediaSrc* src)
 {
     ASSERT(mediaSource);
-    mediaSource->setPrivateAndOpen(adoptRef(*new MediaSourceGStreamer(mediaSource, src)));
+    RefPtr<MediaSourceGStreamer> sourceGStreamer = adoptRef(new MediaSourceGStreamer(mediaSource, src));
+    mediaSource->setPrivateAndOpen(*sourceGStreamer);
 }
 
 MediaSourceGStreamer::MediaSourceGStreamer(MediaSourcePrivateClient* mediaSource, WebKitMediaSrc* src)
-    : m_client(adoptRef(new MediaSourceClientGStreamer(src)))
+    : MediaSourcePrivate()
     , m_mediaSource(mediaSource)
     , m_readyState(MediaPlayer::HaveNothing)
 {
-    ASSERT(m_client);
+    m_client = MediaSourceClientGStreamer::create(src);
 }
 
 MediaSourceGStreamer::~MediaSourceGStreamer()
diff --git a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
index 154acbc..24cada5 100644
--- a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.cpp
@@ -36,6 +36,7 @@
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
 #include "MediaSourceGStreamer.h"
+#include "MediaSample.h"
 #include "NotImplemented.h"
 #include "WebKitMediaSourceGStreamer.h"
 
@@ -66,10 +67,13 @@ void SourceBufferPrivateGStreamer::append(const unsigned char* data, unsigned le
     ASSERT(m_mediaSource);
     ASSERT(m_sourceBufferPrivateClient);
 
-    SourceBufferPrivateClient::AppendResult result = m_mediaSource->client().append(this, data, length);
-
-    if (m_sourceBufferPrivateClient)
-        m_sourceBufferPrivateClient->sourceBufferPrivateAppendComplete(this, result);
+    if (!m_mediaSource->client().append(this, data, length)) {
+        if (m_sourceBufferPrivateClient)
+            m_sourceBufferPrivateClient->sourceBufferPrivateAppendComplete(this, SourceBufferPrivateClient::ReadStreamFailed);
+    } else {
+        if (m_sourceBufferPrivateClient)
+            m_sourceBufferPrivateClient->sourceBufferPrivateAppendComplete(this, SourceBufferPrivateClient::AppendSucceeded);
+    }
 }
 
 void SourceBufferPrivateGStreamer::abort()
@@ -130,5 +134,17 @@ void SourceBufferPrivateGStreamer::notifyClientWhenReadyForMoreSamples(AtomicStr
     notImplemented();
 }
 
+void SourceBufferPrivateGStreamer::didReceiveInitializationSegment(const SourceBufferPrivateClient::InitializationSegment& initializationSegment)
+{
+    if (m_sourceBufferPrivateClient)
+        m_sourceBufferPrivateClient->sourceBufferPrivateDidReceiveInitializationSegment(this, initializationSegment);
+}
+
+void SourceBufferPrivateGStreamer::didReceiveSample(PassRefPtr<MediaSample> sample)
+{
+    if (m_sourceBufferPrivateClient)
+        m_sourceBufferPrivateClient->sourceBufferPrivateDidReceiveSample(this, sample);
+}
+
 }
 #endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
index 8f9e958..541c004 100644
--- a/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/SourceBufferPrivateGStreamer.h
@@ -36,6 +36,7 @@
 #if ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
 #include "SourceBufferPrivate.h"
+#include "SourceBufferPrivateClient.h"
 
 namespace WebCore {
 
@@ -66,6 +67,9 @@ class SourceBufferPrivateGStreamer final : public SourceBufferPrivate {
     SourceBufferPrivateGStreamer(MediaSourceGStreamer*);
     friend class MediaSourceClientGStreamer;
 
+    void didReceiveInitializationSegment(const SourceBufferPrivateClient::InitializationSegment&);
+    void didReceiveSample(PassRefPtr<MediaSample>);
+
     MediaSourceGStreamer* m_mediaSource;
     SourceBufferPrivateClient* m_sourceBufferPrivateClient;
     MediaPlayer::ReadyState m_readyState;
diff --git a/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.cpp
index e3652c3..cfcdf00 100644
--- a/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.cpp
@@ -37,6 +37,8 @@ VideoTrackPrivateGStreamer::VideoTrackPrivateGStreamer(GRefPtr<GstElement> playb
     : TrackPrivateBaseGStreamer(this, index, pad)
     , m_playbin(playbin)
 {
+    // FIXME: Get a real ID here
+    m_id = "V" + String::number(index);
     notifyTrackOfActiveChanged();
 }
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.h
index b216221..45a3bf6 100644
--- a/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/VideoTrackPrivateGStreamer.h
@@ -47,13 +47,13 @@ class VideoTrackPrivateGStreamer final : public VideoTrackPrivate, public TrackP
     virtual void setActive(bool enabled) override { setSelected(enabled); }
 
     virtual int trackIndex() const override { return m_index; }
-
+    virtual AtomicString id() const override { return m_id; }
     virtual AtomicString label() const override { return m_label; }
     virtual AtomicString language() const override { return m_language; }
 
 private:
     VideoTrackPrivateGStreamer(GRefPtr<GstElement> playbin, gint index, GRefPtr<GstPad>);
-
+    AtomicString m_id;
     GRefPtr<GstElement> m_playbin;
 };
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
index 77c7740..683fd35 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
@@ -24,21 +24,164 @@
 
 #if ENABLE(VIDEO) && ENABLE(MEDIA_SOURCE) && USE(GSTREAMER)
 
+#include "AudioTrackPrivateGStreamer.h"
 #include "GStreamerUtilities.h"
+#include "MediaDescription.h"
+#include "MediaSample.h"
+#include "MediaSourceGStreamer.h"
 #include "NotImplemented.h"
+#include "SourceBufferPrivateGStreamer.h"
 #include "TimeRanges.h"
+#include "VideoTrackPrivateGStreamer.h"
 
-#include <gst/app/gstappsrc.h>
-#include <gst/gst.h>
-#include <gst/pbutils/missing-plugins.h>
+#include <gst/app/app.h>
+#include <gst/pbutils/pbutils.h>
+#include <gst/video/video.h>
 #include <wtf/gobject/GUniquePtr.h>
 #include <wtf/text/CString.h>
 
+namespace WebCore
+{
+class GStreamerMediaDescription : public MediaDescription {
+private:
+    GstCaps* m_caps;
+public:
+    static PassRefPtr<GStreamerMediaDescription> create(GstCaps* caps)
+    {
+        return adoptRef(new GStreamerMediaDescription(caps));
+    }
+
+    virtual ~GStreamerMediaDescription()
+    {
+        gst_caps_unref(m_caps);
+    }
+
+    AtomicString codec() const override
+    {
+        gchar* description = gst_pb_utils_get_codec_description(m_caps);
+        AtomicString codecName(description);
+        g_free(description);
+
+        return codecName;
+    }
+
+    bool isVideo() const override
+    {
+        GstStructure* s = gst_caps_get_structure(m_caps, 0);
+        const gchar* name = gst_structure_get_name(s);
+
+        return g_str_has_prefix(name, "video/");
+    }
+
+    bool isAudio() const override
+    {
+        GstStructure* s = gst_caps_get_structure(m_caps, 0);
+        const gchar* name = gst_structure_get_name(s);
+
+        return g_str_has_prefix(name, "audio/");
+    }
+
+    bool isText() const override
+    {
+        // TODO
+        return false;
+    }
+
+private:
+    GStreamerMediaDescription(GstCaps* caps)
+        : MediaDescription()
+        , m_caps(gst_caps_ref(caps))
+    {
+    }
+};
+
+class GStreamerMediaSample : public MediaSample
+{
+private:
+    MediaTime m_pts, m_dts, m_duration;
+    AtomicString m_trackID;
+    size_t m_size;
+    FloatSize m_presentationSize;
+    MediaSample::SampleFlags m_flags;
+    GStreamerMediaSample(GstBuffer* buffer, const FloatSize& presentationSize, const AtomicString& trackID)
+        : MediaSample()
+        , m_pts(MediaTime::zeroTime())
+        , m_dts(MediaTime::zeroTime())
+        , m_duration(MediaTime::zeroTime())
+        , m_trackID(trackID)
+        , m_presentationSize(presentationSize)
+        , m_flags(MediaSample::IsSync)
+    {
+        if (GST_BUFFER_PTS_IS_VALID(buffer))
+            m_pts = MediaTime(GST_BUFFER_PTS(buffer), GST_SECOND);
+        if (GST_BUFFER_DTS_IS_VALID(buffer))
+            m_dts = MediaTime(GST_BUFFER_DTS(buffer), GST_SECOND);
+        if (GST_BUFFER_DURATION_IS_VALID(buffer))
+            m_duration = MediaTime(GST_BUFFER_DURATION(buffer), GST_SECOND);
+        m_size = gst_buffer_get_size(buffer);
+
+        if (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DELTA_UNIT))
+            m_flags = MediaSample::None;
+
+        if (GST_BUFFER_FLAG_IS_SET(buffer, GST_BUFFER_FLAG_DECODE_ONLY))
+            m_flags = (MediaSample::SampleFlags) (m_flags | MediaSample::NonDisplaying);
+    }
+
+public:
+    static PassRefPtr<GStreamerMediaSample> create(GstBuffer* buffer, const FloatSize& presentationSize, const AtomicString& trackID)
+    {
+        return adoptRef(new GStreamerMediaSample(buffer, presentationSize, trackID));
+    }
+
+    MediaTime presentationTime() const { return m_pts; }
+    MediaTime decodeTime() const { return m_dts; }
+    MediaTime duration() const { return m_duration; }
+    AtomicString trackID() const { return m_trackID; }
+    size_t sizeInBytes() const { return m_size; }
+    FloatSize presentationSize() const { return m_presentationSize; }
+    SampleFlags flags() const { return m_flags; }
+    PlatformSample platformSample() { return PlatformSample(); }
+    void dump(PrintStream&) const {}
+};
+};
+
+typedef struct _Stream Stream;
 typedef struct _Source Source;
+
+typedef struct {
+    GstBuffer* buffer;
+    WebCore::FloatSize presentationSize;
+} PendingReceiveSample;
+
+struct _Stream
+{
+    Source* parent;
+
+    // Might be 0, e.g. for VP8/VP9
+    GstElement *parser;
+    GstPad* srcpad;
+    GstCaps* caps;
+    RefPtr<WebCore::AudioTrackPrivateGStreamer> *audioTrack;
+    RefPtr<WebCore::VideoTrackPrivateGStreamer> *videoTrack;
+    WebCore::FloatSize presentationSize;
+    GList* pendingReceiveSample;
+};
+
 struct _Source {
+    WebKitMediaSrc* parent;
     GstElement* src;
+    GstElement* typefind;
+    // May be 0 if elementary stream
+    GstElement* demuxer;
+    GstElement* multiqueue;
+    GList* streams;
+
+    // We expose everything when
+    // all sources are noMorePads
+    bool noMorePads;
+
     // Just for identification
-    WebCore::SourceBufferPrivate* sourceBuffer;
+    WebCore::SourceBufferPrivateGStreamer* sourceBuffer;
 };
 
 struct _WebKitMediaSrcPrivate {
@@ -48,6 +191,9 @@ struct _WebKitMediaSrcPrivate {
     bool haveAppsrc;
     bool asyncStart;
     bool noMorePads;
+    int numberOfPads;
+
+    WebCore::MediaSourceClientGStreamer* mediaSourceClient;
 };
 
 enum {
@@ -69,6 +215,7 @@ static void webKitMediaSrcSetProperty(GObject*, guint propertyId, const GValue*,
 static void webKitMediaSrcGetProperty(GObject*, guint propertyId, GValue*, GParamSpec*);
 static GstStateChangeReturn webKitMediaSrcChangeState(GstElement*, GstStateChange);
 static gboolean webKitMediaSrcQueryWithParent(GstPad*, GstObject*, GstQuery*);
+static gboolean webKitMediaSrcEventWithParent(GstPad*, GstObject*, GstEvent*);
 
 #define webkit_media_src_parent_class parent_class
 // We split this out into another macro to avoid a check-webkit-style error.
@@ -242,6 +389,407 @@ static gboolean webKitMediaSrcQueryWithParent(GstPad* pad, GstObject* parent, Gs
     return result;
 }
 
+static void webKitMediaSrcDidReceiveInitializationSegment(Source* source);
+
+static gboolean webKitMediaSrcEventWithParent(GstPad* pad, GstObject* parent, GstEvent* event)
+{
+    gboolean result = FALSE;
+
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_CUSTOM_UPSTREAM:{
+        const GstStructure* s = gst_event_get_structure(event);
+
+        if (gst_structure_has_name(s, "webKitAudioTrack")) {
+            Stream* stream = (Stream*) gst_pad_get_element_private(pad);
+            RefPtr<WebCore::AudioTrackPrivateGStreamer>* audioTrack;
+
+            gst_structure_get(s, "track", G_TYPE_POINTER, &audioTrack, nullptr);
+            stream->audioTrack = audioTrack;
+
+            webKitMediaSrcDidReceiveInitializationSegment(stream->parent);
+
+            result = TRUE;
+            gst_event_unref(event);
+        } else if (gst_structure_has_name(s, "webKitVideoTrack")) {
+            Stream* stream = (Stream*) gst_pad_get_element_private(pad);
+            RefPtr<WebCore::VideoTrackPrivateGStreamer>* videoTrack;
+
+            gst_structure_get(s, "track", G_TYPE_POINTER, &videoTrack, nullptr);
+            stream->videoTrack = videoTrack;
+
+            webKitMediaSrcDidReceiveInitializationSegment(stream->parent);
+
+            result = TRUE;
+            gst_event_unref(event);
+        } else {
+            result = gst_pad_event_default(pad, parent, event);
+        }
+        break;
+    }
+    default:
+        result = gst_pad_event_default(pad, parent, event);
+        break;
+    }
+
+    return result;
+}
+
+static GstPad* get_internal_linked_pad(GstPad* pad)
+{
+    GstIterator* it;
+    GstPad* otherpad;
+    GValue item = G_VALUE_INIT;
+
+    it = gst_pad_iterate_internal_links(pad);
+
+    if (!it || (gst_iterator_next(it, &item)) != GST_ITERATOR_OK
+        || ((otherpad = GST_PAD(g_value_dup_object(&item))) == 0)) {
+        return 0;
+    }
+    g_value_unset(&item);
+    if (it)
+        gst_iterator_free(it);
+
+    return otherpad;
+}
+
+typedef struct {
+    Stream* stream;
+    WTF::RefPtr<WebCore::GStreamerMediaSample> sample;
+} ReceiveSample;
+
+static gboolean webKitWebSrcDidReceiveSample(ReceiveSample* sample)
+{
+    sample->stream->parent->parent->priv->mediaSourceClient->didReceiveSample(sample->stream->parent->sourceBuffer, sample->sample);
+    sample->sample.release();
+    g_free(sample);
+    return G_SOURCE_REMOVE;
+}
+
+static GstPadProbeReturn webKitWebSrcBufferProbe(GstPad*, GstPadProbeInfo* info, Stream* stream)
+{
+    GstBuffer* buffer = GST_BUFFER(info->data);
+
+    if (!stream->audioTrack && !stream->videoTrack) {
+        PendingReceiveSample* sample = g_new0(PendingReceiveSample, 1);
+        sample->buffer = gst_buffer_ref(buffer);
+        sample->presentationSize = stream->presentationSize;
+        stream->pendingReceiveSample = g_list_append(stream->pendingReceiveSample, sample);
+    } else {
+        ReceiveSample* sample = g_new0(ReceiveSample, 1);
+        sample->sample = WebCore::GStreamerMediaSample::create(buffer, stream->presentationSize, stream->audioTrack ? stream->audioTrack->get()->id() : stream->videoTrack->get()->id());
+        sample->stream = stream;
+        g_idle_add((GSourceFunc)webKitWebSrcDidReceiveSample, sample);
+    }
+    return GST_PAD_PROBE_OK;
+}
+
+static void webKitMediaSrcDemuxerNoMorePads(GstElement*, Source* source);
+
+static void webKitMediaSrcParserNotifyCaps(GObject* object, GParamSpec*, Stream* stream)
+{
+    GstPad* srcpad = GST_PAD(object);
+    GstCaps* caps = gst_pad_get_current_caps(srcpad);
+
+    if (!caps)
+        return;
+
+    GstStructure* s = gst_caps_get_structure(caps, 0);
+    const gchar* structureName = gst_structure_get_name(s);
+    GstVideoInfo info;
+    if (g_str_has_prefix(structureName, "video/") && gst_video_info_from_caps(&info, caps)) {
+        float width, height;
+
+        // TODO: correct?
+        width = info.width;
+        height = info.height * ((float) info.par_d / (float) info.par_n);
+        stream->presentationSize = WebCore::FloatSize(width, height);
+    } else {
+        stream->presentationSize = WebCore::FloatSize();
+    }
+
+    // TODO
+    if (gst_pad_is_linked(srcpad)) {
+        gst_caps_unref(caps);
+        return;
+    }
+
+    // TODO: Atomic ints, GRefPtr
+    gchar* padName = g_strdup_printf("src_%u", stream->parent->parent->priv->numberOfPads++);
+    GstPad* ghostpad = gst_ghost_pad_new_from_template(padName, srcpad, gst_static_pad_template_get(&srcTemplate));
+
+
+    gst_pad_set_query_function(ghostpad, webKitMediaSrcQueryWithParent);
+    gst_pad_set_event_function(ghostpad, webKitMediaSrcEventWithParent);
+
+    gst_pad_set_element_private(ghostpad, stream);
+    gst_pad_add_probe(ghostpad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) webKitWebSrcBufferProbe, stream, nullptr);
+
+    gst_pad_set_active(ghostpad, TRUE);
+    gst_element_add_pad(GST_ELEMENT(stream->parent->parent), ghostpad);
+    stream->srcpad = ghostpad;
+    stream->caps = caps;
+
+    webKitMediaSrcDemuxerNoMorePads(nullptr, stream->parent);
+}
+
+static void webKitMediaSrcDemuxerPadAdded(GstElement* demuxer, GstPad* pad, Source* source)
+{
+    GstCaps* caps = gst_pad_get_current_caps(pad);
+    GstStructure* s = gst_caps_get_structure(caps, 0);
+    Stream* stream = g_new0(Stream, 1);
+
+    stream->parent = source;
+    source->streams = g_list_prepend(source->streams, stream);
+
+    g_assert(caps != 0);
+
+    if (gst_structure_has_name(s, "video/x-h264")) {
+        GstElement* parser;
+        GstElement* capsfilter;
+        GstPad* pad;
+        GstCaps* caps;
+
+        caps = gst_caps_new_simple("video/x-h264", "alignment", G_TYPE_STRING, "au", NULL);
+        parser = gst_element_factory_make("h264parse", 0);
+        capsfilter = gst_element_factory_make("capsfilter", 0);
+        g_object_set(capsfilter, "caps", caps, nullptr);
+        gst_caps_unref(caps);
+
+        stream->parser = gst_bin_new(nullptr);
+        gst_bin_add_many(GST_BIN(stream->parser), parser, capsfilter, nullptr);
+        gst_element_link_pads(parser, "src", capsfilter, "sink");
+
+        pad = gst_element_get_static_pad(parser, "sink");
+        gst_element_add_pad(stream->parser, gst_ghost_pad_new("sink", pad));
+        gst_object_unref(pad);
+
+        pad = gst_element_get_static_pad(capsfilter, "src");
+        gst_element_add_pad(stream->parser, gst_ghost_pad_new("src", pad));
+        gst_object_unref(pad);
+    } else if (gst_structure_has_name(s, "video/x-h265")) {
+        GstElement* parser;
+        GstElement* capsfilter;
+        GstPad* pad;
+        GstCaps* caps;
+
+        caps = gst_caps_new_simple("video/x-h265", "alignment", G_TYPE_STRING, "au", NULL);
+        parser = gst_element_factory_make("h265parse", 0);
+        capsfilter = gst_element_factory_make("capsfilter", 0);
+        g_object_set(capsfilter, "caps", caps, nullptr);
+        gst_caps_unref(caps);
+
+        stream->parser = gst_bin_new(nullptr);
+        gst_bin_add_many(GST_BIN(stream->parser), parser, capsfilter, nullptr);
+        gst_element_link_pads(parser, "src", capsfilter, "sink");
+
+        pad = gst_element_get_static_pad(parser, "sink");
+        gst_element_add_pad(stream->parser, gst_ghost_pad_new("sink", pad));
+        gst_object_unref(pad);
+
+        pad = gst_element_get_static_pad(capsfilter, "src");
+        gst_element_add_pad(stream->parser, gst_ghost_pad_new("src", pad));
+        gst_object_unref(pad);
+    } else if (gst_structure_has_name(s, "audio/mpeg")) {
+        gint mpegversion = -1;
+
+        gst_structure_get_int(s, "mpegversion", &mpegversion);
+        if (mpegversion == 1) {
+            stream->parser = gst_element_factory_make("mpegaudioparse", 0);
+        } else if (mpegversion == 2 || mpegversion == 4) {
+            stream->parser = gst_element_factory_make("aacparse", 0);
+        } else {
+            g_assert_not_reached();
+        }
+    }
+
+    GstPad* sinkpad;
+    GstPad* srcpad;
+    GstPad* ghostpad;
+
+    sinkpad = gst_element_get_request_pad(source->multiqueue, "sink_%u");
+    gst_pad_link(pad, sinkpad);
+
+    srcpad = get_internal_linked_pad(sinkpad);
+    gst_object_unref(sinkpad);
+
+    if (stream->parser) {
+        gst_bin_add(GST_BIN(source->parent), stream->parser);
+        gst_element_sync_state_with_parent(stream->parser);
+        sinkpad = gst_element_get_static_pad(stream->parser, "sink");
+        gst_pad_link(srcpad, sinkpad);
+        gst_object_unref(srcpad);
+        gst_object_unref(sinkpad);
+        srcpad = gst_element_get_static_pad(stream->parser, "src");
+        g_signal_connect(srcpad, "notify::caps", G_CALLBACK(webKitMediaSrcParserNotifyCaps), stream);
+        gst_object_unref(srcpad);
+        gst_caps_unref(caps);
+        return;
+    }
+
+    g_signal_connect(srcpad, "notify::caps", G_CALLBACK(webKitMediaSrcParserNotifyCaps), stream);
+
+    // TODO: Atomic ints, GRefPtr
+    gchar* padName = g_strdup_printf("src_%u", source->parent->priv->numberOfPads++);
+    ghostpad = gst_ghost_pad_new_from_template(padName, srcpad, gst_static_pad_template_get(&srcTemplate));
+    gst_object_unref(srcpad);
+
+    gst_pad_set_query_function(ghostpad, webKitMediaSrcQueryWithParent);
+    gst_pad_set_event_function(ghostpad, webKitMediaSrcEventWithParent);
+
+    gst_pad_set_element_private(ghostpad, stream);
+    gst_pad_add_probe(ghostpad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback) webKitWebSrcBufferProbe, stream, nullptr);
+
+    gst_pad_set_active(ghostpad, TRUE);
+    gst_element_add_pad(GST_ELEMENT(source->parent), ghostpad);
+    stream->srcpad = ghostpad;
+    stream->caps = caps;
+
+    const gchar* structureName = gst_structure_get_name(s);
+    GstVideoInfo info;
+    if (g_str_has_prefix(structureName, "video/") && gst_video_info_from_caps(&info, caps)) {
+        float width, height;
+
+        // TODO: correct?
+        width = info.width;
+        height = info.height * ((float) info.par_d / (float) info.par_n);
+
+        stream->presentationSize = WebCore::FloatSize(width, height);
+    } else {
+        stream->presentationSize = WebCore::FloatSize();
+    }
+}
+
+static void webKitMediaSrcDemuxerPadRemoved(GstElement* demuxer, GstPad* pad, Source* source)
+{
+
+}
+
+static void webKitMediaSrcDidReceiveInitializationSegment(Source* source)
+{
+    GList* l;
+    for (l = source->streams; l; l = l->next) {
+        Stream* stream = (Stream*)l->data;
+        if (!stream->audioTrack && !stream->videoTrack)
+            return;
+    }
+
+    // TODO: Locking
+    WebCore::SourceBufferPrivateClient::InitializationSegment initializationSegment;
+
+    initializationSegment.duration = MediaTime(source->parent->priv->duration, GST_SECOND);
+    for (l = source->streams; l; l = l->next) {
+        Stream* stream = (Stream*)l->data;
+        GstCaps* caps = stream->caps;
+
+        if (stream->audioTrack) {
+            WebCore::SourceBufferPrivateClient::InitializationSegment::AudioTrackInformation info;
+            info.track = *stream->audioTrack;
+            info.description = WebCore::GStreamerMediaDescription::create(stream->caps);
+            initializationSegment.audioTracks.append(info);
+        } else if (stream->videoTrack) {
+            WebCore::SourceBufferPrivateClient::InitializationSegment::VideoTrackInformation info;
+            info.track = *stream->videoTrack;
+            info.description = WebCore::GStreamerMediaDescription::create(stream->caps);
+            initializationSegment.videoTracks.append(info);
+        } else {
+            g_assert_not_reached();
+        }
+    }
+
+    source->parent->priv->mediaSourceClient->didReceiveInitializationSegment(source->sourceBuffer, initializationSegment);
+
+    for (l = source->streams; l; l = l->next) {
+        Stream* stream = (Stream*)l->data;
+        GList* m;
+
+        for (m = stream->pendingReceiveSample; m; m = m->next) {
+            PendingReceiveSample* pending = (PendingReceiveSample*)m->data;
+
+            RefPtr<WebCore::GStreamerMediaSample> sample = WebCore::GStreamerMediaSample::create(pending->buffer, pending->presentationSize, stream->audioTrack ? stream->audioTrack->get()->id() : stream->videoTrack->get()->id());
+            source->parent->priv->mediaSourceClient->didReceiveSample(source->sourceBuffer, sample);
+            gst_buffer_unref(pending->buffer);
+            g_free(pending);
+        }
+        g_list_free(stream->pendingReceiveSample);
+        stream->pendingReceiveSample = nullptr;
+    }
+}
+
+static void webKitMediaSrcDemuxerNoMorePads(GstElement*, Source* source)
+{
+    GList* l;
+    bool allDone = true;
+    source->noMorePads = true;
+    // TODO: Locking
+    for (l = source->parent->priv->sources; l; l = l->next) {
+        Source* tmp = (Source*)l->data;
+
+        allDone = allDone && tmp->noMorePads;
+
+        GList* m;
+        for (m = source->streams; m; m = m->next) {
+            Stream* stream = (Stream*)m->data;
+
+            allDone = allDone && stream->caps != nullptr;
+        }
+    }
+    if (allDone) {
+        source->parent->priv->noMorePads = true;
+        gst_element_no_more_pads(GST_ELEMENT(source->parent));
+        webKitMediaSrcDoAsyncDone(source->parent);
+    }
+}
+
+static void webKitMediaSrcHaveType(GstElement* typefind, guint probability, GstCaps* caps, Source* source)
+{
+    if (source->demuxer || source->streams)
+        return;
+
+    GstStructure* s = gst_caps_get_structure(caps, 0);
+    if (gst_structure_has_name(s, "video/webm") || gst_structure_has_name(s, "audio/webm")) {
+        source->demuxer = gst_element_factory_make("matroskademux", NULL);
+    } else if (gst_structure_has_name(s, "video/quicktime") || gst_structure_has_name(s, "audio/x-m4a")
+               || gst_structure_has_name(s, "application/x-3gp")) {
+        source->demuxer = gst_element_factory_make("qtdemux", NULL);
+    } else if (gst_structure_has_name(s, "video/mpegts")) {
+        source->demuxer = gst_element_factory_make("tsdemux", NULL);
+    } else if (gst_structure_has_name(s, "audio/mpeg")) {
+        gint mpegversion = -1;
+
+        gst_structure_get_int(s, "mpegversion", &mpegversion);
+        if (mpegversion == 1) {
+            // TODO: MP3
+            g_assert_not_reached();
+        } else if (mpegversion == 2 || mpegversion == 4) {
+            // TODO: AAC
+            g_assert_not_reached();
+        } else {
+            g_assert_not_reached();
+        }
+    } else {
+        g_assert_not_reached();
+    }
+
+    if (source->demuxer) {
+        source->multiqueue = gst_element_factory_make("multiqueue", NULL);
+
+        gst_bin_add_many(GST_BIN(source->parent), source->demuxer, source->multiqueue, nullptr);
+        gst_element_sync_state_with_parent(source->demuxer);
+        gst_element_sync_state_with_parent(source->multiqueue);
+
+        gst_element_link_pads(typefind, "src", source->demuxer, "sink");
+
+        g_signal_connect(source->demuxer, "pad-added", G_CALLBACK(webKitMediaSrcDemuxerPadAdded), source);
+        g_signal_connect(source->demuxer, "pad-removed", G_CALLBACK(webKitMediaSrcDemuxerPadRemoved), source);
+        g_signal_connect(source->demuxer, "no-more-pads", G_CALLBACK(webKitMediaSrcDemuxerNoMorePads), source);
+    } else {
+        g_assert_not_reached();
+    }
+}
+
+
+
 // uri handler interface
 static GstURIType webKitMediaSrcUriGetType(GType)
 {
@@ -300,16 +848,23 @@ static void webKitMediaSrcUriHandlerInit(gpointer gIface, gpointer)
 }
 
 namespace WebCore {
+PassRefPtr<MediaSourceClientGStreamer> MediaSourceClientGStreamer::create(WebKitMediaSrc* src)
+{
+    return adoptRef(new MediaSourceClientGStreamer(src));
+}
+
 MediaSourceClientGStreamer::MediaSourceClientGStreamer(WebKitMediaSrc* src)
-    : m_src(adoptGRef(static_cast<WebKitMediaSrc*>(gst_object_ref(src))))
+    : RefCounted<MediaSourceClientGStreamer>()
+    , m_src(adoptGRef(static_cast<WebKitMediaSrc*>(gst_object_ref(src))))
 {
+    m_src->priv->mediaSourceClient = this;
 }
 
 MediaSourceClientGStreamer::~MediaSourceClientGStreamer()
 {
 }
 
-MediaSourcePrivate::AddStatus MediaSourceClientGStreamer::addSourceBuffer(PassRefPtr<SourceBufferPrivate> sourceBufferPrivate, const ContentType&)
+MediaSourcePrivate::AddStatus MediaSourceClientGStreamer::addSourceBuffer(PassRefPtr<SourceBufferPrivateGStreamer> sourceBufferPrivate, const ContentType&)
 {
     WebKitMediaSrcPrivate* priv = m_src->priv;
 
@@ -325,24 +880,20 @@ MediaSourcePrivate::AddStatus MediaSourceClientGStreamer::addSourceBuffer(PassRe
     Source* source = g_new0(Source, 1);
     guint numberOfSources = g_list_length(priv->sources);
     GUniquePtr<gchar> srcName(g_strdup_printf("src%u", numberOfSources));
-
+    GUniquePtr<gchar> typefindName(g_strdup_printf("typefind%u", numberOfSources));
+    source->parent = m_src.get();
     source->src = gst_element_factory_make("appsrc", srcName.get());
+    source->typefind = gst_element_factory_make("typefind", typefindName.get());
+    g_signal_connect(source->typefind, "have-type", G_CALLBACK(webKitMediaSrcHaveType), source);
     source->sourceBuffer = sourceBufferPrivate.get();
-
-    GUniquePtr<gchar> padName(g_strdup_printf("src_%u", numberOfSources));
     priv->sources = g_list_prepend(priv->sources, source);
     GST_OBJECT_UNLOCK(m_src.get());
 
-    priv->haveAppsrc = source->src;
-
-    gst_bin_add(GST_BIN(m_src.get()), source->src);
-    GRefPtr<GstPad> pad = adoptGRef(gst_element_get_static_pad(source->src, "src"));
-    GstPad* ghostPad = gst_ghost_pad_new_from_template(padName.get(), pad.get(), gst_static_pad_template_get(&srcTemplate));
-    gst_pad_set_query_function(ghostPad, webKitMediaSrcQueryWithParent);
-    gst_pad_set_active(ghostPad, TRUE);
-    gst_element_add_pad(GST_ELEMENT(m_src.get()), ghostPad);
+    gst_bin_add_many(GST_BIN(m_src.get()), source->src, source->typefind, nullptr);
+    gst_element_link_pads(source->src, "src", source->typefind, "sink");
 
     gst_element_sync_state_with_parent(source->src);
+    gst_element_sync_state_with_parent(source->typefind);
 
     return MediaSourcePrivate::Ok;
 }
@@ -367,40 +918,28 @@ void MediaSourceClientGStreamer::durationChanged(const MediaTime& duration)
     gst_element_post_message(GST_ELEMENT(m_src.get()), gst_message_new_duration_changed(GST_OBJECT(m_src.get())));
 }
 
-SourceBufferPrivateClient::AppendResult MediaSourceClientGStreamer::append(PassRefPtr<SourceBufferPrivate> sourceBufferPrivate, const unsigned char* data, unsigned length)
+bool MediaSourceClientGStreamer::append(PassRefPtr<SourceBufferPrivateGStreamer> sourceBufferPrivate, const unsigned char* data, unsigned length)
 {
     WebKitMediaSrcPrivate* priv = m_src->priv;
     GstFlowReturn ret = GST_FLOW_OK;
     GstBuffer* buffer;
     Source* source = 0;
+    GList *l;
 
-    if (!priv->noMorePads) {
-        priv->noMorePads = true;
-        gst_element_no_more_pads(GST_ELEMENT(m_src.get()));
-        webKitMediaSrcDoAsyncDone(m_src.get());
-    }
-
-    for (GList* iter = priv->sources; iter; iter = iter->next) {
-        Source* tmp = static_cast<Source*>(iter->data);
+    for (l = priv->sources; l; l = l->next) {
+        Source *tmp = static_cast<Source*>(l->data);
         if (tmp->sourceBuffer == sourceBufferPrivate.get()) {
             source = tmp;
             break;
         }
     }
-
     if (!source || !source->src)
-        return SourceBufferPrivateClient::ReadStreamFailed;
-
+        return false;
     buffer = gst_buffer_new_and_alloc(length);
     gst_buffer_fill(buffer, 0, data, length);
-
     ret = gst_app_src_push_buffer(GST_APP_SRC(source->src), buffer);
-    GST_DEBUG_OBJECT(m_src.get(), "push buffer %d\n", static_cast<int>(ret));
-
-    if (ret == GST_FLOW_OK)
-        return SourceBufferPrivateClient::AppendSucceeded;
 
-    return SourceBufferPrivateClient::ReadStreamFailed;
+    return (ret == GST_FLOW_OK);
 }
 
 void MediaSourceClientGStreamer::markEndOfStream(MediaSourcePrivate::EndOfStreamStatus)
@@ -422,22 +961,34 @@ void MediaSourceClientGStreamer::markEndOfStream(MediaSourcePrivate::EndOfStream
     }
 }
 
-void MediaSourceClientGStreamer::removedFromMediaSource(PassRefPtr<SourceBufferPrivate> sourceBufferPrivate)
+void MediaSourceClientGStreamer::removedFromMediaSource(PassRefPtr<SourceBufferPrivateGStreamer> sourceBufferPrivate)
 {
     WebKitMediaSrcPrivate* priv = m_src->priv;
     Source* source = 0;
+    GList *l;
 
-    for (GList* iter = priv->sources; iter; iter = iter->next) {
-        Source* tmp = static_cast<Source*>(iter->data);
+    for (l = priv->sources; l; l = l->next) {
+        Source *tmp = static_cast<Source*>(l->data);
         if (tmp->sourceBuffer == sourceBufferPrivate.get()) {
             source = tmp;
             break;
         }
     }
 
-    ASSERT(source && source->src);
+    if (!source || !source->src)
+        return;
+    if (source->src)
+        gst_app_src_end_of_stream(GST_APP_SRC(source->src));
+}
+
+void MediaSourceClientGStreamer::didReceiveInitializationSegment(SourceBufferPrivateGStreamer* sourceBuffer, const SourceBufferPrivateClient::InitializationSegment& initializationSegment)
+{
+    sourceBuffer->didReceiveInitializationSegment(initializationSegment);
+}
 
-    gst_app_src_end_of_stream(GST_APP_SRC(source->src));
+void MediaSourceClientGStreamer::didReceiveSample(SourceBufferPrivateGStreamer* sourceBuffer, PassRefPtr<MediaSample> sample)
+{
+    sourceBuffer->didReceiveSample(sample);
 }
 
 };
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.h
index 234a08c..4e37f01 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.h
@@ -66,22 +66,29 @@ template<> void derefGPtr<WebKitMediaSrc>(WebKitMediaSrc* ptr);
 namespace WebCore {
 
 class ContentType;
+class SourceBufferPrivateGStreamer;
+class MediaSourceGStreamer;
 
 class MediaSourceClientGStreamer: public RefCounted<MediaSourceClientGStreamer> {
     public:
-        MediaSourceClientGStreamer(WebKitMediaSrc*);
+        static PassRefPtr<MediaSourceClientGStreamer> create(WebKitMediaSrc*);
         virtual ~MediaSourceClientGStreamer();
 
         // From MediaSourceGStreamer
-        MediaSourcePrivate::AddStatus addSourceBuffer(PassRefPtr<SourceBufferPrivate>, const ContentType&);
+        MediaSourcePrivate::AddStatus addSourceBuffer(PassRefPtr<SourceBufferPrivateGStreamer>, const ContentType&);
         void durationChanged(const MediaTime&);
         void markEndOfStream(MediaSourcePrivate::EndOfStreamStatus);
 
         // From SourceBufferPrivateGStreamer
-        SourceBufferPrivateClient::AppendResult append(PassRefPtr<SourceBufferPrivate>, const unsigned char*, unsigned);
-        void removedFromMediaSource(PassRefPtr<SourceBufferPrivate>);
+        bool append(PassRefPtr<SourceBufferPrivateGStreamer>, const unsigned char*, unsigned);
+        void removedFromMediaSource(PassRefPtr<SourceBufferPrivateGStreamer>);
+
+        // From our WebKitMediaSrc
+        void didReceiveInitializationSegment(SourceBufferPrivateGStreamer*, const SourceBufferPrivateClient::InitializationSegment&);
+        void didReceiveSample(SourceBufferPrivateGStreamer* sourceBuffer, PassRefPtr<MediaSample> sample);
 
     private:
+        MediaSourceClientGStreamer(WebKitMediaSrc*);
         GRefPtr<WebKitMediaSrc> m_src;
 };
 

From 1cef1d39eb1be20dc22f0f83dc15442a62f96a6e Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Wed, 14 Jan 2015 13:30:54 +0100
Subject: [PATCH 6/8] [GStreamer][MSE] Ensure preloading is disabled

---
 .../platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp      | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 7d8ec6a..759025d 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -2005,6 +2005,11 @@ void MediaPlayerPrivateGStreamer::setDownloadBuffering()
     if (!m_playBin)
         return;
 
+#if ENABLE(MEDIA_SOURCE)
+    if (isMediaSource())
+        return;
+#endif
+
     unsigned flags;
     g_object_get(m_playBin.get(), "flags", &flags, NULL);
 

From c8ba49851bcfb5da6847618cbe4e92d19b492840 Mon Sep 17 00:00:00 2001
From: Philippe Normand <pnormand@igalia.com>
Date: Thu, 22 Jan 2015 11:21:46 +0100
Subject: [PATCH 7/8] Fix build without MSE enabled

---
 .../WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 37ac6b2..1c44a53 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -1992,9 +1992,11 @@ MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::extendedSupportsType(cons
 
 MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::supportsType(const MediaEngineSupportParameters& parameters)
 {
+#if ENABLE(MEDIA_SOURCE)
     // Disable VPX on MSE for now, mp4/avc1 seems way more reliable currently.
     if (parameters.isMediaSource && (parameters.type == "video/webm"))
         return MediaPlayer::IsNotSupported;
+#endif
 
     if (parameters.type.isNull() || parameters.type.isEmpty())
         return MediaPlayer::IsNotSupported;

From 5335daf81d0779ea19bd106d1bf17c14f50bbb52 Mon Sep 17 00:00:00 2001
From: Albert Dahan <a.dahan@metrological.com>
Date: Fri, 6 Feb 2015 21:14:05 +0100
Subject: [PATCH 8/8] mse: prepare compile fix for upstream merge

---
 .../platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp        | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
index 683fd35..7d9200b 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitMediaSourceGStreamer.cpp
@@ -98,7 +98,7 @@ class GStreamerMediaDescription : public MediaDescription {
 class GStreamerMediaSample : public MediaSample
 {
 private:
-    MediaTime m_pts, m_dts, m_duration;
+    MediaTime m_pts, m_dts, m_duration, m_offset;
     AtomicString m_trackID;
     size_t m_size;
     FloatSize m_presentationSize;
@@ -108,6 +108,7 @@ class GStreamerMediaSample : public MediaSample
         , m_pts(MediaTime::zeroTime())
         , m_dts(MediaTime::zeroTime())
         , m_duration(MediaTime::zeroTime())
+        , m_offset(MediaTime::zeroTime())
         , m_trackID(trackID)
         , m_presentationSize(presentationSize)
         , m_flags(MediaSample::IsSync)
@@ -140,6 +141,7 @@ class GStreamerMediaSample : public MediaSample
     size_t sizeInBytes() const { return m_size; }
     FloatSize presentationSize() const { return m_presentationSize; }
     SampleFlags flags() const { return m_flags; }
+    void offsetTimestampsBy(const MediaTime& offset) { m_offset = offset; }
     PlatformSample platformSample() { return PlatformSample(); }
     void dump(PrintStream&) const {}
 };
