From a93cd25cd4b0b5997342cdc79c176a3d924a6073 Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Wed, 10 Jun 2015 13:12:58 +0200
Subject: [PATCH] [GStreamer][wip] PlayReady support

Requires EME_V2 enabled.
---
 Source/WebCore/PlatformWPE.cmake                   |   7 +
 .../graphics/gstreamer/CDMPRSessionGStreamer.cpp   | 272 +++++++++++++++
 .../graphics/gstreamer/CDMPRSessionGStreamer.h     |  69 ++++
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp      |  90 ++++-
 .../gstreamer/MediaPlayerPrivateGStreamer.h        |  12 +
 .../WebKitCommonEncryptionDecryptorGStreamer.cpp   |  39 ++-
 .../WebKitPlayReadyDecryptorGStreamer.cpp          | 380 +++++++++++++++++++++
 .../gstreamer/WebKitPlayReadyDecryptorGStreamer.h  |  45 +++
 .../gstreamer/WebKitWebSourceGStreamer.cpp         |   4 +-
 9 files changed, 901 insertions(+), 17 deletions(-)
 create mode 100644 Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
 create mode 100644 Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h
 create mode 100644 Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
 create mode 100644 Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h

diff --git a/Source/WebCore/PlatformWPE.cmake b/Source/WebCore/PlatformWPE.cmake
index f772a92..39a93cf 100644
--- a/Source/WebCore/PlatformWPE.cmake
+++ b/Source/WebCore/PlatformWPE.cmake
@@ -335,4 +335,11 @@ if (ENABLE_ENCRYPTED_MEDIA OR ENABLE_ENCRYPTED_MEDIA_V2)
         platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
         platform/graphics/gstreamer/WebKitMediaAesCtr.c
     )
+
+    if (ENABLE_ENCRYPTED_MEDIA_V2 AND ENABLE_DXDRM)
+        list(APPEND WebCore_SOURCES
+            platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
+            platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
+        )
+    endif ()
 endif ()
diff --git a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
new file mode 100644
index 0000000..c7ce9b1
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2014-2015 FLUENDO S.A. All rights reserved.
+ * Copyright (C) 2014-2015 METROLOGICAL All rights reserved.
+ * Copyright (C) 2015 IGALIA S.L All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY FLUENDO S.A. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FLUENDO S.A. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CDMPRSessionGStreamer.h"
+
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(GSTREAMER) && USE(DXDRM)
+
+#include "CDM.h"
+#include "MediaKeyError.h"
+#include "MediaPlayerPrivateGStreamer.h"
+#include "UUID.h"
+#include <dxdrm/DxDrmDebugApi.h>
+
+#include <gst/base/gstbytereader.h>
+
+#include <wtf/text/CString.h>
+#include <wtf/text/StringBuilder.h>
+
+GST_DEBUG_CATEGORY_EXTERN(webkit_media_playready_decrypt_debug_category);
+#define GST_CAT_DEFAULT webkit_media_playready_decrypt_debug_category
+
+#define MAX_CHALLENGE_LEN 100000
+
+namespace WebCore {
+
+static void printError(EDxDrmStatus status)
+{
+    g_printerr("DxDRM Error:\n");
+    switch (status) {
+    case DX_ERROR_CONTENT_NOT_RECOGNIZED:
+        g_printerr("The specified file is not protected by one of the supported DRM schemes.\n");
+        break;
+    case DX_ERROR_NOT_INITIALIZED:
+        g_printerr("The DRM Client has not been initialized.\n");
+        break;
+    case DX_ERROR_BAD_ARGUMENTS:
+        g_printerr("Bad arguments.\n");
+        break;
+    default:
+        g_printerr("unknown error: %d\n", status);
+        break;
+    }
+}
+
+CDMPRSessionGStreamer::CDMPRSessionGStreamer(MediaPlayerPrivateGStreamer* parent)
+    : m_player(parent)
+    , m_client(nullptr)
+    , m_sessionId(createCanonicalUUIDString())
+    , m_DxDrmStream(nullptr)
+{
+    DxStatus loaded = DxLoadConfigFile("/etc/dxdrm/dxdrm.config");
+    if (loaded != DX_SUCCESS)
+        GST_WARNING("DX: ERROR - Discretix configuration file not found");
+
+    EDxDrmStatus status = DxDrmClient_Init();
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed to initialize the DxDrmClient (error: %d)", status);
+        printError(status);
+//        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+//        return nullptr;
+    }
+
+    // Set Secure Clock
+/*    status = DxDrmStream_AdjustClock(m_DxDrmStream, DX_AUTO_NO_UI);
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed setting secure clock (%d)", status);
+        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+        systemCode = status;
+        return nullptr;
+    }
+*/
+}
+
+CDMPRSessionGStreamer::~CDMPRSessionGStreamer()
+{
+    if (m_DxDrmStream) {
+        DxDrmStream_Close(&m_DxDrmStream);
+        m_DxDrmStream = nullptr;
+    }
+
+    DxDrmClient_Terminate();
+}
+
+static const guint8* extractWrmHeader(Uint8Array* initData, guint16* recordLength)
+{
+    GstByteReader reader;
+    guint32 length;
+    guint16 recordCount;
+    const guint8* data;
+
+    gst_byte_reader_init(&reader, initData->data(), initData->byteLength());
+
+    gst_byte_reader_get_uint32_le(&reader, &length);
+    gst_byte_reader_get_uint16_le(&reader, &recordCount);
+
+    for (int i = 0; i < recordCount; i++) {
+        guint16 type;
+        gst_byte_reader_get_uint16_le(&reader, &type);
+        gst_byte_reader_get_uint16_le(&reader, recordLength);
+
+        gst_byte_reader_get_data(&reader, *recordLength, &data);
+        // 0x1 => rights management header
+        if (type == 0x1)
+            return data;
+    }
+
+    return nullptr;
+}
+
+PassRefPtr<Uint8Array> CDMPRSessionGStreamer::generateKeyRequest(const String& mimeType, Uint8Array* initData, String& destinationURL, unsigned short& errorCode, unsigned long& systemCode)
+{
+    UNUSED_PARAM(mimeType);
+    UNUSED_PARAM(errorCode);
+    UNUSED_PARAM(systemCode);
+
+    // Instantiate Discretix DRM client from the parsed WRMHEADER.
+    guint16 recordLength;
+    const guint8* data = extractWrmHeader(initData, &recordLength);
+    EDxDrmStatus status = DxDrmClient_OpenDrmStreamFromData(&m_DxDrmStream, data, recordLength);
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed creating DxDrmClient from initData (error: %d)", status);
+        printError(status);
+        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+        return nullptr;
+    }
+
+    guint32 challengeLength = MAX_CHALLENGE_LEN;
+    gpointer challenge = g_malloc0(challengeLength);
+
+    // Get challenge
+    status = DxDrmStream_GetLicenseChallenge(m_DxDrmStream, challenge, (unsigned int *) &challengeLength);
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed to generate challenge request (%d)", status);
+        g_free(challenge);
+        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+        systemCode = status;
+        return nullptr;
+    }
+
+    // Get License URL
+    destinationURL = (const char *) DxDrmStream_GetTextAttribute(m_DxDrmStream, DX_ATTR_SILENT_URL, DX_ACTIVE_CONTENT);
+
+    GST_DEBUG("destination URL : %s", destinationURL.utf8().data());
+    GST_MEMDUMP("generated license request :", (const guint8 *) challenge, challengeLength);
+
+    RefPtr<Uint8Array> result = Uint8Array::create(reinterpret_cast<const unsigned char *>(challenge), challengeLength);
+
+    //g_free(challenge);
+
+    // This is the first stage of license aquisition.
+    m_waitAck = false;
+
+    return result;
+}
+
+void CDMPRSessionGStreamer::releaseKeys()
+{
+    m_player->signalDRM();
+}
+
+bool CDMPRSessionGStreamer::update(Uint8Array* key, RefPtr<Uint8Array>& nextMessage, unsigned short& errorCode, unsigned long& systemCode)
+{
+    GST_MEMDUMP("response received :", key->data(), key->byteLength());
+
+    bool ret = false;
+    bool isAckRequired = false;
+    HDxResponseResult responseResult = nullptr;
+    EDxDrmStatus status;
+
+    m_key = key;
+
+    if (!m_waitAck) {
+        // Server replied to our license request
+        status = DxDrmStream_ProcessLicenseResponse(m_DxDrmStream, key->data(), key->byteLength(), &responseResult, &isAckRequired);
+    } else {
+        // Server replied to our license response acknowledge
+        status = DxDrmClient_ProcessServerResponse(key->data(), key->byteLength(), DX_RESPONSE_LICENSE_ACK, &responseResult, &isAckRequired);
+        if (isAckRequired)
+            GST_WARNING("ack required when processing ack of ack !");
+    }
+
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed processing license response (%d)", status);
+        goto error;
+    }
+
+    if (!m_waitAck && isAckRequired) {
+        guint32 challengeLength = MAX_CHALLENGE_LEN;
+        gpointer challenge = g_malloc0(challengeLength);
+
+        status = DxDrmClient_GetLicenseAcq_GenerateAck(&responseResult, challenge, (unsigned int *) &challengeLength);
+        if (status != DX_SUCCESS) {
+            GST_WARNING("failed generating license ack challenge (%d) response result %p", status, responseResult);
+            g_free(challenge);
+            goto error;
+        }
+
+        GST_MEMDUMP("generated license ack request :", (const guint8 *) challenge, challengeLength);
+
+        nextMessage = Uint8Array::create(reinterpret_cast<const unsigned char *>(challenge), challengeLength);
+
+        //g_free(challenge);
+        m_waitAck = true;
+    } else {
+        // Notify the player instance that a key was added
+        m_player->signalDRM();
+        ret = true;
+    }
+
+    return ret;
+
+error:
+    errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+    systemCode = status;
+    // Notify Player that license acquisition failed
+    m_player->signalDRM();
+    return ret;
+}
+
+bool CDMPRSessionGStreamer::prepareForPlayback()
+{
+    EDxDrmStatus result;
+
+    result = DxDrmStream_SetIntent(m_DxDrmStream, DX_INTENT_AUTO_PLAY, DX_AUTO_NO_UI);
+    if (result != DX_SUCCESS) {
+        GST_WARNING("DX: ERROR - opening stream failed because there are no rights (license) to play the content");
+        DxDrmStream_Close(&(m_DxDrmStream));
+        return false;
+    }
+
+    GST_INFO("DX: playback rights found");
+
+    /*starting consumption of the file - notifying the drm that the file is being used*/
+    result = DxDrmFile_HandleConsumptionEvent(m_DxDrmStream, DX_EVENT_START);
+    if (result != DX_SUCCESS) {
+        GST_WARNING("DX: Content consumption failed");
+        DxDrmStream_Close(&(m_DxDrmStream));
+        return false;
+    }
+
+    GST_INFO("DX: Stream was opened and is ready for playback");
+    return true;
+}
+
+}
+
+#endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h
new file mode 100644
index 0000000..d42b80e
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014-2015 FLUENDO S.A. All rights reserved.
+ * Copyright (C) 2014-2015 METROLOGICAL All rights reserved.
+ * Copyright (C) 2015 IGALIA S.L All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY FLUENDO S.A. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FLUENDO S.A. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CDMPRSessionGStreamer_h
+#define CDMPRSessionGStreamer_h
+
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(GSTREAMER) && USE(DXDRM)
+
+#include "CDMSession.h"
+#include <wtf/RetainPtr.h>
+
+#include <dxdrm/DxDrmClient.h>
+
+namespace WebCore {
+
+class MediaPlayerPrivateGStreamer;
+
+class CDMPRSessionGStreamer : public CDMSession {
+public:
+    CDMPRSessionGStreamer(MediaPlayerPrivateGStreamer* parent);
+    virtual ~CDMPRSessionGStreamer() override;
+
+    virtual void setClient(CDMSessionClient* client) override { m_client = client; }
+    virtual const String& sessionId() const override { return m_sessionId; }
+    virtual PassRefPtr<Uint8Array> generateKeyRequest(const String& mimeType, Uint8Array* initData, String& destinationURL, unsigned short& errorCode, unsigned long& systemCode) override;
+    virtual void releaseKeys() override;
+    virtual bool update(Uint8Array*, RefPtr<Uint8Array>& nextMessage, unsigned short& errorCode, unsigned long& systemCode) override;
+
+    bool prepareForPlayback();
+    void* drmStream() const { return reinterpret_cast<void*>(m_DxDrmStream); }
+
+private:
+    MediaPlayerPrivateGStreamer* m_player;
+    CDMSessionClient* m_client;
+    String m_sessionId;
+    bool m_waitAck;
+    HDxDrmStream m_DxDrmStream;
+    Uint8Array* m_key;
+};
+
+}
+
+#endif
+
+#endif // CDMPRSessionGStreamer_h
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index b13064b..3ed46f0 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -74,6 +74,11 @@
 #include "AudioSourceProviderGStreamer.h"
 #endif
 
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(DXDRM)
+#include "CDMPRSessionGStreamer.h"
+#include "WebKitPlayReadyDecryptorGStreamer.h"
+#endif
+
 #if USE(GSTREAMER_GL)
 #include "GLContext.h"
 
@@ -212,8 +217,13 @@ void MediaPlayerPrivateGStreamer::setAudioStreamProperties(GObject* object)
 void MediaPlayerPrivateGStreamer::registerMediaEngine(MediaEngineRegistrar registrar)
 {
     if (isAvailable())
+#if ENABLE(ENCRYPTED_MEDIA_V2)
         registrar([](MediaPlayer* player) { return std::make_unique<MediaPlayerPrivateGStreamer>(player); },
+            getSupportedTypes, extendedSupportsType, 0, 0, 0, supportsKeySystem);
+#else
+         registrar([](MediaPlayer* player) { return std::make_unique<MediaPlayerPrivateGStreamer>(player); },
             getSupportedTypes, supportsType, 0, 0, 0, supportsKeySystem);
+#endif
 }
 
 bool initializeGStreamerAndRegisterWebKitElements()
@@ -233,6 +243,12 @@ bool initializeGStreamerAndRegisterWebKitElements()
         gst_element_register(0, "webkitcencdec", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_MEDIA_CENC_DECRYPT);
 #endif
 
+#if USE(DXDRM)
+    GRefPtr<GstElementFactory> playReadyDecryptorFactory = gst_element_factory_find("webkitplayreadydec");
+    if (!playReadyDecryptorFactory)
+        gst_element_register(0, "webkitplayreadydec", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT);
+#endif
+
 #if ENABLE(MEDIA_SOURCE)
     GRefPtr<GstElementFactory> WebKitMediaSrcFactory = gst_element_factory_find("webkitmediasrc");
     if (!WebKitMediaSrcFactory)
@@ -704,9 +720,9 @@ bool MediaPlayerPrivateGStreamer::doSeek(gint64 position, float rate, GstSeekFla
     if (!rate)
         rate = 1.0;
 
+#if ENABLE(MEDIA_SOURCE)
     MediaTime time(MediaTime::createWithDouble(double(static_cast<double>(position) / GST_SECOND)));
 
-#if ENABLE(MEDIA_SOURCE)
     if (isMediaSource())
         webkit_media_src_set_seek_time(WEBKIT_MEDIA_SRC(m_source.get()), time);
 #endif
@@ -2314,8 +2330,80 @@ void MediaPlayerPrivateGStreamer::needKey(const String& keySystem, const String&
         m_drmKeySemaphore.signal();
     }
 }
+
+void MediaPlayerPrivateGStreamer::signalDRM()
+{
+    GST_DEBUG("key/license was changed or failed, signal semaphore");
+    // Wake up a potential waiter blocked in the GStreamer thread
+    m_drmKeySemaphore.signal();
+}
 #endif
 
+
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::extendedSupportsType(const MediaEngineSupportParameters& parameters)
+{
+    // From: <http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html#dom-canplaytype>
+    // In addition to the steps in the current specification, this method must run the following steps:
+
+    // 1. Check whether the Key System is supported with the specified container and codec type(s) by following the steps for the first matching condition from the following list:
+    //    If keySystem is null, continue to the next step.
+    if (parameters.keySystem.isNull() || parameters.keySystem.isEmpty())
+        return supportsType(parameters);
+
+    // If keySystem contains an unrecognized or unsupported Key System, return the empty string
+    if (!supportsKeySystem(parameters.keySystem, emptyString()))
+        return MediaPlayer::IsNotSupported;
+
+    // If the Key System specified by keySystem does not support decrypting the container and/or codec specified in the rest of the type string.
+    // (AVFoundation does not provide an API which would allow us to determine this, so this is a no-op)
+
+    // 2. Return "maybe" or "probably" as appropriate per the existing specification of canPlayType().
+    return supportsType(parameters);
+}
+
+void MediaPlayerPrivateGStreamer::needKey(RefPtr<Uint8Array> initData)
+{
+    if (!m_player->keyNeeded(initData.get())) {
+        GST_DEBUG("no event handler for key needed, waking up GStreamer thread");
+        m_drmKeySemaphore.signal();
+    }
+}
+
+std::unique_ptr<CDMSession> MediaPlayerPrivateGStreamer::createSession(const String& keySystem)
+{
+    if (!supportsKeySystem(keySystem, emptyString()))
+        return nullptr;
+
+#if USE(DXDRM)
+    if (equalIgnoringCase(keySystem, "com.microsoft.playready")
+        || equalIgnoringCase(keySystem, "com.youtube.playready"))
+        return std::make_unique<CDMPRSessionGStreamer>(this);
+#endif
+
+    return nullptr;
+}
+
+void MediaPlayerPrivateGStreamer::setCDMSession(CDMSession* session)
+{
+    m_cdmSession = session;
+}
+
+void MediaPlayerPrivateGStreamer::keyAdded()
+{
+#if USE(DXDRM)
+    if (!m_cdmSession)
+        return;
+
+    CDMPRSessionGStreamer* cdm = reinterpret_cast<CDMPRSessionGStreamer*>(m_cdmSession);
+    if (cdm && cdm->prepareForPlayback())
+        gst_element_send_event(m_pipeline.get(), gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM_OOB,
+            gst_structure_new("drm-cipher", "stream", G_TYPE_POINTER, cdm->drmStream(), nullptr)));
+#endif
+}
+#endif
+
+
 MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::supportsType(const MediaEngineSupportParameters& parameters)
 {
 #if ENABLE(MEDIA_SOURCE)
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index c653c08..36b454c 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -163,6 +163,12 @@ public:
     void notifyAppendComplete();
 #endif
 
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+    void needKey(RefPtr<Uint8Array> initData);
+    void setCDMSession(CDMSession*);
+    void keyAdded();
+#endif
+
 private:
     static void getSupportedTypes(HashSet<String>&);
     static MediaPlayer::SupportsType supportsType(const MediaEngineSupportParameters&);
@@ -172,6 +178,12 @@ private:
 
     GstElement* createAudioSink() override;
 
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+    static MediaPlayer::SupportsType extendedSupportsType(const MediaEngineSupportParameters&);
+    std::unique_ptr<CDMSession> createSession(const String&);
+    CDMSession* m_cdmSession;
+#endif
+
     float playbackPosition() const;
 
     void cacheDuration();
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
index 0cba28b..6a206a1 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
@@ -51,7 +51,7 @@ static GstStaticPadTemplate sinkTemplate = GST_STATIC_PAD_TEMPLATE("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS("application/x-cenc, original-media-type=(string)video/x-h264, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID "; "
-    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID));
+    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID "; "));
 
 static GstStaticPadTemplate srcTemplate = GST_STATIC_PAD_TEMPLATE("src",
     GST_PAD_SRC,
@@ -94,6 +94,28 @@ static void webkit_media_common_encryption_decrypt_init(WebKitMediaCommonEncrypt
 }
 
 /*
+  Append new_structure to dest, but only if it does not already exist in res.
+  This function takes ownership of new_structure.
+*/
+static bool webkitMediaCommonEncryptionDecryptCapsAppendIfNotDuplicate(GstCaps* destination, GstStructure* structure)
+{
+    bool duplicate = false;
+    unsigned size = gst_caps_get_size(destination);
+    for (unsigned index = 0; !duplicate && index < size; ++index) {
+        GstStructure* s = gst_caps_get_structure(destination, index);
+        if (gst_structure_is_equal(s, structure))
+            duplicate = true;
+    }
+
+    if (!duplicate)
+        gst_caps_append_structure(destination, structure);
+    else
+        gst_structure_free(structure);
+
+    return duplicate;
+}
+
+/*
   Given the pad in this direction and the given caps, what caps are allowed on
   the other pad in this element ?
 */
@@ -153,22 +175,11 @@ static GstCaps* webkitMediaCommonEncryptionDecryptTransformCaps(GstBaseTransform
                 "original-media-type", G_TYPE_STRING, gst_structure_get_name(in), nullptr);
 
             gst_structure_set_name(out, "application/x-cenc");
-            gst_structure_free(tmp);
-        }
-
-        bool duplicate = false;
-        unsigned size = gst_caps_get_size(transformedCaps);
 
-        for (unsigned index = 0; !duplicate && index < size; ++index) {
-            GstStructure* s = gst_caps_get_structure(transformedCaps, index);
-            if (gst_structure_is_equal(s, out))
-                duplicate = true;
+            gst_structure_free(tmp);
         }
 
-        if (!duplicate)
-            gst_caps_append_structure(transformedCaps, out);
-        else
-            gst_structure_free(out);
+        webkitMediaCommonEncryptionDecryptCapsAppendIfNotDuplicate(transformedCaps, out);
     }
 
     if (filter) {
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
new file mode 100644
index 0000000..55019e3
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
@@ -0,0 +1,380 @@
+/* GStreamer ClearKey common encryption decryptor
+ *
+ * Copyright (C) 2015 Igalia S.L
+ * Copyright (C) 2015 Metrological
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+
+#include "config.h"
+
+#if (ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)) && USE(GSTREAMER) && USE(DXDRM)
+#include "WebKitPlayReadyDecryptorGStreamer.h"
+
+#include <gst/base/gstbasetransform.h>
+#include <gst/base/gstbytereader.h>
+#include <dxdrm/DxDrmClient.h>
+#include <dxdrm/DxDrmDebugApi.h>
+
+struct _WebKitMediaPlayReadyDecrypt {
+    GstBaseTransform parent;
+    HDxDrmStream drmStream;
+    gboolean streamReceived;
+
+    GMutex mutex;
+    GCond condition;
+};
+
+struct _WebKitMediaPlayReadyDecryptClass {
+    GstBaseTransformClass parentClass;
+};
+
+static bool keyRequested = false;
+
+
+static GstCaps* webkitMediaPlayReadyDecryptTransformCaps(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps* filter);
+static GstFlowReturn webkitMediaPlayReadyDecryptTransformInPlace(GstBaseTransform*, GstBuffer*);
+static gboolean webkitMediaPlayReadyDecryptSinkEventHandler(GstBaseTransform*, GstEvent*);
+
+GST_DEBUG_CATEGORY(webkit_media_playready_decrypt_debug_category);
+#define GST_CAT_DEFAULT webkit_media_playready_decrypt_debug_category
+
+#define PLAYREADY_PROTECTION_SYSTEM_ID "9a04f079-9840-4286-ab92-e65be0885f95"
+
+static GstStaticPadTemplate sinkTemplate = GST_STATIC_PAD_TEMPLATE("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS("application/x-cenc, original-media-type=(string)video/x-h264, protection-system=(string)" PLAYREADY_PROTECTION_SYSTEM_ID "; "
+    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" PLAYREADY_PROTECTION_SYSTEM_ID
+        ));
+
+static GstStaticPadTemplate srcTemplate = GST_STATIC_PAD_TEMPLATE("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS("video/x-h264; audio/mpeg"));
+
+#define webkit_media_playready_decrypt_parent_class parent_class
+G_DEFINE_TYPE(WebKitMediaPlayReadyDecrypt, webkit_media_playready_decrypt, GST_TYPE_BASE_TRANSFORM);
+
+static void webkit_media_playready_decrypt_dispose(GObject*);
+
+static void webkit_media_playready_decrypt_class_init(WebKitMediaPlayReadyDecryptClass* klass) {
+    GObjectClass *gobjectClass = G_OBJECT_CLASS(klass);
+    GstBaseTransformClass* baseTransformClass = GST_BASE_TRANSFORM_CLASS(klass);
+    GstElementClass* elementClass = GST_ELEMENT_CLASS(klass);
+
+    gobjectClass->dispose = webkit_media_playready_decrypt_dispose;
+    gst_element_class_add_pad_template(elementClass, gst_static_pad_template_get(&sinkTemplate));
+    gst_element_class_add_pad_template(elementClass, gst_static_pad_template_get(&srcTemplate));
+
+    gst_element_class_set_static_metadata(elementClass,
+        "Decrypt content encrypted using PlayReady Encryption",
+        GST_ELEMENT_FACTORY_KLASS_DECRYPTOR,
+        "Decrypts media that has been encrypted using PlayReady Encryption.",
+        "Philippe Normand <philn@igalia.com>");
+
+    GST_DEBUG_CATEGORY_INIT(webkit_media_playready_decrypt_debug_category,
+        "webkitplayready", 0, "PlayReady decryptor");
+
+    baseTransformClass->transform_ip = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptTransformInPlace);
+    baseTransformClass->transform_caps = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptTransformCaps);
+    baseTransformClass->sink_event = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptSinkEventHandler);
+    baseTransformClass->transform_ip_on_passthrough = FALSE;
+}
+
+static void webkit_media_playready_decrypt_init(WebKitMediaPlayReadyDecrypt* self)
+{
+    GstBaseTransform* base = GST_BASE_TRANSFORM(self);
+
+    gst_base_transform_set_in_place(base, TRUE);
+    gst_base_transform_set_passthrough(base, FALSE);
+    gst_base_transform_set_gap_aware(base, FALSE);
+
+    g_mutex_init(&self->mutex);
+    g_cond_init(&self->condition);
+}
+
+static void webkit_media_playready_decrypt_dispose(GObject* object)
+{
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(object);
+
+    g_mutex_clear(&self->mutex);
+    g_cond_clear(&self->condition);
+
+    G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+/*
+  Append new_structure to dest, but only if it does not already exist in res.
+  This function takes ownership of new_structure.
+*/
+static bool webkitMediaPlayReadyDecryptCapsAppendIfNotDuplicate(GstCaps* destination, GstStructure* structure)
+{
+    bool duplicate = false;
+    unsigned size = gst_caps_get_size(destination);
+    for (unsigned index = 0; !duplicate && index < size; ++index) {
+        GstStructure* s = gst_caps_get_structure(destination, index);
+        if (gst_structure_is_equal(s, structure))
+            duplicate = true;
+    }
+
+    if (!duplicate)
+        gst_caps_append_structure(destination, structure);
+    else
+        gst_structure_free(structure);
+
+    return duplicate;
+}
+
+static GstCaps* webkitMediaPlayReadyDecryptTransformCaps(GstBaseTransform* base, GstPadDirection direction, GstCaps* caps, GstCaps* filter)
+{
+    g_return_val_if_fail(direction != GST_PAD_UNKNOWN, nullptr);
+    GstCaps* transformedCaps = gst_caps_new_empty();
+
+    GST_DEBUG_OBJECT(base, "direction: %s, caps: %" GST_PTR_FORMAT " filter:"
+        " %" GST_PTR_FORMAT, (direction == GST_PAD_SRC) ? "src" : "sink", caps, filter);
+
+    unsigned size = gst_caps_get_size(caps);
+    for (unsigned i = 0; i < size; ++i) {
+        GstStructure* in = gst_caps_get_structure(caps, i);
+        GstStructure* out = nullptr;
+
+        if (direction == GST_PAD_SINK) {
+            if (!gst_structure_has_field(in, "original-media-type"))
+                continue;
+
+            out = gst_structure_copy(in);
+            gst_structure_set_name(out, gst_structure_get_string(out, "original-media-type"));
+
+            /* filter out the DRM related fields from the down-stream caps */
+            for (int j = 0; j < gst_structure_n_fields(in); ++j) {
+                const gchar* fieldName = gst_structure_nth_field_name(in, j);
+
+                if (g_str_has_prefix(fieldName, "protection-system")
+                    || g_str_has_prefix(fieldName, "original-media-type"))
+                    gst_structure_remove_field(out, fieldName);
+            }
+        } else {
+            GstStructure* tmp = gst_structure_copy(in);
+            /* filter out the video related fields from the up-stream caps,
+               because they are not relevant to the input caps of this element and
+               can cause caps negotiation failures with adaptive bitrate streams */
+            for (int index = gst_structure_n_fields(tmp) - 1; index >= 0; --index) {
+                const gchar* fieldName = gst_structure_nth_field_name(tmp, index);
+                GST_TRACE("Check field \"%s\" for removal", fieldName);
+
+                if (!g_strcmp0(fieldName, "base-profile")
+                    || !g_strcmp0(fieldName, "codec_data")
+                    || !g_strcmp0(fieldName, "height")
+                    || !g_strcmp0(fieldName, "framerate")
+                    || !g_strcmp0(fieldName, "level")
+                    || !g_strcmp0(fieldName, "pixel-aspect-ratio")
+                    || !g_strcmp0(fieldName, "profile")
+                    || !g_strcmp0(fieldName, "rate")
+                    || !g_strcmp0(fieldName, "width")) {
+                    gst_structure_remove_field(tmp, fieldName);
+                    GST_TRACE("Removing field %s", fieldName);
+                }
+            }
+
+            out = gst_structure_copy(tmp);
+            gst_structure_set(out, "protection-system", G_TYPE_STRING, PLAYREADY_PROTECTION_SYSTEM_ID,
+                "original-media-type", G_TYPE_STRING, gst_structure_get_name(in), nullptr);
+
+            gst_structure_set_name(out, "application/x-cenc");
+            gst_structure_free(tmp);
+        }
+
+        webkitMediaPlayReadyDecryptCapsAppendIfNotDuplicate(transformedCaps, out);
+    }
+
+    if (filter) {
+        GstCaps* intersection;
+
+        GST_DEBUG_OBJECT(base, "Using filter caps %" GST_PTR_FORMAT, filter);
+        intersection = gst_caps_intersect_full(transformedCaps, filter, GST_CAPS_INTERSECT_FIRST);
+        gst_caps_unref(transformedCaps);
+        transformedCaps = intersection;
+    }
+
+    GST_DEBUG_OBJECT(base, "returning %" GST_PTR_FORMAT, transformedCaps);
+    return transformedCaps;
+}
+
+static GstFlowReturn webkitMediaPlayReadyDecryptTransformInPlace(GstBaseTransform* base, GstBuffer* buffer)
+{
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(base);
+    GstFlowReturn result = GST_FLOW_OK;
+    GstMapInfo map;
+    const GValue* value;
+    guint sampleIndex = 0;
+    int errorCode;
+    unsigned int activeFlags;
+    unsigned trackID = 0;
+    GstPad* pad;
+    GstCaps* caps;
+    GstMapInfo boxMap;
+    GstBuffer* box = nullptr;
+
+    g_mutex_lock(&self->mutex);
+
+    // The key might not have been received yet. Wait for it.
+    if (!self->streamReceived) {
+        g_printerr("stream not received yet. Waiting.\n");
+        g_cond_wait(&self->condition, &self->mutex);
+    }
+
+    GstProtectionMeta* protectionMeta = reinterpret_cast<GstProtectionMeta*>(gst_buffer_get_protection_meta(buffer));
+    if (!protectionMeta || !buffer) {
+        if (!protectionMeta)
+            GST_ERROR_OBJECT(self, "Failed to get GstProtection metadata from buffer %p", buffer);
+
+        if (!buffer)
+            GST_ERROR_OBJECT(self, "Failed to get writable buffer");
+
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    if (!gst_buffer_map(buffer, &map, static_cast<GstMapFlags>(GST_MAP_READWRITE))) {
+        GST_ERROR_OBJECT(self, "Failed to map buffer");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    if ((errorCode = DxDrmStream_GetFlags(self->drmStream,
+                                          DX_FLAG_CAN_PLAY | DX_FLAG_HAS_FUTURE_RIGHTS,
+                                          &activeFlags, DX_ALL_PERMISSIONS, 0)) != DX_DRM_SUCCESS) {
+        GST_WARNING_OBJECT(self, "DX: ERROR - getflags failed [%d]", errorCode);
+        result = GST_FLOW_ERROR;
+        goto beach;
+    }
+
+    pad = gst_element_get_static_pad(GST_ELEMENT(self), "src");
+    caps = gst_pad_get_current_caps(pad);
+    if (g_str_has_prefix(gst_structure_get_name(gst_caps_get_structure(caps, 0)), "video/"))
+        trackID = 1;
+    else
+        trackID = 2;
+    gst_caps_unref(caps);
+    gst_object_unref(pad);
+
+    if (!gst_structure_get_uint(protectionMeta->info, "sample-index", &sampleIndex)) {
+        GST_ERROR_OBJECT(self, "failed to get sample-index");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    value = gst_structure_get_value(protectionMeta->info, "box");
+    if (!value) {
+        GST_ERROR_OBJECT(self, "Failed to get encryption box for sample");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    box = gst_value_get_buffer(value);
+    if (!gst_buffer_map(box, &boxMap, GST_MAP_READ)) {
+        GST_ERROR_OBJECT(self, "Failed to map encryption box");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    GST_TRACE_OBJECT(self, "decrypt sample %u", sampleIndex);
+
+    if ((errorCode = DxDrmStream_ProcessPiffPacket(self->drmStream, (void*) map.data,
+                                                   (unsigned int) map.size,
+                                                   (const void*) boxMap.data,
+                                                   (unsigned int) boxMap.size,
+                                                   (unsigned int) sampleIndex, trackID)) != DX_DRM_SUCCESS) {
+        GST_WARNING_OBJECT(self, "DX: ERROR - packet decryption failed [%d]", errorCode);
+        GST_MEMDUMP_OBJECT(self, "box", boxMap.data, boxMap.size);
+        result = GST_FLOW_ERROR;
+        goto beach;
+    }
+
+beach:
+    if (box)
+        gst_buffer_unmap(box, &boxMap);
+
+    gst_buffer_unmap(buffer, &map);
+
+    if (protectionMeta)
+        gst_buffer_remove_meta(buffer, reinterpret_cast<GstMeta*>(protectionMeta));
+
+    g_mutex_unlock(&self->mutex);
+    return result;
+}
+
+static gboolean webkitMediaPlayReadyDecryptSinkEventHandler(GstBaseTransform* trans, GstEvent* event)
+{
+    gboolean result = FALSE;
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(trans);
+
+    g_mutex_lock(&self->mutex);
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_PROTECTION: {
+        const gchar* systemId;
+        GstBuffer* buffer = nullptr;
+        const gchar* origin;
+
+        GST_INFO_OBJECT(self, "received protection event");
+        gst_event_parse_protection(event, &systemId, &buffer, &origin);
+        GST_INFO_OBJECT(self, "systemId: %s", systemId);
+        if (!g_str_equal(systemId, PLAYREADY_PROTECTION_SYSTEM_ID)
+            || !g_str_has_prefix(origin, "smooth-streaming")) {
+            gst_event_unref(event);
+            result = FALSE;
+            break;
+        }
+
+        if (!keyRequested) {
+            keyRequested = true;
+            gst_element_post_message(GST_ELEMENT(self),
+                gst_message_new_element(GST_OBJECT(self),
+                    gst_structure_new("drm-key-needed", "data", GST_TYPE_BUFFER, buffer,
+                        "key-system-id", G_TYPE_STRING, systemId, nullptr)));
+        }
+
+        gst_event_unref(event);
+        result = TRUE;
+        break;
+    }
+    case GST_EVENT_CUSTOM_DOWNSTREAM_OOB: {
+        GST_INFO_OBJECT(self, "received OOB event");
+        const GstStructure* structure = gst_event_get_structure(event);
+        if (gst_structure_has_name(structure, "drm-cipher")) {
+            GST_INFO_OBJECT(self, "received drm-cipher");
+
+            const GValue* value = gst_structure_get_value(structure, "stream");
+            self->drmStream = (HDxDrmStream) g_value_get_pointer(value);
+            self->streamReceived = TRUE;
+            g_cond_signal(&self->condition);
+        }
+
+        gst_event_unref(event);
+        result = TRUE;
+        break;
+    }
+    default:
+        result = GST_BASE_TRANSFORM_CLASS(parent_class)->sink_event(trans, event);
+        break;
+    }
+
+    g_mutex_unlock(&self->mutex);
+    return result;
+}
+
+#endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h
new file mode 100644
index 0000000..feb7a50
--- /dev/null
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h
@@ -0,0 +1,45 @@
+/* GStreamer ClearKey common encryption decryptor
+ *
+ * Copyright (C) 2015 Igalia S.L
+ * Copyright (C) 2015 Metrological
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef WebKitPlayReadyDecryptorGStreamer_h
+#define WebKitPlayReadyDecryptorGStreamer_h
+
+#if (ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)) && USE(GSTREAMER) && USE(DXDRM)
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT          (webkit_media_playready_decrypt_get_type())
+#define WEBKIT_MEDIA_PLAYREADY_DECRYPT(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT, WebKitMediaPlayReadyDecrypt))
+#define WEBKIT_MEDIA_PLAYREADY_DECRYPT_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT, WebKitMediaPlayReadyDecryptClass))
+#define WEBKIT_IS_MEDIA_PLAYREADY_DECRYPT(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT))
+#define WEBKIT_IS_MEDIA_PLAYREADY_DECRYPT_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT))
+
+typedef struct _WebKitMediaPlayReadyDecrypt      WebKitMediaPlayReadyDecrypt;
+typedef struct _WebKitMediaPlayReadyDecryptClass WebKitMediaPlayReadyDecryptClass;
+
+GType webkit_media_playready_decrypt_get_type(void);
+
+G_END_DECLS
+
+#endif
+#endif
diff --git a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
index 9da20d2..69beb44 100644
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
@@ -1082,8 +1082,8 @@ void StreamingClient::handleDataReceived(const char* data, int length)
     priv->offset += length;
     // priv->size == 0 if received length on didReceiveResponse < 0.
     if (priv->size > 0 && priv->offset > priv->size) {
-        GST_DEBUG_OBJECT(src, "Updating internal size from %" G_GUINT64_FORMAT " to %" G_GUINT64_FORMAT, priv->size, priv->offset);
-        gst_app_src_set_size(priv->appsrc, priv->offset);
+        GST_DEBUG_OBJECT(src, "Updating internal size from %" G_GUINT64_FORMAT " to %" G_GUINT64_FORMAT, priv->size, priv->offset+4096);
+        gst_app_src_set_size(priv->appsrc, priv->offset + 4096);
         priv->size = priv->offset;
     }
     GST_BUFFER_OFFSET_END(priv->buffer.get()) = priv->offset;
-- 
2.1.4

