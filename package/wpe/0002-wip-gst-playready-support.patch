diff -urN a/Source/WebCore/platform/graphics/CDMSession.h b/Source/WebCore/platform/graphics/CDMSession.h
--- a/Source/WebCore/platform/graphics/CDMSession.h	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/platform/graphics/CDMSession.h	2015-07-20 20:24:07.576260534 +0200
@@ -59,6 +59,7 @@
     CDMSessionTypeClearKey,
     CDMSessionTypeAVFoundationObjC,
     CDMSessionTypeMediaSourceAVFObjC,
+    CDMSessionTypeMediaSourcePlayReady
 };
 
 class CDMSession {
diff -urN a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
--- a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp	2015-07-20 20:23:57.928260561 +0200
@@ -0,0 +1,346 @@
+/*
+ * Copyright (C) 2014-2015 FLUENDO S.A. All rights reserved.
+ * Copyright (C) 2014-2015 METROLOGICAL All rights reserved.
+ * Copyright (C) 2015 IGALIA S.L All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY FLUENDO S.A. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FLUENDO S.A. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "config.h"
+#include "CDMPRSessionGStreamer.h"
+
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(GSTREAMER) && USE(DXDRM)
+
+#include "CDM.h"
+#include "MediaKeyError.h"
+#include "MediaPlayerPrivateGStreamer.h"
+#include "UUID.h"
+
+#include <dxdrm/DxDrmClient.h>
+#include <dxdrm/DxDrmDebugApi.h>
+
+#include <gst/base/gstbytereader.h>
+
+#include <wtf/text/CString.h>
+#include <wtf/text/StringBuilder.h>
+
+GST_DEBUG_CATEGORY_EXTERN(webkit_media_playready_decrypt_debug_category);
+#define GST_CAT_DEFAULT webkit_media_playready_decrypt_debug_category
+
+#define MAX_CHALLENGE_LEN 64000
+
+namespace WebCore {
+
+static const guint8* extractWrmHeader(Uint8Array* initData, guint16* recordLength)
+{
+    GstByteReader reader;
+    guint32 length;
+    guint16 recordCount;
+    const guint8* data;
+
+    gst_byte_reader_init(&reader, initData->data(), initData->byteLength());
+
+    gst_byte_reader_get_uint32_le(&reader, &length);
+    gst_byte_reader_get_uint16_le(&reader, &recordCount);
+
+    for (int i = 0; i < recordCount; i++) {
+        guint16 type;
+        gst_byte_reader_get_uint16_le(&reader, &type);
+        gst_byte_reader_get_uint16_le(&reader, recordLength);
+
+        gst_byte_reader_get_data(&reader, *recordLength, &data);
+        // 0x1 => rights management header
+        if (type == 0x1)
+            return data;
+    }
+
+    return nullptr;
+}
+
+class DRMInitialisation
+{
+    private:
+        DRMInitialisation(const DRMInitialisation&);
+        DRMInitialisation& operator= (const DRMInitialisation&);
+
+    public:
+        DRMInitialisation ()
+        {
+            DxStatus status = DxLoadConfigFile("/etc/dxdrm/dxdrm.config");
+            if (status != DX_SUCCESS)
+            {
+                GST_WARNING("DX: ERROR - Discretix configuration file not found");
+                _status = DX_ERROR_BAD_ARGUMENTS;
+            }
+            else
+            {
+                _status = DxDrmClient_Init();
+                if (_status != DX_SUCCESS) 
+                {
+                    GST_WARNING("failed to initialize the DxDrmClient (error: %d)", _status);
+                }
+
+                // Set Secure Clock
+                /*   _status = DxDrmStream_AdjustClock(m_DxDrmStream, DX_AUTO_NO_UI);
+                if (_status != DX_SUCCESS) 
+                {
+                    GST_WARNING("failed setting secure clock (%d)", _status);
+                }
+                */
+            }
+        }
+	~DRMInitialisation()
+        {
+            DxDrmClient_Terminate();
+        }
+
+    public:
+        inline bool IsInitialised() const
+        {
+            return (_status == DX_SUCCESS);
+        }
+        void printError(const EDxDrmStatus status)
+        {
+            g_printerr("DxDRM Error:\n");
+
+            switch (status) {
+            case DX_ERROR_CONTENT_NOT_RECOGNIZED:
+                 g_printerr("The specified file is not protected by one of the supported DRM schemes.\n");
+                 break;
+            case DX_ERROR_NOT_INITIALIZED:
+                 g_printerr("The DRM Client has not been initialized.\n");
+                 break;
+            case DX_ERROR_BAD_ARGUMENTS:
+                 g_printerr("Bad arguments.\n");
+                 break;
+            default:
+                 g_printerr("unknown error: %d\n", status);
+                 break;
+        }
+}
+
+
+    private:
+        EDxDrmStatus _status;
+};
+
+static DRMInitialisation g_DRMInitialisation;
+
+CDMPRSessionGStreamer::CDMPRSessionGStreamer(MediaPlayerPrivateGStreamer* parent)
+    : m_player(parent)
+    , m_client(nullptr)
+    , m_sessionId()
+    , m_DxDrmStream(nullptr)
+    , m_key()
+    , m_state(PHASE_INITIAL)
+{
+    if (g_DRMInitialisation.IsInitialised() == true) {
+        m_sessionId = createCanonicalUUIDString();
+    }
+}
+
+CDMPRSessionGStreamer::~CDMPRSessionGStreamer()
+{
+    if (m_DxDrmStream != nullptr) {
+        DxDrmStream_Close(&m_DxDrmStream);
+        m_DxDrmStream = nullptr;
+    }
+}
+
+/* virtual */ CDMSessionType CDMPRSessionGStreamer::type() 
+{ 
+    return CDMSessionTypeMediaSourcePlayReady; 
+}
+
+/* virtual */ void CDMPRSessionGStreamer::setClient(CDMSessionClient* client) 
+{ 
+    ASSERT ( (m_client == nullptr) ^ (client == nullptr) );
+
+    m_client = client; 
+}
+
+/* virtual */ const String& CDMPRSessionGStreamer::sessionId() const 
+{ 
+    return m_sessionId; 
+}
+
+//
+// Expected synchronisation from caller. This method is not thread safe!!!!
+//
+/* virtual */ PassRefPtr<Uint8Array> CDMPRSessionGStreamer::generateKeyRequest(const String& mimeType, Uint8Array* initData, String& destinationURL, unsigned short& errorCode, unsigned long& systemCode) 
+{
+    UNUSED_PARAM(mimeType);
+
+    RefPtr<Uint8Array> result;
+
+    // Instantiate Discretix DRM client from the parsed WRMHEADER.
+    guint16 recordLength;
+    const guint8* data = extractWrmHeader(initData, &recordLength);
+    EDxDrmStatus status = DxDrmClient_OpenDrmStreamFromData(&m_DxDrmStream, data, recordLength);
+
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed creating DxDrmClient from initData (error: %d)", status);
+        g_DRMInitialisation.printError(status);
+        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+    } else {
+        unsigned long challengeLength = MAX_CHALLENGE_LEN;
+        unsigned char* challenge = static_cast<unsigned char*> (g_malloc0(challengeLength));
+
+        // Get challenge
+        status = DxDrmStream_GetLicenseChallenge(m_DxDrmStream, challenge, &challengeLength);
+        if (status != DX_SUCCESS) {
+            GST_WARNING("failed to generate challenge request (%d)", status);
+            errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+        } else {
+            // Get License URL
+            destinationURL = static_cast<const char *>(DxDrmStream_GetTextAttribute(m_DxDrmStream, DX_ATTR_SILENT_URL, DX_ACTIVE_CONTENT));
+            GST_DEBUG("destination URL : %s", destinationURL.utf8().data());
+
+            GST_MEMDUMP("generated license request :", challenge, challengeLength);
+
+            result = Uint8Array::create(challenge, challengeLength);
+            errorCode = 0;
+        }
+
+        g_free(challenge);
+    }
+
+    systemCode = status;
+
+    return result;
+}
+
+//
+// Expected synchronisation from caller. This method is not thread safe!!!!
+//
+/* virtual */ bool CDMPRSessionGStreamer::update(Uint8Array* key, RefPtr<Uint8Array>& nextMessage, unsigned short& errorCode, unsigned long& systemCode)
+{
+    GST_MEMDUMP("response received :", key->data(), key->byteLength());
+
+    unsigned long isAckRequired;
+    HDxResponseResult responseResult = nullptr;
+    EDxDrmStatus status = DX_ERROR_CONTENT_NOT_RECOGNIZED;
+
+    if (m_state == PHASE_INITIAL)
+    {
+        // Server replied to our license request
+        status = DxDrmStream_ProcessLicenseResponse(m_DxDrmStream, key->data(), key->byteLength(), &responseResult, &isAckRequired);
+
+        if (status  == DX_SUCCESS) {
+            // Create a deep copy of the key.
+            m_key = key->buffer();
+            m_state = (isAckRequired != 0 ? PHASE_ACKNOWLEDGE : PHASE_PROVISIONED);
+        }
+
+    } else if (m_state == PHASE_ACKNOWLEDGE) {
+
+        // Server replied to our license response acknowledge
+        status = DxDrmClient_ProcessServerResponse(key->data(), key->byteLength(), DX_RESPONSE_LICENSE_ACK, &responseResult, &isAckRequired);
+
+        if (status  == DX_SUCCESS) {
+            // Create a deep copy of the key.
+            m_key   = key->buffer();
+            m_state = (isAckRequired != 0 ? PHASE_ACKNOWLEDGE : PHASE_PROVISIONED);
+
+            if (m_state == PHASE_ACKNOWLEDGE) {
+                GST_WARNING("Acknowledging an Ack. Strange situation.");
+            }
+        }
+
+    } else {
+
+        GST_WARNING("Unexpected call. We are already provisioned");
+    }
+
+    if (status != DX_SUCCESS) {
+        GST_WARNING("failed processing license response (%d)", status);
+        errorCode = MediaKeyError::MEDIA_KEYERR_CLIENT;
+    } else if (m_state == PHASE_PROVISIONED) {
+
+        status = DxDrmStream_SetIntent(m_DxDrmStream, DX_INTENT_AUTO_PLAY, DX_AUTO_NO_UI);
+        if (status != DX_SUCCESS) {
+            GST_WARNING("DX: ERROR - opening stream failed because there are no rights (license) to play the content");
+        } else {
+            GST_INFO("DX: playback rights found");
+
+            /* Taken from the "Decryptor, not used there... 
+            status =  DxDrmStream_GetFlags(m_DxDrmStream, DX_FLAG_CAN_PLAY | DX_FLAG_HAS_FUTURE_RIGHTS,
+                                          &activeFlags, DX_ALL_PERMISSIONS, 0); */
+
+            /* starting consumption of the file - notifying the drm that the file is being used */
+            status = DxDrmFile_HandleConsumptionEvent(m_DxDrmStream, DX_EVENT_START);
+            if (status != DX_SUCCESS) {
+                GST_WARNING("DX: Content consumption failed");
+            } else {
+                GST_INFO("DX: Stream was opened and is ready for playback");
+                m_player->signalDRM();
+            }
+        }
+
+    } else if (m_state == PHASE_ACKNOWLEDGE) {
+        unsigned long challengeLength = MAX_CHALLENGE_LEN;
+        unsigned char* challenge = static_cast<unsigned char*>(g_malloc0(challengeLength));
+
+        status = DxDrmClient_GetLicenseAcq_GenerateAck(&responseResult, challenge, &challengeLength);
+        if (status != DX_SUCCESS) {
+            GST_WARNING("failed generating license ack challenge (%d) response result %p", status, responseResult);
+        }
+
+        GST_MEMDUMP("generated license ack request :", challenge, challengeLength);
+
+        nextMessage = Uint8Array::create(challenge, challengeLength);
+
+        g_free(challenge);
+    }
+
+    systemCode = status;
+
+    return (status == DX_SUCCESS);
+}
+
+/* virtual */ void CDMPRSessionGStreamer::releaseKeys()
+{
+    m_player->signalDRM();
+}
+
+/* virtual */ RefPtr<ArrayBuffer> CDMPRSessionGStreamer::cachedKeyForKeyID(const String& sessionId) const
+{
+    return (sessionId == m_sessionId ? m_key : nullptr);
+}
+
+int CDMPRSessionGStreamer::decrypt (GstMapInfo& map, GstMapInfo& boxMap, const unsigned int sampleIndex, const unsigned int trackId)
+{
+    EDxDrmStatus status = DxDrmStream_ProcessPiffPacket(
+        m_DxDrmStream, 
+        static_cast<void*>(map.data),
+        static_cast<unsigned int>(map.size),
+        static_cast<const void*>(boxMap.data),
+        static_cast<unsigned int>(boxMap.size),
+        static_cast<unsigned int>(sampleIndex),
+        trackId);
+
+    return (status == DX_DRM_SUCCESS ? 0 : status);
+}
+
+}
+
+#endif
diff -urN a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h
--- a/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h	1970-01-01 01:00:00.000000000 +0100
+++ b/Source/WebCore/platform/graphics/gstreamer/CDMPRSessionGStreamer.h	2015-07-20 20:23:57.928260561 +0200
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014-2015 FLUENDO S.A. All rights reserved.
+ * Copyright (C) 2014-2015 METROLOGICAL All rights reserved.
+ * Copyright (C) 2015 IGALIA S.L All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY FLUENDO S.A. AND ITS CONTRIBUTORS ``AS IS''
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL FLUENDO S.A. OR ITS CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef CDMPRSessionGStreamer_h
+#define CDMPRSessionGStreamer_h
+
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(GSTREAMER) && USE(DXDRM)
+
+#include "CDMSession.h"
+#include <gst/gst.h>
+#include <wtf/RetainPtr.h>
+
+namespace WebCore {
+
+class MediaPlayerPrivateGStreamer;
+
+class CDMPRSessionGStreamer : public CDMSession {
+private:
+    CDMPRSessionGStreamer();
+    CDMPRSessionGStreamer(const CDMPRSessionGStreamer&);
+
+private:
+    enum SessionState {
+        PHASE_INITIAL,
+        PHASE_ACKNOWLEDGE,
+        PHASE_PROVISIONED
+    };
+        
+public:
+    CDMPRSessionGStreamer(MediaPlayerPrivateGStreamer* parent);
+    virtual ~CDMPRSessionGStreamer() override;
+
+    virtual CDMSessionType type() override;
+    virtual void setClient(CDMSessionClient* client) override;
+    virtual const String& sessionId() const override;
+    virtual PassRefPtr<Uint8Array> generateKeyRequest(const String& mimeType, Uint8Array* initData, String& destinationURL, unsigned short& errorCode, unsigned long& systemCode) override;
+    virtual void releaseKeys() override;
+    virtual bool update(Uint8Array*, RefPtr<Uint8Array>& nextMessage, unsigned short& errorCode, unsigned long& systemCode) override;
+    virtual RefPtr<ArrayBuffer> cachedKeyForKeyID(const String&) const;
+
+    int decrypt(GstMapInfo& map, GstMapInfo& boxMap, const unsigned int sampleIndex, const unsigned int trackId);
+
+private:
+    MediaPlayerPrivateGStreamer* m_player;
+    CDMSessionClient* m_client;
+    String m_sessionId;
+    void* m_DxDrmStream;
+    RefPtr<ArrayBuffer> m_key;
+    SessionState m_state;
+};
+
+}
+
+#endif
+
+#endif // CDMPRSessionGStreamer_h
diff -urN a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp	2015-07-20 20:23:57.928260561 +0200
@@ -74,6 +74,11 @@
 #include "AudioSourceProviderGStreamer.h"
 #endif
 
+#if ENABLE(ENCRYPTED_MEDIA_V2) && USE(DXDRM)
+#include "CDMPRSessionGStreamer.h"
+#include "WebKitPlayReadyDecryptorGStreamer.h"
+#endif
+
 #if USE(GSTREAMER_GL)
 #include "GLContext.h"
 
@@ -212,8 +217,13 @@
 void MediaPlayerPrivateGStreamer::registerMediaEngine(MediaEngineRegistrar registrar)
 {
     if (isAvailable())
+#if ENABLE(ENCRYPTED_MEDIA_V2)
         registrar([](MediaPlayer* player) { return std::make_unique<MediaPlayerPrivateGStreamer>(player); },
+            getSupportedTypes, extendedSupportsType, 0, 0, 0, supportsKeySystem);
+#else
+         registrar([](MediaPlayer* player) { return std::make_unique<MediaPlayerPrivateGStreamer>(player); },
             getSupportedTypes, supportsType, 0, 0, 0, supportsKeySystem);
+#endif
 }
 
 bool initializeGStreamerAndRegisterWebKitElements()
@@ -233,6 +243,12 @@
         gst_element_register(0, "webkitcencdec", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_MEDIA_CENC_DECRYPT);
 #endif
 
+#if USE(DXDRM)
+    GRefPtr<GstElementFactory> playReadyDecryptorFactory = gst_element_factory_find("webkitplayreadydec");
+    if (!playReadyDecryptorFactory)
+        gst_element_register(0, "webkitplayreadydec", GST_RANK_PRIMARY + 100, WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT);
+#endif
+
 #if ENABLE(MEDIA_SOURCE)
     GRefPtr<GstElementFactory> WebKitMediaSrcFactory = gst_element_factory_find("webkitmediasrc");
     if (!WebKitMediaSrcFactory)
@@ -428,7 +444,7 @@
 #endif
 
 #if ENABLE(MEDIA_STREAM)
-void MediaPlayerPrivateGStreamer::load(MediaStreamPrivate&)
+void MediaPlayerPrivateGStreamer::load(MediaStreamPrivate*)
 {
     notImplemented();
 }
@@ -704,9 +720,9 @@
     if (!rate)
         rate = 1.0;
 
+#if ENABLE(MEDIA_SOURCE)
     MediaTime time(MediaTime::createWithDouble(double(static_cast<double>(position) / GST_SECOND)));
 
-#if ENABLE(MEDIA_SOURCE)
     if (isMediaSource())
         webkit_media_src_set_seek_time(WEBKIT_MEDIA_SRC(m_source.get()), time);
 #endif
@@ -2283,7 +2299,7 @@
 }
 
 #if ENABLE(ENCRYPTED_MEDIA)
-MediaPlayer::MediaKeyException MediaPlayerPrivateGStreamer::addKey(const String& keySystem, const unsigned char* keyData, unsigned keyLength, const unsigned char* initData, unsigned initDataLength, const String& sessionID)
+MediaPlayer::MediaKeyException MediaPlayerPrivateGStreamer::addKey(const String& keySystem, const unsigned char* keyData, unsigned keyLength, const unsigned char* /* initData */, unsigned /* initDataLength */ , const String& sessionID)
 {
     LOG_MEDIA_MESSAGE("addKey system: %s, length: %u, session: %s", keySystem.utf8().data(), keyLength, sessionID.utf8().data());
     GstBuffer* buffer = gst_buffer_new_wrapped(g_memdup(keyData, keyLength), keyLength);
@@ -2301,7 +2317,7 @@
     return MediaPlayer::NoError;
 }
 
-MediaPlayer::MediaKeyException MediaPlayerPrivateGStreamer::cancelKeyRequest(const String& keySystem, const String& sessionID)
+MediaPlayer::MediaKeyException MediaPlayerPrivateGStreamer::cancelKeyRequest(const String& /* keySystem */ , const String& /* sessionID */)
 {
     LOG_MEDIA_MESSAGE("cancelKeyRequest");
     return MediaPlayer::KeySystemNotSupported;
@@ -2314,8 +2330,75 @@
         m_drmKeySemaphore.signal();
     }
 }
+
+void MediaPlayerPrivateGStreamer::signalDRM()
+{
+    GST_DEBUG("key/license was changed or failed, signal semaphore");
+    // Wake up a potential waiter blocked in the GStreamer thread
+    m_drmKeySemaphore.signal();
+}
 #endif
 
+
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::extendedSupportsType(const MediaEngineSupportParameters& parameters)
+{
+    // From: <http://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html#dom-canplaytype>
+    // In addition to the steps in the current specification, this method must run the following steps:
+
+    // 1. Check whether the Key System is supported with the specified container and codec type(s) by following the steps for the first matching condition from the following list:
+    //    If keySystem is null, continue to the next step.
+    if (parameters.keySystem.isNull() || parameters.keySystem.isEmpty())
+        return supportsType(parameters);
+
+    // If keySystem contains an unrecognized or unsupported Key System, return the empty string
+    if (!supportsKeySystem(parameters.keySystem, emptyString()))
+        return MediaPlayer::IsNotSupported;
+
+    // If the Key System specified by keySystem does not support decrypting the container and/or codec specified in the rest of the type string.
+    // (AVFoundation does not provide an API which would allow us to determine this, so this is a no-op)
+
+    // 2. Return "maybe" or "probably" as appropriate per the existing specification of canPlayType().
+    return supportsType(parameters);
+}
+
+void MediaPlayerPrivateGStreamer::needKey(RefPtr<Uint8Array> initData)
+{
+    if (!m_player->keyNeeded(initData.get())) {
+        GST_DEBUG("no event handler for key needed, waking up GStreamer thread");
+        m_drmKeySemaphore.signal();
+    }
+}
+
+std::unique_ptr<CDMSession> MediaPlayerPrivateGStreamer::createSession(const String& keySystem)
+{
+    if (!supportsKeySystem(keySystem, emptyString()))
+        return nullptr;
+
+#if USE(DXDRM)
+    if (equalIgnoringCase(keySystem, "com.microsoft.playready")
+        || equalIgnoringCase(keySystem, "com.youtube.playready"))
+        return std::make_unique<CDMPRSessionGStreamer>(this);
+#endif
+
+    return nullptr;
+}
+
+void MediaPlayerPrivateGStreamer::setCDMSession(CDMSession* session)
+{
+    m_cdmSession = session;
+}
+
+void MediaPlayerPrivateGStreamer::keyAdded()
+{
+#if USE(DXDRM)
+    gst_element_send_event(m_pipeline.get(), gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM_OOB,
+       gst_structure_new("drm-cipher", "stream", G_TYPE_POINTER, static_cast<CDMPRSessionGStreamer*>(m_cdmSession), nullptr)));
+#endif
+}
+#endif
+
+
 MediaPlayer::SupportsType MediaPlayerPrivateGStreamer::supportsType(const MediaEngineSupportParameters& parameters)
 {
 #if ENABLE(MEDIA_SOURCE)
diff -urN a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h	2015-07-20 20:23:57.928260561 +0200
@@ -82,7 +82,7 @@
     void load(const String& url, MediaSourcePrivateClient*) override;
 #endif
 #if ENABLE(MEDIA_STREAM)
-    void load(MediaStreamPrivate&) override;
+    void load(MediaStreamPrivate*) override;
 #endif
     void commitLoad();
     void cancelLoad() override;
@@ -163,6 +163,12 @@
     void notifyAppendComplete();
 #endif
 
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+    void needKey(RefPtr<Uint8Array> initData);
+    void setCDMSession(CDMSession*);
+    void keyAdded();
+#endif
+
 private:
     static void getSupportedTypes(HashSet<String>&);
     static MediaPlayer::SupportsType supportsType(const MediaEngineSupportParameters&);
@@ -172,6 +178,12 @@
 
     GstElement* createAudioSink() override;
 
+#if ENABLE(ENCRYPTED_MEDIA_V2)
+    static MediaPlayer::SupportsType extendedSupportsType(const MediaEngineSupportParameters&);
+    std::unique_ptr<CDMSession> createSession(const String&);
+    CDMSession* m_cdmSession;
+#endif
+
     float playbackPosition() const;
 
     void cacheDuration();
diff -urN a/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp	2015-07-20 20:22:44.428260761 +0200
@@ -51,7 +51,7 @@
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS("application/x-cenc, original-media-type=(string)video/x-h264, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID "; "
-    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID));
+    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" CLEAR_KEY_PROTECTION_SYSTEM_ID "; "));
 
 static GstStaticPadTemplate srcTemplate = GST_STATIC_PAD_TEMPLATE("src",
     GST_PAD_SRC,
@@ -94,6 +94,28 @@
 }
 
 /*
+  Append new_structure to dest, but only if it does not already exist in res.
+  This function takes ownership of new_structure.
+*/
+static bool webkitMediaCommonEncryptionDecryptCapsAppendIfNotDuplicate(GstCaps* destination, GstStructure* structure)
+{
+    bool duplicate = false;
+    unsigned size = gst_caps_get_size(destination);
+    for (unsigned index = 0; !duplicate && index < size; ++index) {
+        GstStructure* s = gst_caps_get_structure(destination, index);
+        if (gst_structure_is_equal(s, structure))
+            duplicate = true;
+    }
+
+    if (!duplicate)
+        gst_caps_append_structure(destination, structure);
+    else
+        gst_structure_free(structure);
+
+    return duplicate;
+}
+
+/*
   Given the pad in this direction and the given caps, what caps are allowed on
   the other pad in this element ?
 */
@@ -153,22 +175,11 @@
                 "original-media-type", G_TYPE_STRING, gst_structure_get_name(in), nullptr);
 
             gst_structure_set_name(out, "application/x-cenc");
-            gst_structure_free(tmp);
-        }
-
-        bool duplicate = false;
-        unsigned size = gst_caps_get_size(transformedCaps);
 
-        for (unsigned index = 0; !duplicate && index < size; ++index) {
-            GstStructure* s = gst_caps_get_structure(transformedCaps, index);
-            if (gst_structure_is_equal(s, out))
-                duplicate = true;
+            gst_structure_free(tmp);
         }
 
-        if (!duplicate)
-            gst_caps_append_structure(transformedCaps, out);
-        else
-            gst_structure_free(out);
+        webkitMediaCommonEncryptionDecryptCapsAppendIfNotDuplicate(transformedCaps, out);
     }
 
     if (filter) {
diff -urN a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp	2015-07-20 20:23:57.928260561 +0200
@@ -0,0 +1,364 @@
+/* GStreamer ClearKey common encryption decryptor
+ *
+ * Copyright (C) 2015 Igalia S.L
+ * Copyright (C) 2015 Metrological
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Suite 500,
+ * Boston, MA 02110-1335, USA.
+ */
+
+#include "config.h"
+
+#if (ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)) && USE(GSTREAMER) && USE(DXDRM)
+#include "WebKitPlayReadyDecryptorGStreamer.h"
+#include "CDMPRSessionGStreamer.h"
+
+#include <gst/base/gstbasetransform.h>
+#include <gst/base/gstbytereader.h>
+
+struct _WebKitMediaPlayReadyDecrypt {
+    GstBaseTransform parent;
+    WebCore::CDMPRSessionGStreamer* sessionMetaData;
+    gboolean streamReceived;
+
+    GMutex mutex;
+    GCond condition;
+};
+
+struct _WebKitMediaPlayReadyDecryptClass {
+    GstBaseTransformClass parentClass;
+};
+
+static bool keyRequested = false;
+
+static GstCaps* webkitMediaPlayReadyDecryptTransformCaps(GstBaseTransform*, GstPadDirection, GstCaps*, GstCaps* filter);
+static GstFlowReturn webkitMediaPlayReadyDecryptTransformInPlace(GstBaseTransform*, GstBuffer*);
+static gboolean webkitMediaPlayReadyDecryptSinkEventHandler(GstBaseTransform*, GstEvent*);
+
+GST_DEBUG_CATEGORY(webkit_media_playready_decrypt_debug_category);
+#define GST_CAT_DEFAULT webkit_media_playready_decrypt_debug_category
+
+#define PLAYREADY_PROTECTION_SYSTEM_ID "9a04f079-9840-4286-ab92-e65be0885f95"
+
+static GstStaticPadTemplate sinkTemplate = GST_STATIC_PAD_TEMPLATE("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS("application/x-cenc, original-media-type=(string)video/x-h264, protection-system=(string)" PLAYREADY_PROTECTION_SYSTEM_ID "; "
+    "application/x-cenc, original-media-type=(string)audio/mpeg, protection-system=(string)" PLAYREADY_PROTECTION_SYSTEM_ID
+        ));
+
+static GstStaticPadTemplate srcTemplate = GST_STATIC_PAD_TEMPLATE("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS("video/x-h264; audio/mpeg"));
+
+#define webkit_media_playready_decrypt_parent_class parent_class
+G_DEFINE_TYPE(WebKitMediaPlayReadyDecrypt, webkit_media_playready_decrypt, GST_TYPE_BASE_TRANSFORM);
+
+static void webkit_media_playready_decrypt_dispose(GObject*);
+
+static void webkit_media_playready_decrypt_class_init(WebKitMediaPlayReadyDecryptClass* klass) {
+    GObjectClass *gobjectClass = G_OBJECT_CLASS(klass);
+    GstBaseTransformClass* baseTransformClass = GST_BASE_TRANSFORM_CLASS(klass);
+    GstElementClass* elementClass = GST_ELEMENT_CLASS(klass);
+
+    gobjectClass->dispose = webkit_media_playready_decrypt_dispose;
+    gst_element_class_add_pad_template(elementClass, gst_static_pad_template_get(&sinkTemplate));
+    gst_element_class_add_pad_template(elementClass, gst_static_pad_template_get(&srcTemplate));
+
+    gst_element_class_set_static_metadata(elementClass,
+        "Decrypt content encrypted using PlayReady Encryption",
+        GST_ELEMENT_FACTORY_KLASS_DECRYPTOR,
+        "Decrypts media that has been encrypted using PlayReady Encryption.",
+        "Philippe Normand <philn@igalia.com>");
+
+    GST_DEBUG_CATEGORY_INIT(webkit_media_playready_decrypt_debug_category,
+        "webkitplayready", 0, "PlayReady decryptor");
+
+    baseTransformClass->transform_ip = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptTransformInPlace);
+    baseTransformClass->transform_caps = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptTransformCaps);
+    baseTransformClass->sink_event = GST_DEBUG_FUNCPTR(webkitMediaPlayReadyDecryptSinkEventHandler);
+    baseTransformClass->transform_ip_on_passthrough = FALSE;
+}
+
+static void webkit_media_playready_decrypt_init(WebKitMediaPlayReadyDecrypt* self)
+{
+    GstBaseTransform* base = GST_BASE_TRANSFORM(self);
+
+    gst_base_transform_set_in_place(base, TRUE);
+    gst_base_transform_set_passthrough(base, FALSE);
+    gst_base_transform_set_gap_aware(base, FALSE);
+
+    g_mutex_init(&self->mutex);
+    g_cond_init(&self->condition);
+}
+
+static void webkit_media_playready_decrypt_dispose(GObject* object)
+{
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(object);
+
+    g_mutex_clear(&self->mutex);
+    g_cond_clear(&self->condition);
+
+    G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+/*
+  Append new_structure to dest, but only if it does not already exist in res.
+  This function takes ownership of new_structure.
+*/
+static bool webkitMediaPlayReadyDecryptCapsAppendIfNotDuplicate(GstCaps* destination, GstStructure* structure)
+{
+    bool duplicate = false;
+    unsigned size = gst_caps_get_size(destination);
+    for (unsigned index = 0; !duplicate && index < size; ++index) {
+        GstStructure* s = gst_caps_get_structure(destination, index);
+        if (gst_structure_is_equal(s, structure))
+            duplicate = true;
+    }
+
+    if (!duplicate)
+        gst_caps_append_structure(destination, structure);
+    else
+        gst_structure_free(structure);
+
+    return duplicate;
+}
+
+static GstCaps* webkitMediaPlayReadyDecryptTransformCaps(GstBaseTransform* base, GstPadDirection direction, GstCaps* caps, GstCaps* filter)
+{
+    g_return_val_if_fail(direction != GST_PAD_UNKNOWN, nullptr);
+    GstCaps* transformedCaps = gst_caps_new_empty();
+
+    GST_DEBUG_OBJECT(base, "direction: %s, caps: %" GST_PTR_FORMAT " filter:"
+        " %" GST_PTR_FORMAT, (direction == GST_PAD_SRC) ? "src" : "sink", caps, filter);
+
+    unsigned size = gst_caps_get_size(caps);
+    for (unsigned i = 0; i < size; ++i) {
+        GstStructure* in = gst_caps_get_structure(caps, i);
+        GstStructure* out = nullptr;
+
+        if (direction == GST_PAD_SINK) {
+            if (!gst_structure_has_field(in, "original-media-type"))
+                continue;
+
+            out = gst_structure_copy(in);
+            gst_structure_set_name(out, gst_structure_get_string(out, "original-media-type"));
+
+            /* filter out the DRM related fields from the down-stream caps */
+            for (int j = 0; j < gst_structure_n_fields(in); ++j) {
+                const gchar* fieldName = gst_structure_nth_field_name(in, j);
+
+                if (g_str_has_prefix(fieldName, "protection-system")
+                    || g_str_has_prefix(fieldName, "original-media-type"))
+                    gst_structure_remove_field(out, fieldName);
+            }
+        } else {
+            GstStructure* tmp = gst_structure_copy(in);
+            /* filter out the video related fields from the up-stream caps,
+               because they are not relevant to the input caps of this element and
+               can cause caps negotiation failures with adaptive bitrate streams */
+            for (int index = gst_structure_n_fields(tmp) - 1; index >= 0; --index) {
+                const gchar* fieldName = gst_structure_nth_field_name(tmp, index);
+                GST_TRACE("Check field \"%s\" for removal", fieldName);
+
+                if (!g_strcmp0(fieldName, "base-profile")
+                    || !g_strcmp0(fieldName, "codec_data")
+                    || !g_strcmp0(fieldName, "height")
+                    || !g_strcmp0(fieldName, "framerate")
+                    || !g_strcmp0(fieldName, "level")
+                    || !g_strcmp0(fieldName, "pixel-aspect-ratio")
+                    || !g_strcmp0(fieldName, "profile")
+                    || !g_strcmp0(fieldName, "rate")
+                    || !g_strcmp0(fieldName, "width")) {
+                    gst_structure_remove_field(tmp, fieldName);
+                    GST_TRACE("Removing field %s", fieldName);
+                }
+            }
+
+            out = gst_structure_copy(tmp);
+            gst_structure_set(out, "protection-system", G_TYPE_STRING, PLAYREADY_PROTECTION_SYSTEM_ID,
+                "original-media-type", G_TYPE_STRING, gst_structure_get_name(in), nullptr);
+
+            gst_structure_set_name(out, "application/x-cenc");
+            gst_structure_free(tmp);
+        }
+
+        webkitMediaPlayReadyDecryptCapsAppendIfNotDuplicate(transformedCaps, out);
+    }
+
+    if (filter) {
+        GstCaps* intersection;
+
+        GST_DEBUG_OBJECT(base, "Using filter caps %" GST_PTR_FORMAT, filter);
+        intersection = gst_caps_intersect_full(transformedCaps, filter, GST_CAPS_INTERSECT_FIRST);
+        gst_caps_unref(transformedCaps);
+        transformedCaps = intersection;
+    }
+
+    GST_DEBUG_OBJECT(base, "returning %" GST_PTR_FORMAT, transformedCaps);
+    return transformedCaps;
+}
+
+static GstFlowReturn webkitMediaPlayReadyDecryptTransformInPlace(GstBaseTransform* base, GstBuffer* buffer)
+{
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(base);
+    GstFlowReturn result = GST_FLOW_OK;
+    GstMapInfo map;
+    const GValue* value;
+    guint sampleIndex = 0;
+    int errorCode;
+    unsigned trackID = 0;
+    GstPad* pad;
+    GstCaps* caps;
+    GstMapInfo boxMap;
+    GstBuffer* box = nullptr;
+
+    g_mutex_lock(&self->mutex);
+
+    // The key might not have been received yet. Wait for it.
+    if (!self->streamReceived) {
+        g_printerr("stream not received yet. Waiting.\n");
+        g_cond_wait(&self->condition, &self->mutex);
+    }
+
+    GstProtectionMeta* protectionMeta = reinterpret_cast<GstProtectionMeta*>(gst_buffer_get_protection_meta(buffer));
+    if (!protectionMeta || !buffer) {
+        if (!protectionMeta)
+            GST_ERROR_OBJECT(self, "Failed to get GstProtection metadata from buffer %p", buffer);
+
+        if (!buffer)
+            GST_ERROR_OBJECT(self, "Failed to get writable buffer");
+
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    if (!gst_buffer_map(buffer, &map, static_cast<GstMapFlags>(GST_MAP_READWRITE))) {
+        GST_ERROR_OBJECT(self, "Failed to map buffer");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    pad = gst_element_get_static_pad(GST_ELEMENT(self), "src");
+    caps = gst_pad_get_current_caps(pad);
+    if (g_str_has_prefix(gst_structure_get_name(gst_caps_get_structure(caps, 0)), "video/"))
+        trackID = 1;
+    else
+        trackID = 2;
+    gst_caps_unref(caps);
+    gst_object_unref(pad);
+
+    if (!gst_structure_get_uint(protectionMeta->info, "sample-index", &sampleIndex)) {
+        GST_ERROR_OBJECT(self, "failed to get sample-index");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    value = gst_structure_get_value(protectionMeta->info, "box");
+    if (!value) {
+        GST_ERROR_OBJECT(self, "Failed to get encryption box for sample");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    box = gst_value_get_buffer(value);
+    if (!gst_buffer_map(box, &boxMap, GST_MAP_READ)) {
+        GST_ERROR_OBJECT(self, "Failed to map encryption box");
+        result = GST_FLOW_NOT_SUPPORTED;
+        goto beach;
+    }
+
+    GST_TRACE_OBJECT(self, "decrypt sample %u", sampleIndex);
+    if ((errorCode = self->sessionMetaData->decrypt( map, boxMap,  sampleIndex, trackID)) != 0) {
+        GST_WARNING_OBJECT(self, "ERROR - packet decryption failed [%d]", errorCode);
+        GST_MEMDUMP_OBJECT(self, "box", boxMap.data, boxMap.size);
+        result = GST_FLOW_ERROR;
+        goto beach;
+    }
+
+beach:
+    if (box)
+        gst_buffer_unmap(box, &boxMap);
+
+    gst_buffer_unmap(buffer, &map);
+
+    if (protectionMeta)
+        gst_buffer_remove_meta(buffer, reinterpret_cast<GstMeta*>(protectionMeta));
+
+    g_mutex_unlock(&self->mutex);
+    return result;
+}
+
+static gboolean webkitMediaPlayReadyDecryptSinkEventHandler(GstBaseTransform* trans, GstEvent* event)
+{
+    gboolean result = FALSE;
+    WebKitMediaPlayReadyDecrypt* self = WEBKIT_MEDIA_PLAYREADY_DECRYPT(trans);
+
+    g_mutex_lock(&self->mutex);
+    switch (GST_EVENT_TYPE(event)) {
+    case GST_EVENT_PROTECTION: {
+        const gchar* systemId;
+        GstBuffer* buffer = nullptr;
+        const gchar* origin;
+
+        GST_INFO_OBJECT(self, "received protection event");
+        gst_event_parse_protection(event, &systemId, &buffer, &origin);
+        GST_INFO_OBJECT(self, "systemId: %s", systemId);
+        if (!g_str_equal(systemId, PLAYREADY_PROTECTION_SYSTEM_ID)
+            || !g_str_has_prefix(origin, "smooth-streaming")) {
+            gst_event_unref(event);
+            result = FALSE;
+            break;
+        }
+
+        if (!keyRequested) {
+            keyRequested = true;
+            gst_element_post_message(GST_ELEMENT(self),
+                gst_message_new_element(GST_OBJECT(self),
+                    gst_structure_new("drm-key-needed", "data", GST_TYPE_BUFFER, buffer,
+                        "key-system-id", G_TYPE_STRING, systemId, nullptr)));
+        }
+
+        gst_event_unref(event);
+        result = TRUE;
+        break;
+    }
+    case GST_EVENT_CUSTOM_DOWNSTREAM_OOB: {
+        GST_INFO_OBJECT(self, "received OOB event");
+        const GstStructure* structure = gst_event_get_structure(event);
+        if (gst_structure_has_name(structure, "drm-cipher")) {
+            GST_INFO_OBJECT(self, "received drm-cipher");
+
+            const GValue* value = gst_structure_get_value(structure, "stream");
+            self->sessionMetaData = reinterpret_cast<WebCore::CDMPRSessionGStreamer*>(g_value_get_pointer(value));
+            self->streamReceived = TRUE;
+            g_cond_signal(&self->condition);
+        }
+
+        gst_event_unref(event);
+        result = TRUE;
+        break;
+    }
+    default:
+        result = GST_BASE_TRANSFORM_CLASS(parent_class)->sink_event(trans, event);
+        break;
+    }
+
+    g_mutex_unlock(&self->mutex);
+    return result;
+}
+
+#endif
diff -urN a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h	1970-01-01 01:00:00.000000000 +0100
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.h	2015-07-20 20:23:58.004260561 +0200
@@ -0,0 +1,45 @@
+/* GStreamer ClearKey common encryption decryptor
+ *
+ * Copyright (C) 2015 Igalia S.L
+ * Copyright (C) 2015 Metrological
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef WebKitPlayReadyDecryptorGStreamer_h
+#define WebKitPlayReadyDecryptorGStreamer_h
+
+#if (ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)) && USE(GSTREAMER) && USE(DXDRM)
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT          (webkit_media_playready_decrypt_get_type())
+#define WEBKIT_MEDIA_PLAYREADY_DECRYPT(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT, WebKitMediaPlayReadyDecrypt))
+#define WEBKIT_MEDIA_PLAYREADY_DECRYPT_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT, WebKitMediaPlayReadyDecryptClass))
+#define WEBKIT_IS_MEDIA_PLAYREADY_DECRYPT(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT))
+#define WEBKIT_IS_MEDIA_PLAYREADY_DECRYPT_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass), WEBKIT_TYPE_MEDIA_PLAYREADY_DECRYPT))
+
+typedef struct _WebKitMediaPlayReadyDecrypt      WebKitMediaPlayReadyDecrypt;
+typedef struct _WebKitMediaPlayReadyDecryptClass WebKitMediaPlayReadyDecryptClass;
+
+GType webkit_media_playready_decrypt_get_type(void);
+
+G_END_DECLS
+
+#endif
+#endif
diff -urN a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp
--- a/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/platform/graphics/gstreamer/WebKitWebSourceGStreamer.cpp	2015-07-20 20:22:44.428260761 +0200
@@ -1082,8 +1082,8 @@
     priv->offset += length;
     // priv->size == 0 if received length on didReceiveResponse < 0.
     if (priv->size > 0 && priv->offset > priv->size) {
-        GST_DEBUG_OBJECT(src, "Updating internal size from %" G_GUINT64_FORMAT " to %" G_GUINT64_FORMAT, priv->size, priv->offset);
-        gst_app_src_set_size(priv->appsrc, priv->offset);
+        GST_DEBUG_OBJECT(src, "Updating internal size from %" G_GUINT64_FORMAT " to %" G_GUINT64_FORMAT, priv->size, priv->offset+4096);
+        gst_app_src_set_size(priv->appsrc, priv->offset + 4096);
         priv->size = priv->offset;
     }
     GST_BUFFER_OFFSET_END(priv->buffer.get()) = priv->offset;
diff -urN a/Source/WebCore/PlatformWPE.cmake b/Source/WebCore/PlatformWPE.cmake
--- a/Source/WebCore/PlatformWPE.cmake	2015-07-18 12:52:08.000000000 +0200
+++ b/Source/WebCore/PlatformWPE.cmake	2015-07-20 20:22:44.428260761 +0200
@@ -335,4 +335,11 @@
         platform/graphics/gstreamer/WebKitCommonEncryptionDecryptorGStreamer.cpp
         platform/graphics/gstreamer/WebKitMediaAesCtr.c
     )
+
+    if (ENABLE_ENCRYPTED_MEDIA_V2 AND ENABLE_DXDRM)
+        list(APPEND WebCore_SOURCES
+            platform/graphics/gstreamer/CDMPRSessionGStreamer.cpp
+            platform/graphics/gstreamer/WebKitPlayReadyDecryptorGStreamer.cpp
+        )
+    endif ()
 endif ()
