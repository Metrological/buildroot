--- a/Source/WebCore/html/HTMLCanvasElement.cpp
+++ b/Source/WebCore/html/HTMLCanvasElement.cpp
@@ -552,8 +552,8 @@
         return false;
 
     // Do not use acceleration for small canvas.
-    if (size.width() * size.height() < settings->minimumAccelerated2dCanvasSize())
-        return false;
+    // if (size.width() * size.height() < settings->minimumAccelerated2dCanvasSize())
+    //     return false;
 
     return true;
 #else
--- a/Source/WebCore/page/Settings.in
+++ b/Source/WebCore/page/Settings.in
@@ -107,7 +107,7 @@
 webGLErrorsToConsoleEnabled initial=true
 openGLMultisamplingEnabled initial=true
 privilegedWebGLExtensionsEnabled initial=false
-accelerated2dCanvasEnabled initial=false
+accelerated2dCanvasEnabled initial=true
 antialiased2dCanvasEnabled initial=true
 loadDeferringEnabled initial=true
 webAudioEnabled initial=false
--- a/Source/WebCore/platform/graphics/GraphicsContext.cpp
+++ b/Source/WebCore/platform/graphics/GraphicsContext.cpp
@@ -758,7 +758,7 @@
 }
 #endif
 
-#if !USE(CG) && !USE(CAIRO)
+#if !USE(CG) && !USE(CAIRO) && !PLATFORM(QT)
 bool GraphicsContext::isAcceleratedContext() const
 {
     return false;
--- a/Source/WebCore/platform/graphics/ImageBuffer.cpp
+++ b/Source/WebCore/platform/graphics/ImageBuffer.cpp
@@ -98,7 +98,7 @@
     genericConvertToLuminanceMask();
 }
 
-#if USE(ACCELERATED_COMPOSITING) && !USE(CAIRO) && !PLATFORM(BLACKBERRY)
+#if USE(ACCELERATED_COMPOSITING) && !USE(CAIRO) && !PLATFORM(BLACKBERRY) && !PLATFORM(QT)
 PlatformLayer* ImageBuffer::platformLayer() const
 {
     return 0;
--- a/Source/WebCore/platform/graphics/qt/GLSharedContext.cpp
+++ b/Source/WebCore/platform/graphics/qt/GLSharedContext.cpp
@@ -0,0 +1,14 @@
+#include "GLSharedContext.h"
+
+namespace WebCore {
+
+QOpenGLContext* GLSharedContext::getContext() {
+    return m_context;
+}
+
+void GLSharedContext::setContext(QOpenGLContext *context) {
+    m_context = context;
+}
+
+QOpenGLContext* GLSharedContext::m_context = NULL;
+}
--- a/Source/WebCore/platform/graphics/qt/GLSharedContext.h
+++ b/Source/WebCore/platform/graphics/qt/GLSharedContext.h
@@ -0,0 +1,18 @@
+#include <QOpenGLContext>
+
+#ifndef GLSharedContext_h
+#define GLSharedContext_h
+
+namespace WebCore {
+
+class GLSharedContext {
+public:
+    static QOpenGLContext* getContext();
+    static void setContext(QOpenGLContext *context);
+
+private:
+    static QOpenGLContext *m_context;
+};
+}
+
+#endif
--- a/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp
+++ b/Source/WebCore/platform/graphics/qt/GraphicsContextQt.cpp
@@ -1704,6 +1704,10 @@
     m_data->takeOwnershipOfPlatformContext();
 }
 
+bool GraphicsContext::isAcceleratedContext() const
+{
+    return (platformContext()->paintEngine()->type() == QPaintEngine::OpenGL2);
 }
 
+}
 // vim: ts=4 sw=4 et
--- a/Source/WebCore/platform/graphics/qt/ImageBufferDataQt.h
+++ b/Source/WebCore/platform/graphics/qt/ImageBufferDataQt.h
@@ -34,16 +34,14 @@
 namespace WebCore {
 
 class IntSize;
+struct ImageBufferDataPrivate;
 
-class ImageBufferData {
+class ImageBufferData
+{
 public:
-    ImageBufferData(const IntSize&);
-
-    QImage toQImage() const;
-
-    QPixmap m_pixmap;
+    ImageBufferData(const IntSize&, bool);
     OwnPtr<QPainter> m_painter;
-    RefPtr<Image> m_image;
+    OwnPtr<ImageBufferDataPrivate> m_impl;
 };
 
 } // namespace WebCore
--- b/Source/WebCore/Target.pri
+++ b/Source/WebCore/Target.pri
@@ -2232,7 +2232,14 @@
     platform/graphics/RoundedRect.h \
     platform/graphics/qt/FontCustomPlatformData.h \
     platform/graphics/qt/NativeImageQt.h \
-    platform/graphics/qt/StillImageQt.h \
+    platform/graphics/qt/StillImageQt.h
+
+contains(QT_CONFIG,opengl) {
+HEADERS += \
+    platform/graphics/qt/GLSharedContext.h
+}
+
+HEADERS += \
     platform/graphics/qt/TransparencyLayer.h \
     platform/graphics/SegmentedFontData.h \
     platform/graphics/ShadowBlur.h \
@@ -2886,7 +2893,14 @@
     platform/graphics/qt/IntSizeQt.cpp \
     platform/graphics/qt/PathQt.cpp \
     platform/graphics/qt/PatternQt.cpp \
-    platform/graphics/qt/StillImageQt.cpp \
+    platform/graphics/qt/StillImageQt.cpp
+
+contains(QT_CONFIG,opengl){
+SOURCES += \
+    platform/graphics/qt/GLSharedContext.cpp
+}
+
+SOURCES += \
     platform/graphics/texmap/GraphicsLayerTextureMapper.cpp \
     platform/graphics/texmap/TextureMapper.cpp \
     platform/graphics/texmap/TextureMapperBackingStore.cpp \
--- b/Source/WebKit/qt/WidgetSupport/PageClientQt.h
+++ b/Source/WebKit/qt/WidgetSupport/PageClientQt.h
@@ -174,7 +174,9 @@
 #endif
 
     virtual bool makeOpenGLContextCurrentIfAvailable();
-
+#ifndef QT_NO_OPENGL
+    virtual QOpenGLContext* getOpenGLContextIfAvailable();
+#endif
     virtual QRectF windowRect() const;
 
     QGraphicsView* firstGraphicsView() const;
--- b/Source/WebKit/qt/WidgetSupport/PageClientQt.cpp
+++ b/Source/WebKit/qt/WidgetSupport/PageClientQt.cpp
@@ -195,6 +195,26 @@
     return false;
 }
 
+#ifndef QT_NO_OPENGL
+QOpenGLContext* PageClientQGraphicsWidget::getOpenGLContextIfAvailable()
+{
+#if USE(ACCELERATED_COMPOSITING) && USE(TEXTURE_MAPPER_GL) && defined(QT_OPENGL_LIB)
+    QGraphicsView* graphicsView = firstGraphicsView();
+    if (graphicsView && graphicsView->viewport()) {
+        QGLWidget* glWidget = qobject_cast<QGLWidget*>(graphicsView->viewport());
+        if (glWidget) {
+            QOpenGLContext *previous = QOpenGLContext::currentContext();
+            glWidget->makeCurrent();
+            QOpenGLContext *c = QOpenGLContext::currentContext();
+            previous->makeCurrent(previous->surface());
+            return c;
+        }
+    }
+#endif
+    return 0;
+}
+#endif
+
 void PageClientQGraphicsWidget::setInputMethodEnabled(bool enable)
 {
     view->setFlag(QGraphicsItem::ItemAcceptsInputMethod, enable);
--- b/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp
+++ b/Source/WebKit/qt/WidgetApi/qgraphicswebview.cpp
@@ -316,6 +316,11 @@
         QApplication::sendEvent(this, &event);
         return value;
     }
+#ifndef QT_NO_OPENGL
+    case ItemSceneHasChanged:
+        if (scene())
+            d->page->d->saveGLContext();
+#endif
     default:
         break;
     }
--- b/Source/WebCore/platform/qt/QWebPageClient.h
+++ b/Source/WebCore/platform/qt/QWebPageClient.h
@@ -40,6 +40,9 @@
 
 #include <QPalette>
 #include <QRect>
+#ifndef QT_NO_OPENGL
+#include <QOpenGLContext>
+#endif
 
 QT_BEGIN_NAMESPACE
 class QStyle;
@@ -62,6 +65,9 @@
     virtual void setInputMethodEnabled(bool enable) = 0;
     virtual bool inputMethodEnabled() const = 0;
     virtual bool makeOpenGLContextCurrentIfAvailable() { return false; }
+#ifndef QT_NO_OPENGL
+    virtual QOpenGLContext* getOpenGLContextIfAvailable() { return 0; }
+#endif
 
     virtual void setInputMethodHints(Qt::InputMethodHints hint) = 0;
 
--- b/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h
+++ b/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.h
@@ -158,6 +158,9 @@
     // For similar reasons, we don't want to create the WebCore Page before
     // we properly initialized the style factory callbacks.
     void initializeWebCorePage();
+#ifndef QT_NO_OPENGL
+    void saveGLContext();
+#endif
 
     virtual void show() = 0;
     virtual void setFocus() = 0;
--- b/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.cpp
+++ b/Source/WebKit/qt/WebCoreSupport/QWebPageAdapter.cpp
@@ -107,6 +107,10 @@
 #include <QTextCharFormat>
 #include <QTouchEvent>
 #include <QWheelEvent>
+#ifndef QT_NO_OPENGL
+#include <QOpenGLContext>
+#include "GLSharedContext.h"
+#endif
 
 // from text/qfont.cpp
 QT_BEGIN_NAMESPACE
@@ -281,6 +285,14 @@
     PageGroup::setShouldTrackVisitedLinks(true);
 }
 
+#ifndef QT_NO_OPENGL
+void QWebPageAdapter::saveGLContext()
+{
+    QOpenGLContext *c = client->getOpenGLContextIfAvailable();
+    GLSharedContext::setContext(c);
+}
+#endif
+
 QWebPageAdapter::~QWebPageAdapter()
 {
     delete page;
--- a/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp
+++ b/Source/WebCore/platform/graphics/qt/ImageBufferQt.cpp
@@ -45,116 +45,315 @@
 #include <QPixmap>
 #include <math.h>
 
+#if ENABLE(ACCELERATED_2D_CANVAS)
+#include <QOpenGLFramebufferObject>
+#include <QOpenGLPaintDevice>
+#include <QOffscreenSurface>
+#include <QOpenGLContext>
+#include "TextureMapper.h"
+#include "TextureMapperPlatformLayer.h"
+#include "TextureMapperGL.h"
+#include <private/qopenglpaintengine_p.h>
+#include "OpenGLShims.h"
+#include "GLSharedContext.h"
+#endif
+
 namespace WebCore {
 
-ImageBufferData::ImageBufferData(const IntSize& size)
-    : m_pixmap(size)
-{
-    if (m_pixmap.isNull())
-        return;
+struct ImageBufferDataPrivate {
+    virtual ~ImageBufferDataPrivate() { }
+    virtual QPaintDevice* paintDevice() = 0;
+    virtual QImage toQImage() const = 0;
+    virtual PassRefPtr<Image> copyImage(BackingStoreCopy copyBehavior) const = 0;
+    virtual bool isAccelerated() const = 0;
+    virtual PlatformLayer* platformLayer() = 0;
+    virtual void draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect,
+                      const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode, bool useLowQualityScale,
+                      bool ownContext) = 0;
+    virtual void drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                             const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op,
+                             const FloatRect& destRect, bool ownContext) = 0;
+    virtual void clip(GraphicsContext* context, const FloatRect& floatRect) const = 0;
+    virtual void platformTransformColorSpace(const Vector<int>& lookUpTable) = 0;
+};
+
+#if ENABLE(ACCELERATED_2D_CANVAS)
+class GLBufferContext : public QOpenGLContext {
+public:
+    static GLBufferContext* getContext() {
+        if (!m_context)
+            m_context = new GLBufferContext;
+        return m_context;
+    }
 
-    m_pixmap.fill(QColor(Qt::transparent));
+    void makeCurrentIfNeeded() {
+        if (QOpenGLContext::currentContext() != this)
+            makeCurrent(m_surface);
+    }
+private:
+    GLBufferContext() : m_surface(new QOffscreenSurface) {
+        m_surface->create();
+        setShareContext(GLSharedContext::getContext());
+        create();
+        makeCurrent(m_surface);
+        initializeOpenGLShims();
+    }
+    QOffscreenSurface *m_surface;
+    static GLBufferContext *m_context;
+};
+GLBufferContext* GLBufferContext::m_context = NULL;
+
+
+/*************** accelerated implementation ****************/
+
+class ImageBufferPaintDevice;
+struct ImageBufferDataPrivateAccelerated : public TextureMapperPlatformLayer, public ImageBufferDataPrivate {
+    ImageBufferDataPrivateAccelerated(const IntSize& size);
+    QPaintDevice* paintDevice() { return m_pdev.get(); }
+    QImage toQImage() const;
+    PassRefPtr<Image> copyImage(BackingStoreCopy copyBehavior) const;
+    bool isAccelerated() const { return true; }
+    PlatformLayer* platformLayer() { return this; }
+
+    void commitChanges() const;
+    void draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect,
+              const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode, bool useLowQualityScale,
+              bool ownContext);
+    void drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                     const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op,
+                     const FloatRect& destRect, bool ownContext);
+    void clip(GraphicsContext* context, const FloatRect& floatRect) const;
+    void platformTransformColorSpace(const Vector<int>& lookUpTable);
+    void paintToTextureMapper(TextureMapper*, const FloatRect&, const TransformationMatrix& modelViewMatrix = TransformationMatrix(), float opacity = 1.0);
+
+    mutable bool m_fboDirty;
+    OwnPtr<QOpenGLFramebufferObject> m_fbo;
+    OwnPtr<QOpenGLPaintDevice> m_pdev;
+};
+
+class ImageBufferPaintDevice : public QOpenGLPaintDevice
+{
+public:
+    ImageBufferPaintDevice(ImageBufferDataPrivateAccelerated* impl)
+    : QOpenGLPaintDevice(impl->m_fbo->size())
+    , m_impl(impl) { }
+    virtual ~ImageBufferPaintDevice() { }
+
+    void ensureActiveTarget()
+    {
+        GLBufferContext::getContext()->makeCurrentIfNeeded();
+        m_impl->m_fbo->bind();
+        m_impl->m_fboDirty = true;
+    }
+private:
+    ImageBufferDataPrivateAccelerated* m_impl;
+};
+
+ImageBufferDataPrivateAccelerated::ImageBufferDataPrivateAccelerated(const IntSize& size)
+    : m_fboDirty(true)
+{
+    GLBufferContext::getContext()->makeCurrentIfNeeded();
+
+    QOpenGLFramebufferObjectFormat fboFormat;
+    fboFormat.setSamples(0);
+    fboFormat.setAttachment(QOpenGLFramebufferObject::CombinedDepthStencil);
+    m_fbo = adoptPtr(new QOpenGLFramebufferObject(size, fboFormat));
+    m_fbo->bind();
+    m_pdev = adoptPtr(new ImageBufferPaintDevice(this));
+}
+
+QImage ImageBufferDataPrivateAccelerated::toQImage() const
+{
+    QOpenGLContext *previousContext = QOpenGLContext::currentContext();
+    GLBufferContext::getContext()->makeCurrentIfNeeded();
+    commitChanges();
+    QImage image = m_fbo->toImage();
+    previousContext->makeCurrent(previousContext->surface());
+    return image;
+}
 
-    QPainter* painter = new QPainter;
-    m_painter = adoptPtr(painter);
+PassRefPtr<Image> ImageBufferDataPrivateAccelerated::copyImage(BackingStoreCopy copyBehavior) const
+{
+    return StillImage::create(QPixmap::fromImage(toQImage()));
+}
 
-    if (!painter->begin(&m_pixmap))
+void ImageBufferDataPrivateAccelerated::commitChanges() const
+{
+    if (!m_fboDirty)
         return;
 
-    // Since ImageBuffer is used mainly for Canvas, explicitly initialize
-    // its painter's pen and brush with the corresponding canvas defaults
-    // NOTE: keep in sync with CanvasRenderingContext2D::State
-    QPen pen = painter->pen();
-    pen.setColor(Qt::black);
-    pen.setWidth(1);
-    pen.setCapStyle(Qt::FlatCap);
-    pen.setJoinStyle(Qt::SvgMiterJoin);
-    pen.setMiterLimit(10);
-    painter->setPen(pen);
-    QBrush brush = painter->brush();
-    brush.setColor(Qt::black);
-    painter->setBrush(brush);
-    painter->setCompositionMode(QPainter::CompositionMode_SourceOver);
-    
-    m_image = StillImage::createForRendering(&m_pixmap);
+    // this will flush pending QPainter operations and force ensureActiveTarget() to be called on the next paint
+    QPainter* painter = m_pdev->paintEngine()->painter();
+    painter->beginNativePainting();
+    painter->endNativePainting();
+
+    m_fboDirty = false;
+}
+
+void ImageBufferDataPrivateAccelerated::draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect,
+                                             const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode,
+                                             bool useLowQualityScale, bool ownContext)
+{
+    if (destContext->isAcceleratedContext()) {
+        QOpenGLContext *previousContext = QOpenGLContext::currentContext();
+        GLBufferContext::getContext()->makeCurrentIfNeeded();
+        commitChanges();
+        previousContext->makeCurrent(previousContext->surface());
+
+        QOpenGL2PaintEngineEx* acceleratedPaintEngine = static_cast<QOpenGL2PaintEngineEx*>(destContext->platformContext()->paintEngine());
+        FloatRect flippedSrc = srcRect;
+        flippedSrc.setY(m_fbo->size().height() - flippedSrc.height() - flippedSrc.y());
+        acceleratedPaintEngine->drawTexture(destRect, m_fbo->texture(), m_fbo->size(), flippedSrc);
+    } else {
+        RefPtr<Image> image = StillImage::create(QPixmap::fromImage(toQImage()));
+        destContext->drawImage(image.get(), styleColorSpace, destRect, srcRect, op, blendMode,
+                               DoNotRespectImageOrientation, useLowQualityScale);
+    }
 }
 
-QImage ImageBufferData::toQImage() const
+void ImageBufferDataPrivateAccelerated::drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                                                    const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op,
+                                                    const FloatRect& destRect, bool ownContext)
 {
-    QPaintEngine* paintEngine = m_pixmap.paintEngine();
-    if (!paintEngine || paintEngine->type() != QPaintEngine::Raster)
-        return m_pixmap.toImage();
+    RefPtr<Image> image = StillImage::create(QPixmap::fromImage(toQImage()));
+    image->drawPattern(destContext, srcRect, patternTransform, phase, styleColorSpace, op, destRect);
+}
 
-    // QRasterPixmapData::toImage() will deep-copy the backing QImage if there's an active QPainter on it.
-    // For performance reasons, we don't want that here, so we temporarily redirect the paint engine.
-    QPaintDevice* currentPaintDevice = paintEngine->paintDevice();
-    paintEngine->setPaintDevice(0);
-    QImage image = m_pixmap.toImage();
-    paintEngine->setPaintDevice(currentPaintDevice);
-    return image;
+void ImageBufferDataPrivateAccelerated::clip(GraphicsContext* context, const FloatRect& floatRect) const
+{
+    QPixmap alphaMask = QPixmap::fromImage(toQImage());
+    IntRect rect = enclosingIntRect(floatRect);
+    context->pushTransparencyLayerInternal(rect, 1.0, alphaMask);
 }
 
-ImageBuffer::ImageBuffer(const IntSize& size, float /* resolutionScale */, ColorSpace, RenderingMode, bool& success)
-    : m_data(size)
-    , m_size(size)
-    , m_logicalSize(size)
+void ImageBufferDataPrivateAccelerated::platformTransformColorSpace(const Vector<int>& lookUpTable)
 {
-    success = m_data.m_painter && m_data.m_painter->isActive();
-    if (!success)
-        return;
+    QPainter* painter = paintDevice()->paintEngine()->painter();
 
-    m_context = adoptPtr(new GraphicsContext(m_data.m_painter.get()));
+    QImage image = toQImage().convertToFormat(QImage::Format_ARGB32);
+    ASSERT(!image.isNull());
+
+    uchar* bits = image.bits();
+    const int bytesPerLine = image.bytesPerLine();
+
+    for (int y = 0; y < image.height(); ++y) {
+        quint32* scanLine = reinterpret_cast_ptr<quint32*>(bits + y * bytesPerLine);
+        for (int x = 0; x < image.width(); ++x) {
+            QRgb& pixel = scanLine[x];
+            pixel = qRgba(lookUpTable[qRed(pixel)],
+                          lookUpTable[qGreen(pixel)],
+                          lookUpTable[qBlue(pixel)],
+                          qAlpha(pixel));
+        }
+    }
+
+    painter->save();
+    painter->resetTransform();
+    painter->setOpacity(1.0);
+    painter->setClipping(false);
+    painter->setCompositionMode(QPainter::CompositionMode_Source);
+    // Should coordinates be flipped?
+    painter->drawImage(QPoint(0,0), image);
+    painter->restore();
 }
 
-ImageBuffer::~ImageBuffer()
+void ImageBufferDataPrivateAccelerated::paintToTextureMapper(TextureMapper* textureMapper, const FloatRect& targetRect, const TransformationMatrix& matrix, float opacity)
 {
+    if (textureMapper->accelerationMode() != TextureMapper::OpenGLMode) {
+        return;
+    }
+
+    QOpenGLContext *previousContext = QOpenGLContext::currentContext();
+    GLBufferContext::getContext()->makeCurrentIfNeeded();
+    commitChanges();
+    previousContext->makeCurrent(previousContext->surface());
+
+    static_cast<TextureMapperGL*>(textureMapper)->drawTexture(m_fbo->texture(), TextureMapperGL::ShouldFlipTexture | TextureMapperGL::ShouldBlend, m_fbo->size(), targetRect, matrix, opacity);
+
 }
 
-GraphicsContext* ImageBuffer::context() const
-{
-    ASSERT(m_data.m_painter->isActive());
+#endif // ACCELERATED_2D_CANVAS
+
+/*************** non accelerated implementation ****************/
+
+struct ImageBufferDataPrivateUnaccelerated : public ImageBufferDataPrivate {
+    ImageBufferDataPrivateUnaccelerated(const IntSize& size);
+    QPaintDevice* paintDevice() { return m_pixmap.isNull() ? 0 : &m_pixmap; }
+    QImage toQImage() const;
+    PassRefPtr<Image> copyImage(BackingStoreCopy copyBehavior) const;
+    virtual bool isAccelerated() const { return false; }
+    PlatformLayer* platformLayer() { return 0; }
+    void draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect,
+              const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode, bool useLowQualityScale,
+              bool ownContext);
+    void drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                     const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op,
+                     const FloatRect& destRect, bool ownContext);
+    void clip(GraphicsContext* context, const FloatRect& floatRect) const;
+    void platformTransformColorSpace(const Vector<int>& lookUpTable);
+
+    QPixmap m_pixmap;
+    RefPtr<Image> m_image;
+};
 
-    return m_context.get();
+ImageBufferDataPrivateUnaccelerated::ImageBufferDataPrivateUnaccelerated(const IntSize& size)
+    : m_pixmap(size)
+    , m_image(StillImage::createForRendering(&m_pixmap))
+{
+    m_pixmap.fill(QColor(Qt::transparent));
 }
 
-PassRefPtr<Image> ImageBuffer::copyImage(BackingStoreCopy copyBehavior, ScaleBehavior) const
+QImage ImageBufferDataPrivateUnaccelerated::toQImage() const
 {
-    if (copyBehavior == CopyBackingStore)
-        return StillImage::create(m_data.m_pixmap);
+    QPaintEngine* paintEngine = m_pixmap.paintEngine();
+    if (!paintEngine || paintEngine->type() != QPaintEngine::Raster)
+        return m_pixmap.toImage();
 
-    return StillImage::createForRendering(&m_data.m_pixmap);
+    // QRasterPixmapData::toImage() will deep-copy the backing QImage if there's an active QPainter on it.
+    // For performance reasons, we don't want that here, so we temporarily redirect the paint engine.
+    QPaintDevice* currentPaintDevice = paintEngine->paintDevice();
+    paintEngine->setPaintDevice(0);
+    QImage image = m_pixmap.toImage();
+    paintEngine->setPaintDevice(currentPaintDevice);
+    return image;
 }
 
-BackingStoreCopy ImageBuffer::fastCopyImageMode()
+PassRefPtr<Image> ImageBufferDataPrivateUnaccelerated::copyImage(BackingStoreCopy copyBehavior) const
 {
-    return DontCopyBackingStore;
+    if (copyBehavior == CopyBackingStore)
+        return StillImage::create(m_pixmap);
+
+    return StillImage::createForRendering(&m_pixmap);
 }
 
-void ImageBuffer::draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect, const FloatRect& srcRect,
-    CompositeOperator op, BlendMode blendMode, bool useLowQualityScale)
+void ImageBufferDataPrivateUnaccelerated::draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect,
+                                               const FloatRect& srcRect, CompositeOperator op, BlendMode blendMode,
+                                               bool useLowQualityScale, bool ownContext)
 {
-    if (destContext == context()) {
+    if (ownContext) {
         // We're drawing into our own buffer.  In order for this to work, we need to copy the source buffer first.
         RefPtr<Image> copy = copyImage(CopyBackingStore);
         destContext->drawImage(copy.get(), ColorSpaceDeviceRGB, destRect, srcRect, op, blendMode, DoNotRespectImageOrientation, useLowQualityScale);
     } else
-        destContext->drawImage(m_data.m_image.get(), styleColorSpace, destRect, srcRect, op, blendMode, DoNotRespectImageOrientation, useLowQualityScale);
+        destContext->drawImage(m_image.get(), styleColorSpace, destRect, srcRect, op, blendMode, DoNotRespectImageOrientation, useLowQualityScale);
 }
 
-void ImageBuffer::drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
-                              const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op, const FloatRect& destRect)
+void ImageBufferDataPrivateUnaccelerated::drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                                                      const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op,
+                                                      const FloatRect& destRect, bool ownContext)
 {
-    if (destContext == context()) {
+    if (ownContext) {
         // We're drawing into our own buffer.  In order for this to work, we need to copy the source buffer first.
         RefPtr<Image> copy = copyImage(CopyBackingStore);
         copy->drawPattern(destContext, srcRect, patternTransform, phase, styleColorSpace, op, destRect);
     } else
-        m_data.m_image->drawPattern(destContext, srcRect, patternTransform, phase, styleColorSpace, op, destRect);
+        m_image->drawPattern(destContext, srcRect, patternTransform, phase, styleColorSpace, op, destRect);
 }
 
-void ImageBuffer::clip(GraphicsContext* context, const FloatRect& floatRect) const
+void ImageBufferDataPrivateUnaccelerated::clip(GraphicsContext* context, const FloatRect& floatRect) const
 {
-    QPixmap* nativeImage = m_data.m_image->nativeImageForCurrentFrame();
+    QPixmap* nativeImage = m_image->nativeImageForCurrentFrame();
+
     if (!nativeImage)
         return;
 
@@ -164,21 +363,23 @@
     context->pushTransparencyLayerInternal(rect, 1.0, alphaMask);
 }
 
-void ImageBuffer::platformTransformColorSpace(const Vector<int>& lookUpTable)
+void ImageBufferDataPrivateUnaccelerated::platformTransformColorSpace(const Vector<int>& lookUpTable)
 {
-    bool isPainting = m_data.m_painter->isActive();
+    QPainter* painter = paintDevice()->paintEngine()->painter();
+
+    bool isPainting = painter->isActive();
     if (isPainting)
-        m_data.m_painter->end();
+        painter->end();
 
-    QImage image = m_data.toQImage().convertToFormat(QImage::Format_ARGB32);
+    QImage image = toQImage().convertToFormat(QImage::Format_ARGB32);
     ASSERT(!image.isNull());
 
     uchar* bits = image.bits();
     const int bytesPerLine = image.bytesPerLine();
 
-    for (int y = 0; y < m_size.height(); ++y) {
+    for (int y = 0; y < m_pixmap.height(); ++y) {
         quint32* scanLine = reinterpret_cast_ptr<quint32*>(bits + y * bytesPerLine);
-        for (int x = 0; x < m_size.width(); ++x) {
+        for (int x = 0; x < m_pixmap.width(); ++x) {
             QRgb& pixel = scanLine[x];
             pixel = qRgba(lookUpTable[qRed(pixel)],
                           lookUpTable[qGreen(pixel)],
@@ -187,10 +388,98 @@
         }
     }
 
-    m_data.m_pixmap = QPixmap::fromImage(image);
+    m_pixmap = QPixmap::fromImage(image);
 
     if (isPainting)
-        m_data.m_painter->begin(&m_data.m_pixmap);
+        painter->begin(&m_pixmap);
+}
+
+// ********************************************************
+ImageBufferData::ImageBufferData(const IntSize& size, bool accelerated)
+{
+    QPainter* painter = new QPainter;
+    m_painter = adoptPtr(painter);
+
+#if ENABLE(ACCELERATED_2D_CANVAS)
+    if (accelerated) {
+        m_impl = adoptPtr(new ImageBufferDataPrivateAccelerated(size));
+    } else
+#endif
+        m_impl = adoptPtr(new ImageBufferDataPrivateUnaccelerated(size));
+
+    if (!m_impl->paintDevice())
+        return;
+    if (!painter->begin(m_impl->paintDevice()))
+        return;
+
+    painter->setRenderHints(QPainter::Antialiasing | QPainter::HighQualityAntialiasing);
+    QPen pen = painter->pen();
+    pen.setColor(Qt::black);
+    pen.setWidth(1);
+    pen.setCapStyle(Qt::FlatCap);
+    pen.setJoinStyle(Qt::SvgMiterJoin);
+    pen.setMiterLimit(10);
+    painter->setPen(pen);
+    QBrush brush = painter->brush();
+    brush.setColor(Qt::black);
+    painter->setBrush(brush);
+    painter->setCompositionMode(QPainter::CompositionMode_SourceOver);
+}
+
+ImageBuffer::ImageBuffer(const IntSize& size, float /* resolutionScale */, ColorSpace, RenderingMode renderingMode, bool& success)
+    : m_data(size, renderingMode == Accelerated)
+    , m_size(size)
+    , m_logicalSize(size)
+{
+    success = m_data.m_painter && m_data.m_painter->isActive();
+    if (!success)
+        return;
+
+    m_context = adoptPtr(new GraphicsContext(m_data.m_painter.get()));
+}
+
+ImageBuffer::~ImageBuffer()
+{
+    m_data.m_painter->end();
+}
+
+GraphicsContext* ImageBuffer::context() const
+{
+    ASSERT(m_data.m_painter->isActive());
+
+    return m_context.get();
+}
+
+PassRefPtr<Image> ImageBuffer::copyImage(BackingStoreCopy copyBehavior, ScaleBehavior) const
+{
+    return m_data.m_impl->copyImage(copyBehavior);
+}
+
+BackingStoreCopy ImageBuffer::fastCopyImageMode()
+{
+    return DontCopyBackingStore;
+}
+
+void ImageBuffer::draw(GraphicsContext* destContext, ColorSpace styleColorSpace, const FloatRect& destRect, const FloatRect& srcRect,
+                       CompositeOperator op, BlendMode blendMode, bool useLowQualityScale)
+{
+    m_data.m_impl->draw(destContext, styleColorSpace, destRect, srcRect, op, blendMode, useLowQualityScale, destContext == context());
+}
+
+void ImageBuffer::drawPattern(GraphicsContext* destContext, const FloatRect& srcRect, const AffineTransform& patternTransform,
+                              const FloatPoint& phase, ColorSpace styleColorSpace, CompositeOperator op, const FloatRect& destRect)
+{
+    m_data.m_impl->drawPattern(destContext, srcRect, patternTransform, phase, styleColorSpace, op, destRect, destContext == context());
+}
+
+void ImageBuffer::clip(GraphicsContext* context, const FloatRect& floatRect) const
+{
+    m_data.m_impl->clip(context, floatRect);
+}
+
+void ImageBuffer::platformTransformColorSpace(const Vector<int>& lookUpTable)
+{
+    m_data.m_impl->platformTransformColorSpace(lookUpTable);
 }
 
 static inline void copyColorToRGBA(Color& from, uchar* to)
@@ -246,7 +535,7 @@
     const unsigned destBytesPerRow = 4 * rect.width();
 
     // NOTE: For unmultiplied data, we undo the premultiplication below.
-    QImage image = imageData.toQImage().convertToFormat(QImage::Format_ARGB32_Premultiplied);
+    QImage image = imageData.m_impl->toQImage().convertToFormat(QImage::Format_ARGB32_Premultiplied);
 
     ASSERT(!image.isNull());
 
@@ -330,7 +619,7 @@
 
     bool isPainting = m_data.m_painter->isActive();
     if (!isPainting)
-        m_data.m_painter->begin(&m_data.m_pixmap);
+        m_data.m_painter->begin(m_data.m_impl->paintDevice());
     else {
         m_data.m_painter->save();
 
@@ -371,11 +660,17 @@
     // gif, jpeg..., xpm) so skip the image/ to get the Qt image format used to encode
     // the m_pixmap image.
 
+    RefPtr<Image> image = copyImage(DontCopyBackingStore);
     QByteArray data;
-    if (!encodeImage(m_data.m_pixmap, mimeType.substring(sizeof "image"), quality, data))
+    if (!encodeImage(*image->nativeImageForCurrentFrame(), mimeType.substring(sizeof "image"), quality, data))
         return "data:,";
 
     return "data:" + mimeType + ";base64," + data.toBase64().data();
 }
 
+PlatformLayer* ImageBuffer::platformLayer() const
+{
+    return m_data.m_impl->platformLayer();
+}
+
 }

